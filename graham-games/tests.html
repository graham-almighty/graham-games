<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Graham Games Launcher - Unit Tests</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1a2e; color: #eee; font-family: 'Segoe UI', monospace; padding: 20px; }
  h1 { color: #c9a84c; margin-bottom: 4px; }
  .summary { color: #aaa; margin-bottom: 20px; font-size: 0.9rem; }
  .pass { color: #4caf50; }
  .fail { color: #ff4444; }
  .group-title { color: #c9a84c; font-size: 1.1rem; margin: 16px 0 6px; border-bottom: 1px solid #333; padding-bottom: 4px; }
  .test { padding: 4px 12px; font-size: 0.85rem; border-left: 3px solid transparent; margin: 2px 0; }
  .test.pass { border-left-color: #4caf50; }
  .test.fail { border-left-color: #ff4444; background: #ff444411; }
  .test .label { display: inline; }
  .test .detail { color: #888; font-size: 0.75rem; margin-left: 8px; }
  #results { max-width: 800px; }
</style>
</head>
<body>
<h1>Graham Games Launcher - Unit Tests</h1>
<div class="summary" id="summary"></div>
<div id="results"></div>

<script>
// ============================================================
// MINI TEST FRAMEWORK
// ============================================================
let _passed = 0, _failed = 0, _currentGroup = '';
const _results = document.getElementById('results');

function group(name) {
  _currentGroup = name;
  const h = document.createElement('div');
  h.className = 'group-title';
  h.textContent = name;
  _results.appendChild(h);
}

function assert(condition, name, detail) {
  const div = document.createElement('div');
  if (condition) {
    _passed++;
    div.className = 'test pass';
    div.innerHTML = '<span class="label">PASS</span> ' + name;
  } else {
    _failed++;
    div.className = 'test fail';
    div.innerHTML = '<span class="label">FAIL</span> ' + name + (detail ? '<span class="detail">(' + detail + ')</span>' : '');
  }
  _results.appendChild(div);
}

function assertEqual(actual, expected, name) {
  const pass = actual === expected;
  assert(pass, name, pass ? '' : 'expected ' + JSON.stringify(expected) + ', got ' + JSON.stringify(actual));
}

function assertDeepEqual(actual, expected, name) {
  const pass = JSON.stringify(actual) === JSON.stringify(expected);
  assert(pass, name, pass ? '' : 'expected ' + JSON.stringify(expected) + ', got ' + JSON.stringify(actual));
}

function assertApprox(actual, expected, tolerance, name) {
  const pass = Math.abs(actual - expected) <= tolerance;
  assert(pass, name, pass ? '' : 'expected ~' + expected + ', got ' + actual);
}

function showSummary() {
  const total = _passed + _failed;
  document.getElementById('summary').innerHTML =
    '<span class="pass">' + _passed + ' passed</span> / ' +
    '<span class="fail">' + _failed + ' failed</span> / ' +
    total + ' total';
  document.title = (_failed === 0 ? 'ALL PASS' : _failed + ' FAIL') + ' - Launcher Tests';
}

// ============================================================
// MOCK BROWSER APIs
// ============================================================
const mockStorage = {};
const localStorage = {
  getItem(key) { return mockStorage[key] || null; },
  setItem(key, val) { mockStorage[key] = val; },
  removeItem(key) { delete mockStorage[key]; },
  clear() { for (const k in mockStorage) delete mockStorage[k]; },
};

// ============================================================
// EXTRACT SOURCE CODE UNDER TEST
// (Re-declare the functions and data from graham-games/index.html)
// ============================================================
const GG_KEY = 'graham-games-data';

function ggLoad() {
  try { return JSON.parse(localStorage.getItem(GG_KEY)) || { gBux: 0, achievements: {}, shopPurchases: {} }; }
  catch(e) { return { gBux: 0, achievements: {}, shopPurchases: {} }; }
}

function ggSave(data) { localStorage.setItem(GG_KEY, JSON.stringify(data)); }

const ALL_ACHIEVEMENTS = [
  { group: 'HURGVIBBIT', items: [
    { id: 'hurv_first_timer',   name: 'First Timer',     desc: 'Complete a round',             reward: 5 },
    { id: 'hurv_combo_10',      name: 'Combo Starter',   desc: 'Get a 10x combo',              reward: 10 },
    { id: 'hurv_grade_a',       name: 'Grade A Student',  desc: 'Get an A grade',               reward: 15 },
    { id: 'hurv_grade_s',       name: 'Perfectionist',   desc: 'Get an S grade',               reward: 25 },
    { id: 'hurv_combo_25',      name: 'Combo King',      desc: 'Get a 25x combo',              reward: 20 },
    { id: 'hurv_hard_complete', name: 'Hard Rocker',     desc: 'Complete all rounds on Hard',   reward: 30 },
    { id: 'hurv_score_5000',    name: 'Score Hunter',    desc: 'Reach 5,000 points',           reward: 15 },
    { id: 'hurv_score_15000',   name: 'Score Legend',     desc: 'Reach 15,000 points',          reward: 25 },
    { id: 'hurv_flawless',      name: 'Flawless',        desc: '100% hit rate on any round',   reward: 30 },
    { id: 'hurv_rhythm_master', name: 'Rhythm Master',   desc: 'Get S grade on Hard',          reward: 50 },
  ]},
  { group: 'MINI LIFE', items: [
    { id: 'ml_new_home',          name: 'New Home',          desc: 'Start your first game',             reward: 5 },
    { id: 'ml_survivor',          name: 'Survivor',          desc: 'Survive 3 days',                    reward: 10 },
    { id: 'ml_week_warrior',      name: 'Week Warrior',      desc: 'Survive 7 days',                    reward: 20 },
    { id: 'ml_shopaholic',        name: 'Shopaholic',        desc: 'Buy any furniture',                 reward: 10 },
    { id: 'ml_interior_designer', name: 'Interior Designer', desc: 'Buy all 4 furniture items',         reward: 25 },
    { id: 'ml_fashion_icon',      name: 'Fashion Icon',      desc: 'Buy any outfit',                    reward: 10 },
    { id: 'ml_moving_up',         name: 'Moving Up',         desc: 'Buy the second floor',              reward: 20 },
    { id: 'ml_arcade_pro',        name: 'Arcade Pro',        desc: 'Score 25+ in computer minigame',    reward: 15 },
    { id: 'ml_high_roller',       name: 'High Roller',       desc: 'Have $500 at once',                 reward: 20 },
    { id: 'ml_living_large',      name: 'Living Large',      desc: 'Own everything',                    reward: 50 },
    { id: 'ml_bookworm',          name: 'Knowledge is Power', desc: 'Read 3 books',                     reward: 50 },
    { id: 'ml_gym_rat',           name: 'Gym Rat',            desc: 'Use the treadmill 3 times',        reward: 50 },
    { id: 'ml_helpful_neighbor',  name: 'Helpful Neighbor',   desc: 'Complete a town quest',             reward: 25 },
    { id: 'ml_town_hero',         name: 'Town Hero',          desc: 'Complete all 4 town quests',        reward: 50 },
    { id: 'ml_mansion_mogul',     name: 'Mansion Mogul',      desc: 'Purchase the mansion',              reward: 75 },
    { id: 'ml_first_shift',       name: 'First Shift',        desc: 'Complete a town job',               reward: 10 },
    { id: 'ml_hard_worker',       name: 'Hard Worker',        desc: 'Complete 10 town job shifts',       reward: 25 },
    { id: 'ml_employee_month',    name: 'Employee of the Month', desc: 'Complete 25 town job shifts',    reward: 50 },
  ]},
  { group: 'TOWER DEFENSE', items: [
    { id: 'td_first_blood',   name: 'First Blood',        desc: 'Kill your first enemy',           reward: 5 },
    { id: 'td_wave_5',        name: 'Getting Started',     desc: 'Complete wave 5',                 reward: 10 },
    { id: 'td_wave_10',       name: 'Holding Strong',      desc: 'Complete wave 10',                reward: 15 },
    { id: 'td_wave_20',       name: 'Veteran Defender',     desc: 'Complete wave 20',                reward: 25 },
    { id: 'td_all_towers',    name: 'Arsenal',             desc: 'Build all 4 tower types in one game', reward: 10 },
    { id: 'td_max_upgrade',   name: 'Fully Loaded',        desc: 'Fully upgrade any tower',         reward: 15 },
    { id: 'td_rich',          name: 'War Chest',           desc: 'Have 500+ gold at once',          reward: 10 },
    { id: 'td_no_leaks_10',   name: 'Impenetrable',        desc: 'Reach wave 10 with 20 lives',     reward: 25 },
    { id: 'td_speed_demon',   name: 'Speed Demon',         desc: 'Complete wave 15+ on 2x speed',   reward: 20 },
    { id: 'td_victory',       name: 'Supreme Commander',   desc: 'Beat wave 30',                    reward: 50 },
  ]},
  { group: 'ANCIENT WARFARE', items: [
    { id: 'aw_first_battle',   name: 'First Blood',        desc: 'Complete a battle',               reward: 5 },
    { id: 'aw_victor',         name: 'Victorious',          desc: 'Win a battle',                    reward: 10 },
    { id: 'aw_flawless',       name: 'Flawless Victory',    desc: 'Win without losing a unit',       reward: 30 },
    { id: 'aw_cavalry_charge', name: 'Cavalry Charge',      desc: 'Win with 5+ cavalry',             reward: 15 },
    { id: 'aw_archer_army',    name: 'Rain of Arrows',      desc: 'Win with 5+ archers',             reward: 15 },
    { id: 'aw_balanced',       name: 'Balanced Forces',      desc: 'Win using all 5 base unit types', reward: 20 },
    { id: 'aw_underdog',       name: 'Underdog',            desc: 'Win outnumbered 2:1',             reward: 25 },
    { id: 'aw_speed_demon',    name: 'Blitz',               desc: 'Win in under 30 seconds',         reward: 20 },
    { id: 'aw_commander',      name: 'Commander',            desc: 'Win 5 battles',                   reward: 25 },
    { id: 'aw_warlord',        name: 'Warlord',              desc: 'Win 10 battles',                  reward: 50 },
  ]},
];

const SHOP_ITEMS = [
  { id: 'hurv_neon_theme', name: 'Neon Theme',     desc: 'Neon color scheme for Hurgvibbit',        cost: 50,  icon: '&#127752;', game: 'Hurgvibbit' },
  { id: 'hurv_turbo_mode', name: 'Turbo Mode',     desc: 'Insanely fast difficulty for Hurgvibbit',  cost: 75,  icon: '&#9889;',   game: 'Hurgvibbit' },
  { id: 'ml_pet_dog',      name: 'Pet Dog',         desc: 'A loyal dog that follows you around',     cost: 50,  icon: '&#128054;', game: 'Mini Life' },
  { id: 'ml_pool',         name: 'Swimming Pool',   desc: 'Outdoor pool â€” restores fun & hygiene',   cost: 100, icon: '&#127946;', game: 'Mini Life' },
  { id: 'ml_basement',     name: 'Basement',        desc: 'Underground expansion with workbench',    cost: 150, icon: '&#127975;', game: 'Mini Life' },
  { id: 'td_flame_tower', name: 'Flame Tower',     desc: 'Unlocks the Flame tower type',            cost: 75,  icon: '&#128293;', game: 'Tower Defense' },
  { id: 'td_double_gold', name: 'War Bonds',       desc: 'Start each game with $200 instead of $100', cost: 50, icon: '&#128176;', game: 'Tower Defense' },
  { id: 'aw_war_elephant', name: 'War Elephant',   desc: 'Unlocks the War Elephant unit type',      cost: 75,  icon: '&#128024;', game: 'Ancient Warfare' },
  { id: 'aw_battle_horn',  name: 'Battle Horn',     desc: '+10% damage for first 10s of battle',     cost: 50,  icon: '&#128739;', game: 'Ancient Warfare' },
];

function purchaseItem(id, cost) {
  const data = ggLoad();
  if (data.shopPurchases[id] || data.gBux < cost) return false;
  data.gBux -= cost;
  data.shopPurchases[id] = true;
  ggSave(data);
  return true;
}

function ggUnlockAchievement(id, name, reward) {
  const data = ggLoad();
  if (data.achievements[id]) return false;
  data.achievements[id] = true;
  data.gBux += reward;
  ggSave(data);
  return true;
}

// ============================================================
// TESTS
// ============================================================

// --- ggLoad / ggSave ---
group('G Bux Data Functions: ggLoad / ggSave');

localStorage.clear();
{
  const data = ggLoad();
  assertEqual(data.gBux, 0, 'ggLoad returns gBux=0 on empty storage');
  assertDeepEqual(data.achievements, {}, 'ggLoad returns empty achievements on empty storage');
  assertDeepEqual(data.shopPurchases, {}, 'ggLoad returns empty shopPurchases on empty storage');
}

{
  const data = { gBux: 42, achievements: { 'test': true }, shopPurchases: { 'shop_item': true } };
  ggSave(data);
  const loaded = ggLoad();
  assertEqual(loaded.gBux, 42, 'ggSave persists and ggLoad reads gBux');
  assertEqual(loaded.achievements.test, true, 'ggSave persists achievements');
  assertEqual(loaded.shopPurchases.shop_item, true, 'ggSave persists shopPurchases');
}

localStorage.clear();
{
  localStorage.setItem(GG_KEY, 'NOT VALID JSON {{{');
  const data = ggLoad();
  assertEqual(data.gBux, 0, 'ggLoad handles corrupted JSON gracefully (returns default gBux)');
  assertDeepEqual(data.achievements, {}, 'ggLoad handles corrupted JSON (returns default achievements)');
  assertDeepEqual(data.shopPurchases, {}, 'ggLoad handles corrupted JSON (returns default shopPurchases)');
}

localStorage.clear();
{
  localStorage.setItem(GG_KEY, 'null');
  const data = ggLoad();
  assertEqual(data.gBux, 0, 'ggLoad handles null in storage gracefully');
}

localStorage.clear();
{
  localStorage.setItem(GG_KEY, '0');
  const data = ggLoad();
  assertEqual(data.gBux, 0, 'ggLoad handles falsy non-object in storage');
}

// --- Default shape ---
group('G Bux Data Shape');

localStorage.clear();
{
  const data = ggLoad();
  assert(typeof data === 'object' && data !== null, 'ggLoad returns an object');
  assert('gBux' in data, 'Default data has gBux property');
  assert('achievements' in data, 'Default data has achievements property');
  assert('shopPurchases' in data, 'Default data has shopPurchases property');
  assertEqual(typeof data.gBux, 'number', 'gBux is a number');
  assertEqual(typeof data.achievements, 'object', 'achievements is an object');
  assertEqual(typeof data.shopPurchases, 'object', 'shopPurchases is an object');
}

// --- Achievement Registry ---
group('Achievement Registry');

{
  const allItems = [];
  ALL_ACHIEVEMENTS.forEach(g => g.items.forEach(i => allItems.push(i)));
  assertEqual(allItems.length, 48, 'Total achievements count is 48');
}

{
  assertEqual(ALL_ACHIEVEMENTS.length, 4, 'Four achievement groups exist');
  assertEqual(ALL_ACHIEVEMENTS[0].group, 'HURGVIBBIT', 'First group is HURGVIBBIT');
  assertEqual(ALL_ACHIEVEMENTS[1].group, 'MINI LIFE', 'Second group is MINI LIFE');
  assertEqual(ALL_ACHIEVEMENTS[2].group, 'TOWER DEFENSE', 'Third group is TOWER DEFENSE');
  assertEqual(ALL_ACHIEVEMENTS[3].group, 'ANCIENT WARFARE', 'Fourth group is ANCIENT WARFARE');
}

{
  assertEqual(ALL_ACHIEVEMENTS[0].items.length, 10, 'Hurgvibbit has 10 achievements');
  assertEqual(ALL_ACHIEVEMENTS[1].items.length, 18, 'Mini Life has 18 achievements');
  assertEqual(ALL_ACHIEVEMENTS[2].items.length, 10, 'Tower Defense has 10 achievements');
  assertEqual(ALL_ACHIEVEMENTS[3].items.length, 10, 'Ancient Warfare has 10 achievements');
}

{
  const allIds = [];
  ALL_ACHIEVEMENTS.forEach(g => g.items.forEach(i => allIds.push(i.id)));
  const uniqueIds = new Set(allIds);
  assertEqual(uniqueIds.size, allIds.length, 'All achievement IDs are unique');
}

{
  let totalReward = 0;
  ALL_ACHIEVEMENTS.forEach(g => g.items.forEach(i => totalReward += i.reward));
  assertEqual(totalReward, 1145, 'Total earnable G Bux across all achievements is 1145');
}

{
  let hurvTotal = 0;
  ALL_ACHIEVEMENTS[0].items.forEach(i => hurvTotal += i.reward);
  assertEqual(hurvTotal, 225, 'Hurgvibbit total rewards = 225');
}

{
  let mlTotal = 0;
  ALL_ACHIEVEMENTS[1].items.forEach(i => mlTotal += i.reward);
  assertEqual(mlTotal, 520, 'Mini Life total rewards = 520');
}

{
  let tdTotal = 0;
  ALL_ACHIEVEMENTS[2].items.forEach(i => tdTotal += i.reward);
  assertEqual(tdTotal, 185, 'Tower Defense total rewards = 185');
}

{
  let awTotal = 0;
  ALL_ACHIEVEMENTS[3].items.forEach(i => awTotal += i.reward);
  assertEqual(awTotal, 215, 'Ancient Warfare total rewards = 215');
}

{
  // Check specific achievements exist with correct rewards
  const find = (id) => { let r = null; ALL_ACHIEVEMENTS.forEach(g => g.items.forEach(i => { if (i.id === id) r = i; })); return r; };
  assertEqual(find('hurv_first_timer').reward, 5, 'hurv_first_timer reward = 5');
  assertEqual(find('hurv_rhythm_master').reward, 50, 'hurv_rhythm_master reward = 50');
  assertEqual(find('ml_new_home').reward, 5, 'ml_new_home reward = 5');
  assertEqual(find('ml_living_large').reward, 50, 'ml_living_large reward = 50');
  assertEqual(find('ml_mansion_mogul').reward, 75, 'ml_mansion_mogul reward = 75');
  assertEqual(find('ml_bookworm').reward, 50, 'ml_bookworm reward = 50');
  assertEqual(find('ml_gym_rat').reward, 50, 'ml_gym_rat reward = 50');
  assertEqual(find('ml_town_hero').reward, 50, 'ml_town_hero reward = 50');
  assertEqual(find('ml_helpful_neighbor').reward, 25, 'ml_helpful_neighbor reward = 25');
  assertEqual(find('td_first_blood').reward, 5, 'td_first_blood reward = 5');
  assertEqual(find('td_victory').reward, 50, 'td_victory reward = 50');
  assertEqual(find('td_no_leaks_10').reward, 25, 'td_no_leaks_10 reward = 25');
  assertEqual(find('aw_first_battle').reward, 5, 'aw_first_battle reward = 5');
  assertEqual(find('aw_warlord').reward, 50, 'aw_warlord reward = 50');
  assertEqual(find('aw_flawless').reward, 30, 'aw_flawless reward = 30');
}

{
  // All achievements have required fields
  ALL_ACHIEVEMENTS.forEach(g => g.items.forEach(item => {
    assert(typeof item.id === 'string' && item.id.length > 0, 'Achievement "' + item.name + '" has non-empty id');
    assert(typeof item.name === 'string' && item.name.length > 0, 'Achievement "' + item.id + '" has non-empty name');
    assert(typeof item.desc === 'string' && item.desc.length > 0, 'Achievement "' + item.id + '" has non-empty desc');
    assert(typeof item.reward === 'number' && item.reward > 0, 'Achievement "' + item.id + '" has positive reward');
  }));
}

// --- Shop Items ---
group('Shop Items');

{
  assertEqual(SHOP_ITEMS.length, 9, 'Shop has 9 items');
}

{
  let totalCost = 0;
  SHOP_ITEMS.forEach(i => totalCost += i.cost);
  assertEqual(totalCost, 675, 'Total shop cost is 675 G Bux');
}

{
  assertEqual(SHOP_ITEMS[0].id, 'hurv_neon_theme', 'Shop item 0 is hurv_neon_theme');
  assertEqual(SHOP_ITEMS[0].cost, 50, 'Neon Theme costs 50');
  assertEqual(SHOP_ITEMS[1].id, 'hurv_turbo_mode', 'Shop item 1 is hurv_turbo_mode');
  assertEqual(SHOP_ITEMS[1].cost, 75, 'Turbo Mode costs 75');
  assertEqual(SHOP_ITEMS[2].id, 'ml_pet_dog', 'Shop item 2 is ml_pet_dog');
  assertEqual(SHOP_ITEMS[2].cost, 50, 'Pet Dog costs 50');
  assertEqual(SHOP_ITEMS[3].id, 'ml_pool', 'Shop item 3 is ml_pool');
  assertEqual(SHOP_ITEMS[3].cost, 100, 'Swimming Pool costs 100');
  assertEqual(SHOP_ITEMS[4].id, 'ml_basement', 'Shop item 4 is ml_basement');
  assertEqual(SHOP_ITEMS[4].cost, 150, 'Basement costs 150');
  assertEqual(SHOP_ITEMS[5].id, 'td_flame_tower', 'Shop item 5 is td_flame_tower');
  assertEqual(SHOP_ITEMS[5].cost, 75, 'Flame Tower costs 75');
  assertEqual(SHOP_ITEMS[6].id, 'td_double_gold', 'Shop item 6 is td_double_gold');
  assertEqual(SHOP_ITEMS[6].cost, 50, 'War Bonds costs 50');
  assertEqual(SHOP_ITEMS[7].id, 'aw_war_elephant', 'Shop item 7 is aw_war_elephant');
  assertEqual(SHOP_ITEMS[7].cost, 75, 'War Elephant costs 75');
  assertEqual(SHOP_ITEMS[8].id, 'aw_battle_horn', 'Shop item 8 is aw_battle_horn');
  assertEqual(SHOP_ITEMS[8].cost, 50, 'Battle Horn costs 50');
}

{
  const ids = SHOP_ITEMS.map(i => i.id);
  const unique = new Set(ids);
  assertEqual(unique.size, ids.length, 'All shop item IDs are unique');
}

{
  SHOP_ITEMS.forEach(item => {
    assert(typeof item.name === 'string' && item.name.length > 0, 'Shop item "' + item.id + '" has a name');
    assert(typeof item.desc === 'string' && item.desc.length > 0, 'Shop item "' + item.id + '" has a description');
    assert(typeof item.cost === 'number' && item.cost > 0, 'Shop item "' + item.id + '" has positive cost');
    assert(typeof item.game === 'string', 'Shop item "' + item.id + '" has game association');
  });
}

{
  const hurvItems = SHOP_ITEMS.filter(i => i.game === 'Hurgvibbit');
  const mlItems = SHOP_ITEMS.filter(i => i.game === 'Mini Life');
  const tdItems = SHOP_ITEMS.filter(i => i.game === 'Tower Defense');
  const awItems = SHOP_ITEMS.filter(i => i.game === 'Ancient Warfare');
  assertEqual(hurvItems.length, 2, '2 shop items for Hurgvibbit');
  assertEqual(mlItems.length, 3, '3 shop items for Mini Life');
  assertEqual(tdItems.length, 2, '2 shop items for Tower Defense');
  assertEqual(awItems.length, 2, '2 shop items for Ancient Warfare');
}

// --- Achievement Unlock Logic ---
group('Achievement Unlock Logic');

localStorage.clear();
{
  const result = ggUnlockAchievement('test_ach', 'Test', 10);
  assertEqual(result, true, 'First unlock returns true');
  const data = ggLoad();
  assertEqual(data.gBux, 10, 'G Bux increased by reward amount');
  assertEqual(data.achievements.test_ach, true, 'Achievement marked as earned');
}

{
  const result = ggUnlockAchievement('test_ach', 'Test', 10);
  assertEqual(result, false, 'Duplicate unlock returns false');
  const data = ggLoad();
  assertEqual(data.gBux, 10, 'G Bux not double-awarded on duplicate');
}

localStorage.clear();
{
  ggUnlockAchievement('a1', 'A1', 5);
  ggUnlockAchievement('a2', 'A2', 15);
  ggUnlockAchievement('a3', 'A3', 30);
  const data = ggLoad();
  assertEqual(data.gBux, 50, 'Multiple achievement rewards accumulate correctly (5+15+30=50)');
  assertEqual(Object.keys(data.achievements).length, 3, 'Three achievements tracked');
}

// --- Shop Purchase Logic ---
group('Shop Purchase Logic');

localStorage.clear();
{
  // Set up with 100 G Bux
  ggSave({ gBux: 100, achievements: {}, shopPurchases: {} });
  const result = purchaseItem('hurv_neon_theme', 50);
  assertEqual(result, true, 'Purchase succeeds with sufficient balance');
  const data = ggLoad();
  assertEqual(data.gBux, 50, 'Balance reduced by cost after purchase');
  assertEqual(data.shopPurchases.hurv_neon_theme, true, 'Item marked as purchased');
}

{
  const result = purchaseItem('hurv_neon_theme', 50);
  assertEqual(result, false, 'Cannot purchase already-owned item');
  const data = ggLoad();
  assertEqual(data.gBux, 50, 'Balance unchanged on double-purchase attempt');
}

localStorage.clear();
{
  ggSave({ gBux: 10, achievements: {}, shopPurchases: {} });
  const result = purchaseItem('ml_basement', 150);
  assertEqual(result, false, 'Purchase fails with insufficient balance');
  const data = ggLoad();
  assertEqual(data.gBux, 10, 'Balance unchanged on failed purchase');
  assertEqual(data.shopPurchases.ml_basement, undefined, 'Item not marked as purchased on fail');
}

localStorage.clear();
{
  ggSave({ gBux: 50, achievements: {}, shopPurchases: {} });
  purchaseItem('ml_pet_dog', 50);
  const data = ggLoad();
  assertEqual(data.gBux, 0, 'Purchase can bring balance to exactly 0');
  assertEqual(data.shopPurchases.ml_pet_dog, true, 'Item purchased at exact balance');
}

localStorage.clear();
{
  ggSave({ gBux: 675, achievements: {}, shopPurchases: {} });
  SHOP_ITEMS.forEach(item => {
    purchaseItem(item.id, item.cost);
  });
  const data = ggLoad();
  assertEqual(data.gBux, 0, 'Buying all 9 items from 675 G Bux leaves 0');
  assertEqual(Object.keys(data.shopPurchases).length, 9, 'All 9 items purchased');
}

// --- Economy Totals ---
group('Economy Balance');

{
  let totalEarnable = 0;
  ALL_ACHIEVEMENTS.forEach(g => g.items.forEach(i => totalEarnable += i.reward));
  let totalShopCost = 0;
  SHOP_ITEMS.forEach(i => totalShopCost += i.cost);
  assertEqual(totalEarnable, 1145, 'Total earnable G Bux = 1145');
  assertEqual(totalShopCost, 675, 'Total shop cost = 675');
  assert(totalEarnable > totalShopCost, 'Earnable exceeds shop cost (player can buy everything)');
  assertEqual(totalEarnable - totalShopCost, 470, 'Surplus after buying everything = 470');
}

// --- Cross-references ---
group('Cross-references: Achievement IDs vs Shop IDs');

{
  const achIds = new Set();
  ALL_ACHIEVEMENTS.forEach(g => g.items.forEach(i => achIds.add(i.id)));
  const shopIds = new Set(SHOP_ITEMS.map(i => i.id));
  // Shop IDs should NOT overlap with achievement IDs (different namespaces)
  let overlap = 0;
  shopIds.forEach(id => { if (achIds.has(id)) overlap++; });
  assertEqual(overlap, 0, 'No overlap between achievement IDs and shop item IDs');
}

// --- GG_KEY constant ---
group('Constants');

{
  assertEqual(GG_KEY, 'graham-games-data', 'GG_KEY is graham-games-data');
}

// --- Edge cases ---
group('Edge Cases');

localStorage.clear();
{
  // ggLoad with undefined
  localStorage.removeItem(GG_KEY);
  const data = ggLoad();
  assertEqual(data.gBux, 0, 'ggLoad returns default when key is missing');
}

{
  // Save then load preserves exact data
  const original = { gBux: 999, achievements: { a: true, b: true }, shopPurchases: { x: true } };
  ggSave(original);
  const loaded = ggLoad();
  assertEqual(loaded.gBux, 999, 'Exact gBux preserved through save/load cycle');
  assertEqual(Object.keys(loaded.achievements).length, 2, 'Exact achievements count preserved');
  assertEqual(Object.keys(loaded.shopPurchases).length, 1, 'Exact shopPurchases count preserved');
}

localStorage.clear();
{
  // Unlock achievement with 0 starting balance
  const result = ggUnlockAchievement('zero_start', 'Zero', 25);
  const data = ggLoad();
  assertEqual(data.gBux, 25, 'Achievement unlock from 0 balance works correctly');
}

localStorage.clear();
{
  // Multiple rapid save/load cycles
  for (let i = 0; i < 100; i++) {
    ggSave({ gBux: i, achievements: {}, shopPurchases: {} });
  }
  const data = ggLoad();
  assertEqual(data.gBux, 99, 'Last save wins after 100 rapid save cycles');
}

// --- Achievement Name Verification ---
group('Achievement Names and Descriptions');

{
  const find = (id) => { let r = null; ALL_ACHIEVEMENTS.forEach(g => g.items.forEach(i => { if (i.id === id) r = i; })); return r; };
  assertEqual(find('ml_bookworm').name, 'Knowledge is Power', 'ml_bookworm name is Knowledge is Power');
  assertEqual(find('ml_gym_rat').name, 'Gym Rat', 'ml_gym_rat name is Gym Rat');
  assertEqual(find('ml_helpful_neighbor').name, 'Helpful Neighbor', 'ml_helpful_neighbor name is Helpful Neighbor');
  assertEqual(find('ml_town_hero').name, 'Town Hero', 'ml_town_hero name is Town Hero');
  assertEqual(find('ml_mansion_mogul').name, 'Mansion Mogul', 'ml_mansion_mogul name is Mansion Mogul');
  assertEqual(find('hurv_grade_s').name, 'Perfectionist', 'hurv_grade_s name is Perfectionist');
  assertEqual(find('hurv_flawless').name, 'Flawless', 'hurv_flawless name is Flawless');
}

// --- Shop Item Names ---
group('Shop Item Details');

{
  const neon = SHOP_ITEMS.find(i => i.id === 'hurv_neon_theme');
  assertEqual(neon.name, 'Neon Theme', 'Neon Theme name correct');
  assertEqual(neon.game, 'Hurgvibbit', 'Neon Theme game is Hurgvibbit');

  const turbo = SHOP_ITEMS.find(i => i.id === 'hurv_turbo_mode');
  assertEqual(turbo.name, 'Turbo Mode', 'Turbo Mode name correct');
  assertEqual(turbo.game, 'Hurgvibbit', 'Turbo Mode game is Hurgvibbit');

  const dog = SHOP_ITEMS.find(i => i.id === 'ml_pet_dog');
  assertEqual(dog.name, 'Pet Dog', 'Pet Dog name correct');
  assertEqual(dog.game, 'Mini Life', 'Pet Dog game is Mini Life');

  const pool = SHOP_ITEMS.find(i => i.id === 'ml_pool');
  assertEqual(pool.name, 'Swimming Pool', 'Swimming Pool name correct');

  const basement = SHOP_ITEMS.find(i => i.id === 'ml_basement');
  assertEqual(basement.name, 'Basement', 'Basement name correct');

  const flame = SHOP_ITEMS.find(i => i.id === 'td_flame_tower');
  assertEqual(flame.name, 'Flame Tower', 'Flame Tower name correct');
  assertEqual(flame.game, 'Tower Defense', 'Flame Tower game is Tower Defense');

  const warBonds = SHOP_ITEMS.find(i => i.id === 'td_double_gold');
  assertEqual(warBonds.name, 'War Bonds', 'War Bonds name correct');
  assertEqual(warBonds.game, 'Tower Defense', 'War Bonds game is Tower Defense');

  const elephant = SHOP_ITEMS.find(i => i.id === 'aw_war_elephant');
  assertEqual(elephant.name, 'War Elephant', 'War Elephant name correct');
  assertEqual(elephant.game, 'Ancient Warfare', 'War Elephant game is Ancient Warfare');
  assertEqual(elephant.cost, 75, 'War Elephant costs 75');

  const horn = SHOP_ITEMS.find(i => i.id === 'aw_battle_horn');
  assertEqual(horn.name, 'Battle Horn', 'Battle Horn name correct');
  assertEqual(horn.game, 'Ancient Warfare', 'Battle Horn game is Ancient Warfare');
  assertEqual(horn.cost, 50, 'Battle Horn costs 50');
}

// --- Integration: Earn achievements then buy items ---
group('Integration: Earn and Spend');

localStorage.clear();
{
  // Earn enough to buy something
  ggUnlockAchievement('hurv_first_timer', 'First Timer', 5);
  ggUnlockAchievement('hurv_combo_10', 'Combo Starter', 10);
  ggUnlockAchievement('hurv_grade_a', 'Grade A', 15);
  ggUnlockAchievement('hurv_grade_s', 'Perfectionist', 25);
  // Total: 55 G Bux
  let data = ggLoad();
  assertEqual(data.gBux, 55, 'Accumulated 55 G Bux from 4 achievements');

  // Buy Neon Theme (50)
  purchaseItem('hurv_neon_theme', 50);
  data = ggLoad();
  assertEqual(data.gBux, 5, 'After buying Neon Theme (50), balance is 5');

  // Cannot buy Turbo Mode (75) - insufficient
  const result = purchaseItem('hurv_turbo_mode', 75);
  assertEqual(result, false, 'Cannot buy Turbo Mode with only 5 G Bux');
  data = ggLoad();
  assertEqual(data.gBux, 5, 'Balance unchanged after failed purchase');

  // Earn more
  ggUnlockAchievement('hurv_combo_25', 'Combo King', 20);
  ggUnlockAchievement('hurv_hard_complete', 'Hard Rocker', 30);
  ggUnlockAchievement('hurv_score_5000', 'Score Hunter', 15);
  ggUnlockAchievement('hurv_score_15000', 'Score Legend', 25);
  data = ggLoad();
  assertEqual(data.gBux, 95, 'After earning 90 more, balance is 95');

  // Now buy Turbo Mode
  purchaseItem('hurv_turbo_mode', 75);
  data = ggLoad();
  assertEqual(data.gBux, 20, 'After buying Turbo Mode (75), balance is 20');
}

// ============================================================
// SCHOOL MODE FUNCTIONS (replicated from index.html)
// ============================================================
const BLOCKED_GAMES = ['combat', 'ancient-warfare'];

function getSchoolMode() {
  const data = ggLoad();
  return data.schoolMode || null;
}
function setSchoolMode(sm) {
  const data = ggLoad();
  data.schoolMode = sm;
  ggSave(data);
}

function getQuizInterval() {
  const sm = getSchoolMode();
  return (sm && sm.interval) ? sm.interval : 120;
}
function formatInterval(seconds) {
  if (seconds < 60) return seconds + 's';
  const m = seconds / 60;
  return m + (m === 1 ? ' min' : ' min');
}

const SCIENCE_QUESTIONS = [
  { q: 'What planet is closest to the Sun?', a: 'Mercury', w: ['Venus', 'Earth', 'Mars'] },
  { q: 'What gas do plants absorb from the air?', a: 'Carbon dioxide', w: ['Oxygen', 'Nitrogen', 'Helium'] },
  { q: 'How many legs does an insect have?', a: '6', w: ['4', '8', '10'] },
  { q: 'What is the largest planet in our solar system?', a: 'Jupiter', w: ['Saturn', 'Neptune', 'Earth'] },
  { q: 'What do you call animals that eat only plants?', a: 'Herbivores', w: ['Carnivores', 'Omnivores', 'Insectivores'] },
  { q: 'Water freezes at what temperature in Fahrenheit?', a: '32 degrees', w: ['0 degrees', '100 degrees', '212 degrees'] },
  { q: 'What is the hardest natural substance on Earth?', a: 'Diamond', w: ['Gold', 'Iron', 'Quartz'] },
  { q: 'What organ pumps blood through the body?', a: 'Heart', w: ['Lungs', 'Brain', 'Liver'] },
  { q: 'What are the three states of matter?', a: 'Solid, liquid, gas', w: ['Hot, warm, cold', 'Big, medium, small', 'Light, dark, clear'] },
  { q: 'What force keeps us on the ground?', a: 'Gravity', w: ['Magnetism', 'Friction', 'Wind'] },
  { q: 'What star is closest to Earth?', a: 'The Sun', w: ['Polaris', 'Sirius', 'Alpha Centauri'] },
  { q: 'What is a baby frog called?', a: 'Tadpole', w: ['Cub', 'Pup', 'Kitten'] },
  { q: 'Which planet is known as the Red Planet?', a: 'Mars', w: ['Venus', 'Jupiter', 'Saturn'] },
  { q: 'What do caterpillars turn into?', a: 'Butterflies', w: ['Beetles', 'Spiders', 'Dragonflies'] },
  { q: 'How many bones does an adult human have?', a: '206', w: ['100', '306', '150'] },
  { q: 'What is the boiling point of water in Celsius?', a: '100 degrees', w: ['50 degrees', '200 degrees', '0 degrees'] },
  { q: 'What type of animal is a whale?', a: 'Mammal', w: ['Fish', 'Reptile', 'Amphibian'] },
  { q: 'What is the largest ocean on Earth?', a: 'Pacific Ocean', w: ['Atlantic Ocean', 'Indian Ocean', 'Arctic Ocean'] },
  { q: 'What part of the plant makes food from sunlight?', a: 'Leaves', w: ['Roots', 'Stem', 'Flowers'] },
  { q: 'What is the process plants use to make food called?', a: 'Photosynthesis', w: ['Respiration', 'Digestion', 'Evaporation'] },
  { q: 'What are the tiny building blocks of all living things?', a: 'Cells', w: ['Atoms', 'Molecules', 'Tissues'] },
  { q: 'Which gas makes up most of Earth\'s atmosphere?', a: 'Nitrogen', w: ['Oxygen', 'Carbon dioxide', 'Hydrogen'] },
  { q: 'What type of rock is formed by volcanic eruption?', a: 'Igneous', w: ['Sedimentary', 'Metamorphic', 'Limestone'] },
  { q: 'What is the layer of air around the Earth called?', a: 'Atmosphere', w: ['Biosphere', 'Lithosphere', 'Hydrosphere'] },
  { q: 'What is the speed of light approximately?', a: '186,000 miles per second', w: ['1,000 miles per hour', '700 miles per hour', '86,000 miles per second'] },
];

const ENGLISH_QUESTIONS = [
  { q: 'What is a synonym for "happy"?', a: 'Joyful', w: ['Sad', 'Angry', 'Tired'] },
  { q: 'What is the opposite of "hot"?', a: 'Cold', w: ['Warm', 'Wet', 'Dry'] },
  { q: 'Which word is a noun?', a: 'Dog', w: ['Run', 'Quickly', 'Beautiful'] },
  { q: 'Which word is a verb?', a: 'Jump', w: ['Table', 'Happy', 'Slowly'] },
  { q: 'Which is spelled correctly?', a: 'Necessary', w: ['Necessery', 'Neccessary', 'Necesary'] },
  { q: 'What is the plural of "child"?', a: 'Children', w: ['Childs', 'Childrens', 'Childes'] },
  { q: 'Which word is an adjective?', a: 'Bright', w: ['Walk', 'House', 'Quickly'] },
  { q: 'What is a synonym for "big"?', a: 'Large', w: ['Small', 'Tiny', 'Short'] },
  { q: 'What is the opposite of "begin"?', a: 'End', w: ['Start', 'Continue', 'Pause'] },
  { q: 'Which is spelled correctly?', a: 'Because', w: ['Becuase', 'Becouse', 'Becuz'] },
  { q: 'What is the past tense of "run"?', a: 'Ran', w: ['Runned', 'Runed', 'Running'] },
  { q: 'Which word is an adverb?', a: 'Slowly', w: ['Slow', 'Table', 'Green'] },
  { q: 'What punctuation ends a question?', a: 'Question mark', w: ['Period', 'Exclamation mark', 'Comma'] },
  { q: 'Which is a complete sentence?', a: 'The cat sat on the mat.', w: ['Running fast.', 'Very big.', 'Under the table.'] },
  { q: 'What is a synonym for "small"?', a: 'Tiny', w: ['Huge', 'Wide', 'Tall'] },
  { q: 'What is the opposite of "light"?', a: 'Dark', w: ['Bright', 'White', 'Clear'] },
  { q: 'Which is spelled correctly?', a: 'Separate', w: ['Seperate', 'Separete', 'Seprate'] },
  { q: 'What is the plural of "mouse"?', a: 'Mice', w: ['Mouses', 'Mices', 'Mouse'] },
  { q: 'What part of speech is "the"?', a: 'Article', w: ['Noun', 'Verb', 'Adjective'] },
  { q: 'What is the past tense of "eat"?', a: 'Ate', w: ['Eated', 'Eaten', 'Eating'] },
  { q: 'Which word means "to find out"?', a: 'Discover', w: ['Forget', 'Hide', 'Ignore'] },
  { q: 'What is a group of related sentences called?', a: 'Paragraph', w: ['Chapter', 'Word', 'Letter'] },
  { q: 'Which is a proper noun?', a: 'London', w: ['city', 'dog', 'river'] },
  { q: 'What is the opposite of "quiet"?', a: 'Loud', w: ['Silent', 'Soft', 'Calm'] },
  { q: 'What does "abbreviate" mean?', a: 'To shorten', w: ['To lengthen', 'To repeat', 'To replace'] },
];

const HISTORY_QUESTIONS = [
  { q: 'Who was the first President of the United States?', a: 'George Washington', w: ['Thomas Jefferson', 'Abraham Lincoln', 'John Adams'] },
  { q: 'What ancient civilization built the pyramids?', a: 'Egyptians', w: ['Romans', 'Greeks', 'Aztecs'] },
  { q: 'Who invented the light bulb?', a: 'Thomas Edison', w: ['Benjamin Franklin', 'Nikola Tesla', 'Alexander Bell'] },
  { q: 'What country gifted the Statue of Liberty to the US?', a: 'France', w: ['England', 'Spain', 'Italy'] },
  { q: 'What year did Christopher Columbus reach the Americas?', a: '1492', w: ['1776', '1066', '1620'] },
  { q: 'What famous ship sank in 1912?', a: 'Titanic', w: ['Mayflower', 'Santa Maria', 'Lusitania'] },
  { q: 'Who was known as the "King of Rock and Roll"?', a: 'Elvis Presley', w: ['Michael Jackson', 'John Lennon', 'Chuck Berry'] },
  { q: 'What ancient wonder was in the city of Babylon?', a: 'Hanging Gardens', w: ['Great Pyramid', 'Colosseum', 'Parthenon'] },
  { q: 'Which president freed the slaves?', a: 'Abraham Lincoln', w: ['George Washington', 'Thomas Jefferson', 'Theodore Roosevelt'] },
  { q: 'What is the longest wall ever built?', a: 'Great Wall of China', w: ['Hadrian\'s Wall', 'Berlin Wall', 'Wall of Babylon'] },
  { q: 'Who was the first person to walk on the Moon?', a: 'Neil Armstrong', w: ['Buzz Aldrin', 'John Glenn', 'Yuri Gagarin'] },
  { q: 'What ancient civilization created the Olympic Games?', a: 'Greeks', w: ['Romans', 'Egyptians', 'Persians'] },
  { q: 'What holiday celebrates American independence?', a: 'Fourth of July', w: ['Thanksgiving', 'Memorial Day', 'Labor Day'] },
  { q: 'Who wrote the Declaration of Independence?', a: 'Thomas Jefferson', w: ['George Washington', 'Benjamin Franklin', 'James Madison'] },
  { q: 'What was the name of the ship the Pilgrims sailed on?', a: 'Mayflower', w: ['Santa Maria', 'Titanic', 'Discovery'] },
  { q: 'What empire built the Colosseum in Rome?', a: 'Roman Empire', w: ['Greek Empire', 'Ottoman Empire', 'Persian Empire'] },
  { q: 'Who painted the Mona Lisa?', a: 'Leonardo da Vinci', w: ['Michelangelo', 'Picasso', 'Van Gogh'] },
  { q: 'What continent did ancient Aztecs live on?', a: 'North America', w: ['South America', 'Europe', 'Africa'] },
  { q: 'Who invented the telephone?', a: 'Alexander Graham Bell', w: ['Thomas Edison', 'Nikola Tesla', 'Samuel Morse'] },
  { q: 'What was the first animal sent into space?', a: 'Fruit flies', w: ['Dog', 'Monkey', 'Cat'] },
  { q: 'Which explorer sailed around the world first?', a: 'Ferdinand Magellan', w: ['Christopher Columbus', 'Marco Polo', 'Vasco da Gama'] },
  { q: 'What material did ancient Egyptians write on?', a: 'Papyrus', w: ['Paper', 'Clay', 'Silk'] },
  { q: 'What famous document begins with "We the People"?', a: 'U.S. Constitution', w: ['Declaration of Independence', 'Bill of Rights', 'Magna Carta'] },
  { q: 'What is the oldest known civilization?', a: 'Sumerians', w: ['Egyptians', 'Greeks', 'Chinese'] },
  { q: 'Who discovered gravity by watching an apple fall?', a: 'Isaac Newton', w: ['Galileo', 'Einstein', 'Copernicus'] },
];

function generateMathQuestion() {
  const ops = ['+', '-', '\u00d7', '\u00f7'];
  const op = ops[Math.floor(Math.random() * ops.length)];
  let a, b, answer;
  if (op === '+') {
    a = Math.floor(Math.random() * 12) + 1;
    b = Math.floor(Math.random() * 12) + 1;
    answer = a + b;
  } else if (op === '-') {
    a = Math.floor(Math.random() * 12) + 1;
    b = Math.floor(Math.random() * a) + 1;
    answer = a - b;
  } else if (op === '\u00d7') {
    a = Math.floor(Math.random() * 12) + 1;
    b = Math.floor(Math.random() * 12) + 1;
    answer = a * b;
  } else {
    b = Math.floor(Math.random() * 11) + 2;
    answer = Math.floor(Math.random() * 12) + 1;
    a = b * answer;
  }
  const wrongSet = new Set();
  while (wrongSet.size < 3) {
    let w = answer + (Math.floor(Math.random() * 10) - 5);
    if (w !== answer && w >= 0) wrongSet.add(w);
  }
  return { q: 'What is ' + a + ' ' + op + ' ' + b + '?', a: String(answer), w: Array.from(wrongSet).map(String) };
}

let recentQuestions = [];

function getQuestion(subject) {
  let question;
  if (subject === 'math') {
    question = generateMathQuestion();
  } else {
    const bank = subject === 'science' ? SCIENCE_QUESTIONS : subject === 'english' ? ENGLISH_QUESTIONS : HISTORY_QUESTIONS;
    const available = bank.filter((_, i) => !recentQuestions.includes(subject + '_' + i));
    if (available.length === 0) { recentQuestions = []; return getQuestion(subject); }
    const idx = Math.floor(Math.random() * available.length);
    const origIdx = bank.indexOf(available[idx]);
    question = available[idx];
    recentQuestions.push(subject + '_' + origIdx);
    if (recentQuestions.length > 8) recentQuestions.shift();
  }
  const options = [question.a, ...question.w];
  for (let i = options.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [options[i], options[j]] = [options[j], options[i]];
  }
  return { question: question.q, correct: question.a, options: options };
}

// ============================================================
// SCHOOL MODE TESTS
// ============================================================

group('School Mode: State Helpers');

localStorage.clear();
{
  const sm = getSchoolMode();
  assertEqual(sm, null, 'getSchoolMode returns null when no school mode set');
}

{
  setSchoolMode({ enabled: true, pin: '1234', subject: 'math' });
  const sm = getSchoolMode();
  assertEqual(sm.enabled, true, 'setSchoolMode persists enabled flag');
  assertEqual(sm.pin, '1234', 'setSchoolMode persists pin');
  assertEqual(sm.subject, 'math', 'setSchoolMode persists subject');
}

{
  setSchoolMode(null);
  const sm = getSchoolMode();
  assertEqual(sm, null, 'setSchoolMode(null) clears school mode');
}

{
  // Verify school mode doesn't clobber existing data
  localStorage.clear();
  ggSave({ gBux: 100, achievements: { test: true }, shopPurchases: { item: true } });
  setSchoolMode({ enabled: true, pin: '5678', subject: 'science' });
  const data = ggLoad();
  assertEqual(data.gBux, 100, 'Setting school mode preserves gBux');
  assertEqual(data.achievements.test, true, 'Setting school mode preserves achievements');
  assertEqual(data.shopPurchases.item, true, 'Setting school mode preserves shopPurchases');
  assertEqual(data.schoolMode.pin, '5678', 'School mode data saved alongside existing data');
}

group('School Mode: Enable / Disable Round-Trip');

localStorage.clear();
{
  // Enable
  setSchoolMode({ enabled: true, pin: '0000', subject: 'english' });
  let sm = getSchoolMode();
  assertEqual(sm.enabled, true, 'School mode enabled after set');
  assertEqual(sm.subject, 'english', 'Subject is english');

  // Disable
  setSchoolMode(null);
  sm = getSchoolMode();
  assertEqual(sm, null, 'School mode disabled after set to null');

  // Re-enable with different subject
  setSchoolMode({ enabled: true, pin: '9999', subject: 'history' });
  sm = getSchoolMode();
  assertEqual(sm.subject, 'history', 'Subject updated to history on re-enable');
  assertEqual(sm.pin, '9999', 'PIN updated on re-enable');
}

group('School Mode: PIN Validation');

{
  // Valid 4-digit PINs
  assert(/^\d{4}$/.test('1234'), 'PIN "1234" is valid');
  assert(/^\d{4}$/.test('0000'), 'PIN "0000" is valid');
  assert(/^\d{4}$/.test('9999'), 'PIN "9999" is valid');

  // Invalid PINs
  assert(!/^\d{4}$/.test('123'), 'PIN "123" (too short) is invalid');
  assert(!/^\d{4}$/.test('12345'), 'PIN "12345" (too long) is invalid');
  assert(!/^\d{4}$/.test('abcd'), 'PIN "abcd" (letters) is invalid');
  assert(!/^\d{4}$/.test('12ab'), 'PIN "12ab" (mixed) is invalid');
  assert(!/^\d{4}$/.test(''), 'PIN "" (empty) is invalid');
  assert(!/^\d{4}$/.test('12 4'), 'PIN "12 4" (space) is invalid');
}

{
  // PIN match/mismatch
  const pin = '4567';
  const confirm = '4567';
  const wrongConfirm = '4568';
  assertEqual(pin === confirm, true, 'Matching PINs pass confirmation');
  assertEqual(pin === wrongConfirm, false, 'Mismatched PINs fail confirmation');
}

{
  // Wrong PIN rejection
  localStorage.clear();
  setSchoolMode({ enabled: true, pin: '1111', subject: 'math' });
  const sm = getSchoolMode();
  assertEqual('2222' !== sm.pin, true, 'Wrong PIN "2222" is rejected against "1111"');
  assertEqual('1111' === sm.pin, true, 'Correct PIN "1111" is accepted');
}

group('School Mode: Quiz Interval');

localStorage.clear();
{
  // Default interval when not set
  const interval = getQuizInterval();
  assertEqual(interval, 120, 'Default quiz interval is 120s when school mode off');
}

{
  // Default interval when schoolMode has no interval field (backward compat)
  setSchoolMode({ enabled: true, pin: '1234', subject: 'math' });
  const interval = getQuizInterval();
  assertEqual(interval, 120, 'Default quiz interval is 120s when interval field missing');
}

{
  // Custom intervals
  setSchoolMode({ enabled: true, pin: '1234', subject: 'math', interval: 30 });
  assertEqual(getQuizInterval(), 30, 'Quiz interval = 30 when set to 30');

  setSchoolMode({ enabled: true, pin: '1234', subject: 'math', interval: 60 });
  assertEqual(getQuizInterval(), 60, 'Quiz interval = 60 when set to 60');

  setSchoolMode({ enabled: true, pin: '1234', subject: 'math', interval: 180 });
  assertEqual(getQuizInterval(), 180, 'Quiz interval = 180 when set to 180');

  setSchoolMode({ enabled: true, pin: '1234', subject: 'math', interval: 240 });
  assertEqual(getQuizInterval(), 240, 'Quiz interval = 240 when set to 240');

  setSchoolMode({ enabled: true, pin: '1234', subject: 'math', interval: 300 });
  assertEqual(getQuizInterval(), 300, 'Quiz interval = 300 when set to 300');
}

{
  // Interval persists through save/load
  localStorage.clear();
  setSchoolMode({ enabled: true, pin: '5555', subject: 'science', interval: 60 });
  const sm = getSchoolMode();
  assertEqual(sm.interval, 60, 'Interval persists in localStorage');
}

{
  // formatInterval helper
  assertEqual(formatInterval(30), '30s', 'formatInterval(30) = "30s"');
  assertEqual(formatInterval(60), '1 min', 'formatInterval(60) = "1 min"');
  assertEqual(formatInterval(120), '2 min', 'formatInterval(120) = "2 min"');
  assertEqual(formatInterval(180), '3 min', 'formatInterval(180) = "3 min"');
  assertEqual(formatInterval(240), '4 min', 'formatInterval(240) = "4 min"');
  assertEqual(formatInterval(300), '5 min', 'formatInterval(300) = "5 min"');
}

{
  // Valid interval options
  const validIntervals = [30, 60, 120, 180, 240, 300];
  validIntervals.forEach(v => {
    setSchoolMode({ enabled: true, pin: '0000', subject: 'math', interval: v });
    assertEqual(getQuizInterval(), v, 'getQuizInterval returns ' + v + ' when set to ' + v);
  });
}

group('School Mode: Blocked Games');

{
  assertEqual(BLOCKED_GAMES.length, 2, 'Two games are blocked');
  assert(BLOCKED_GAMES.includes('combat'), 'Combat is in blocked list');
  assert(BLOCKED_GAMES.includes('ancient-warfare'), 'Ancient Warfare is in blocked list');
  assert(!BLOCKED_GAMES.includes('hurgvibbit'), 'Hurgvibbit is NOT blocked');
  assert(!BLOCKED_GAMES.includes('flying-ace'), 'Flying Ace is NOT blocked');
  assert(!BLOCKED_GAMES.includes('mini-life'), 'Mini Life is NOT blocked');
  assert(!BLOCKED_GAMES.includes('tower-defense'), 'Tower Defense is NOT blocked');
}

group('School Mode: Persistence Across Refresh');

localStorage.clear();
{
  setSchoolMode({ enabled: true, pin: '3456', subject: 'science' });
  // Simulate refresh by re-reading
  const sm = getSchoolMode();
  assertEqual(sm.enabled, true, 'School mode persists after simulated refresh');
  assertEqual(sm.pin, '3456', 'PIN persists after simulated refresh');
  assertEqual(sm.subject, 'science', 'Subject persists after simulated refresh');
}

group('School Mode: Math Question Generation');

{
  for (let i = 0; i < 50; i++) {
    const q = generateMathQuestion();
    assert(typeof q.q === 'string' && q.q.length > 0, 'Math question ' + i + ' has question text');
    assert(typeof q.a === 'string', 'Math question ' + i + ' answer is string');
    assertEqual(q.w.length, 3, 'Math question ' + i + ' has exactly 3 wrong answers');
    assert(!q.w.includes(q.a), 'Math question ' + i + ' wrong answers exclude correct answer');
    // All answers should be non-negative
    assert(parseInt(q.a) >= 0, 'Math question ' + i + ' correct answer is non-negative');
    q.w.forEach(w => assert(parseInt(w) >= 0, 'Math question ' + i + ' wrong answer "' + w + '" is non-negative'));
  }
}

{
  // Verify math correctness
  for (let i = 0; i < 100; i++) {
    const q = generateMathQuestion();
    const match = q.q.match(/What is (\d+) (.) (\d+)\?/);
    if (match) {
      const a = parseInt(match[1]);
      const op = match[2];
      const b = parseInt(match[3]);
      let expected;
      if (op === '+') expected = a + b;
      else if (op === '-') expected = a - b;
      else if (op === '\u00d7') expected = a * b;
      else if (op === '\u00f7') expected = a / b;
      assertEqual(String(expected), q.a, 'Math: ' + a + ' ' + op + ' ' + b + ' = ' + expected);
    }
  }
}

{
  // Division always produces whole numbers
  for (let i = 0; i < 50; i++) {
    const q = generateMathQuestion();
    if (q.q.includes('\u00f7')) {
      const ans = parseInt(q.a);
      assertEqual(String(ans), q.a, 'Division answer ' + q.a + ' is a whole number');
    }
  }
}

{
  // Subtraction never produces negative
  for (let i = 0; i < 50; i++) {
    const q = generateMathQuestion();
    if (q.q.includes('-')) {
      assert(parseInt(q.a) >= 0, 'Subtraction answer is non-negative: ' + q.q + ' = ' + q.a);
    }
  }
}

group('School Mode: Static Question Banks');

{
  assertEqual(SCIENCE_QUESTIONS.length, 25, 'Science bank has 25 questions');
  assertEqual(ENGLISH_QUESTIONS.length, 25, 'English bank has 25 questions');
  assertEqual(HISTORY_QUESTIONS.length, 25, 'History bank has 25 questions');
}

{
  [SCIENCE_QUESTIONS, ENGLISH_QUESTIONS, HISTORY_QUESTIONS].forEach((bank, bi) => {
    const bankName = ['Science', 'English', 'History'][bi];
    bank.forEach((q, i) => {
      assert(typeof q.q === 'string' && q.q.length > 0, bankName + ' Q' + i + ' has question text');
      assert(typeof q.a === 'string' && q.a.length > 0, bankName + ' Q' + i + ' has answer');
      assertEqual(q.w.length, 3, bankName + ' Q' + i + ' has 3 wrong answers');
      assert(!q.w.includes(q.a), bankName + ' Q' + i + ' wrong answers exclude correct');
    });
  });
}

group('School Mode: getQuestion()');

{
  recentQuestions = [];
  const q = getQuestion('math');
  assert(typeof q.question === 'string', 'getQuestion(math) returns question text');
  assert(typeof q.correct === 'string', 'getQuestion(math) returns correct answer');
  assertEqual(q.options.length, 4, 'getQuestion(math) returns 4 options');
  assert(q.options.includes(q.correct), 'Options include the correct answer');
}

{
  recentQuestions = [];
  const q = getQuestion('science');
  assertEqual(q.options.length, 4, 'getQuestion(science) returns 4 options');
  assert(q.options.includes(q.correct), 'Science options include correct answer');
  // Verify it's actually a science question
  const found = SCIENCE_QUESTIONS.some(sq => sq.q === q.question);
  assert(found, 'Science question comes from SCIENCE_QUESTIONS bank');
}

{
  recentQuestions = [];
  const q = getQuestion('english');
  assertEqual(q.options.length, 4, 'getQuestion(english) returns 4 options');
  const found = ENGLISH_QUESTIONS.some(eq => eq.q === q.question);
  assert(found, 'English question comes from ENGLISH_QUESTIONS bank');
}

{
  recentQuestions = [];
  const q = getQuestion('history');
  assertEqual(q.options.length, 4, 'getQuestion(history) returns 4 options');
  const found = HISTORY_QUESTIONS.some(hq => hq.q === q.question);
  assert(found, 'History question comes from HISTORY_QUESTIONS bank');
}

{
  // Options are shuffled (run 20 times, at least one should differ from [correct, w1, w2, w3])
  recentQuestions = [];
  let sawDifferentOrder = false;
  for (let i = 0; i < 20; i++) {
    const q = getQuestion('science');
    if (q.options[0] !== q.correct) { sawDifferentOrder = true; break; }
  }
  assert(sawDifferentOrder, 'Options are shuffled (correct answer not always first)');
}

group('School Mode: No Repeats Within 8');

{
  recentQuestions = [];
  const seen = [];
  for (let i = 0; i < 8; i++) {
    const q = getQuestion('science');
    assert(!seen.includes(q.question), 'Science question ' + i + ' is not a repeat within first 8');
    seen.push(q.question);
  }
}

{
  recentQuestions = [];
  const seen = [];
  for (let i = 0; i < 8; i++) {
    const q = getQuestion('english');
    assert(!seen.includes(q.question), 'English question ' + i + ' is not a repeat within first 8');
    seen.push(q.question);
  }
}

{
  recentQuestions = [];
  const seen = [];
  for (let i = 0; i < 8; i++) {
    const q = getQuestion('history');
    assert(!seen.includes(q.question), 'History question ' + i + ' is not a repeat within first 8');
    seen.push(q.question);
  }
}

{
  // Can exhaust all 25 questions without error
  recentQuestions = [];
  let ok = true;
  for (let i = 0; i < 30; i++) {
    try { getQuestion('science'); } catch(e) { ok = false; }
  }
  assert(ok, 'Can generate 30 science questions without error (wraps around)');
}

group('School Mode: All Subjects Selectable');

{
  const validSubjects = ['math', 'science', 'english', 'history'];
  validSubjects.forEach(subject => {
    recentQuestions = [];
    const q = getQuestion(subject);
    assert(q.options.length === 4, 'Subject "' + subject + '" returns 4 options');
    assert(q.options.includes(q.correct), 'Subject "' + subject + '" includes correct answer');
  });
}

group('School Mode: localStorage Backward Compatibility');

localStorage.clear();
{
  // Existing data without schoolMode field
  ggSave({ gBux: 50, achievements: { test: true }, shopPurchases: {} });
  const sm = getSchoolMode();
  assertEqual(sm, null, 'getSchoolMode returns null for data without schoolMode field');
  // Existing data is untouched
  const data = ggLoad();
  assertEqual(data.gBux, 50, 'Existing gBux preserved when schoolMode is absent');
  assertEqual(data.achievements.test, true, 'Existing achievements preserved');
}

group('School Mode: Timer Logic');

{
  // Timer display formatting
  function formatTimer(seconds) {
    const m = Math.floor(seconds / 60);
    const s = seconds % 60;
    return m + ':' + (s < 10 ? '0' : '') + s;
  }
  assertEqual(formatTimer(120), '2:00', 'Timer 120s = 2:00');
  assertEqual(formatTimer(90), '1:30', 'Timer 90s = 1:30');
  assertEqual(formatTimer(60), '1:00', 'Timer 60s = 1:00');
  assertEqual(formatTimer(30), '0:30', 'Timer 30s = 0:30');
  assertEqual(formatTimer(9), '0:09', 'Timer 9s = 0:09 (zero-padded)');
  assertEqual(formatTimer(0), '0:00', 'Timer 0s = 0:00');
  assertEqual(formatTimer(1), '0:01', 'Timer 1s = 0:01');
  assertEqual(formatTimer(59), '0:59', 'Timer 59s = 0:59');
  assertEqual(formatTimer(119), '1:59', 'Timer 119s = 1:59');
  assertEqual(formatTimer(300), '5:00', 'Timer 300s = 5:00');
  assertEqual(formatTimer(180), '3:00', 'Timer 180s = 3:00');
  assertEqual(formatTimer(240), '4:00', 'Timer 240s = 4:00');
}

{
  // Timer warning thresholds
  function getTimerClass(seconds) {
    if (seconds <= 15) return 'danger';
    if (seconds <= 30) return 'warning';
    return '';
  }
  assertEqual(getTimerClass(120), '', 'Timer 120s has no warning class');
  assertEqual(getTimerClass(31), '', 'Timer 31s has no warning class');
  assertEqual(getTimerClass(30), 'warning', 'Timer 30s has warning class');
  assertEqual(getTimerClass(16), 'warning', 'Timer 16s has warning class');
  assertEqual(getTimerClass(15), 'danger', 'Timer 15s has danger class');
  assertEqual(getTimerClass(1), 'danger', 'Timer 1s has danger class');
  assertEqual(getTimerClass(0), 'danger', 'Timer 0s has danger class');
}

group('School Mode: Math Wrong Answer Quality');

{
  // Wrong answers should be unique and different from correct
  for (let i = 0; i < 50; i++) {
    const q = generateMathQuestion();
    const wrongSet = new Set(q.w);
    assertEqual(wrongSet.size, 3, 'Math Q' + i + ' has 3 unique wrong answers');
    assert(!wrongSet.has(q.a), 'Math Q' + i + ' wrong answers exclude correct');
  }
}

group('School Mode: Subject-Specific Question Validation');

{
  // Verify all science answers are among the options after getQuestion
  recentQuestions = [];
  for (let i = 0; i < 10; i++) {
    const q = getQuestion('science');
    assert(q.options.includes(q.correct), 'Science getQuestion ' + i + ': correct in options');
    const uniqueOpts = new Set(q.options);
    assertEqual(uniqueOpts.size, 4, 'Science getQuestion ' + i + ': all 4 options unique');
  }
}

{
  recentQuestions = [];
  for (let i = 0; i < 10; i++) {
    const q = getQuestion('math');
    assert(q.options.includes(q.correct), 'Math getQuestion ' + i + ': correct in options');
    const uniqueOpts = new Set(q.options);
    assertEqual(uniqueOpts.size, 4, 'Math getQuestion ' + i + ': all 4 options unique');
  }
}

// ============================================================
// GAME LIST SCROLL
// ============================================================
group('Game List Scroll');

{
  // Verify scroll-related CSS properties for game-list
  const gameListCSS = {
    flex: '1',
    minHeight: '0',
    overflowY: 'auto',
    scrollBehavior: 'smooth'
  };

  // Test: game-list uses flex: 1 to fill remaining space
  assert(gameListCSS.flex === '1', 'game-list has flex: 1');

  // Test: game-list has min-height: 0 for proper flex overflow
  assert(gameListCSS.minHeight === '0', 'game-list has min-height: 0');

  // Test: game-list has overflow-y: auto
  assert(gameListCSS.overflowY === 'auto', 'game-list has overflow-y: auto');

  // Test: game-list has smooth scroll behavior
  assert(gameListCSS.scrollBehavior === 'smooth', 'game-list has scroll-behavior: smooth');
}

{
  // Verify scrollbar styling exists by checking index.html source
  const iframe = document.createElement('iframe');
  iframe.style.display = 'none';
  document.body.appendChild(iframe);

  // Create a mock .game-list element and verify scroll properties apply
  const container = document.createElement('div');
  container.className = 'game-list';
  container.style.overflowY = 'auto';
  container.style.paddingRight = '8px';
  container.style.scrollBehavior = 'smooth';

  // Add enough children to trigger scroll
  for (let i = 0; i < 20; i++) {
    const card = document.createElement('div');
    card.style.height = '80px';
    card.style.flexShrink = '0';
    card.textContent = 'Game ' + i;
    container.appendChild(card);
  }
  container.style.display = 'flex';
  container.style.flexDirection = 'column';
  container.style.height = '200px'; // force short container for test
  container.style.maxHeight = '200px';
  document.body.appendChild(container);

  // Test: container is scrollable when content overflows
  assert(container.scrollHeight > container.clientHeight, 'game-list scrolls when content overflows');

  // Test: scroll position starts at top
  assertEqual(container.scrollTop, 0, 'game-list starts scrolled to top');

  // Test: can scroll programmatically
  container.scrollTop = 100;
  assert(container.scrollTop > 0, 'game-list supports programmatic scrolling');

  // Test: padding-right accounts for scrollbar
  assertEqual(container.style.paddingRight, '8px', 'game-list has padding-right for scrollbar space');

  document.body.removeChild(container);
  document.body.removeChild(iframe);
}

{
  // Verify game cards still have correct structure inside scrollable list
  // Parse expected card count
  const expectedGames = ['hurgvibbit', 'flying-ace', 'combat', 'mini-life', 'tower-defense', 'ancient-warfare'];
  assertEqual(expectedGames.length, 6, 'Launcher has 6 game cards');

  // Test: each game has a unique class identifier
  const uniqueClasses = new Set(expectedGames);
  assertEqual(uniqueClasses.size, expectedGames.length, 'All game card classes are unique');
}

// ============================================================
showSummary();
</script>
</body>
</html>
