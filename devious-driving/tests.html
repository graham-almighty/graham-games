<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Devious Driving - Unit Tests</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1a2e; color: #eee; font-family: 'Segoe UI', monospace; padding: 20px; }
  h1 { color: #e91e63; margin-bottom: 4px; }
  .summary { color: #aaa; margin-bottom: 20px; font-size: 0.9rem; }
  .pass { color: #4caf50; }
  .fail { color: #ff4444; }
  .group-title { color: #e91e63; font-size: 1.1rem; margin: 16px 0 6px; border-bottom: 1px solid #333; padding-bottom: 4px; }
  .test { padding: 4px 12px; font-size: 0.85rem; border-left: 3px solid transparent; margin: 2px 0; }
  .test.pass { border-left-color: #4caf50; }
  .test.fail { border-left-color: #ff4444; background: #ff444411; }
  .test .label { display: inline; }
  .test .detail { color: #888; font-size: 0.75rem; margin-left: 8px; }
  #results { max-width: 800px; }
</style>
</head>
<body>
<h1>Devious Driving - Unit Tests</h1>
<div class="summary" id="summary"></div>
<div id="results"></div>

<script>
// ============================================================
// MINI TEST FRAMEWORK
// ============================================================
let _passed = 0, _failed = 0;
const _results = document.getElementById('results');

function group(name) {
  const h = document.createElement('div');
  h.className = 'group-title';
  h.textContent = name;
  _results.appendChild(h);
}

function assert(condition, name, detail) {
  const div = document.createElement('div');
  if (condition) {
    _passed++;
    div.className = 'test pass';
    div.innerHTML = '<span class="label">PASS</span> ' + name;
  } else {
    _failed++;
    div.className = 'test fail';
    div.innerHTML = '<span class="label">FAIL</span> ' + name + (detail ? '<span class="detail">(' + detail + ')</span>' : '');
  }
  _results.appendChild(div);
}

function assertEqual(actual, expected, name) {
  const pass = actual === expected;
  assert(pass, name, pass ? '' : 'expected ' + JSON.stringify(expected) + ', got ' + JSON.stringify(actual));
}

function assertApprox(actual, expected, tolerance, name) {
  const pass = Math.abs(actual - expected) <= tolerance;
  assert(pass, name, pass ? '' : 'expected ~' + expected + ' (±' + tolerance + '), got ' + actual);
}

function showSummary() {
  const el = document.getElementById('summary');
  el.innerHTML = '<span class="pass">' + _passed + ' passed</span> · <span class="' + (_failed ? 'fail' : 'pass') + '">' + _failed + ' failed</span>';
}

// ============================================================
// MOCK LOCALSTORAGE
// ============================================================
const localStorage = {
  _data: {},
  getItem(k) { return this._data[k] || null; },
  setItem(k, v) { this._data[k] = String(v); },
  removeItem(k) { delete this._data[k]; },
  clear() { this._data = {}; },
};

// ============================================================
// EXTRACTED SOURCE — G BUX
// ============================================================
const GG_KEY = 'graham-games-data';
function ggLoad() {
  try { return JSON.parse(localStorage.getItem(GG_KEY)) || { gBux: 0, achievements: {}, shopPurchases: {} }; }
  catch(e) { return { gBux: 0, achievements: {}, shopPurchases: {} }; }
}
function ggSave(data) { localStorage.setItem(GG_KEY, JSON.stringify(data)); }
function ggUnlockAchievement(id, name, reward) {
  const data = ggLoad();
  if (data.achievements[id]) return false;
  data.achievements[id] = true;
  data.gBux += reward;
  ggSave(data);
  return true;
}

const DD_ACH = {
  dd_first_race:   { name: "Learner's Permit", reward: 5 },
  dd_first_win:    { name: 'Checkered Flag',   reward: 10 },
  dd_all_maps:     { name: 'World Tour',       reward: 25 },
  dd_no_walls:     { name: 'Clean Driver',     reward: 20 },
  dd_drift_king:   { name: 'Drift King',       reward: 15 },
  dd_oil_slick:    { name: 'Dirty Tricks',     reward: 10 },
  dd_speed_demon:  { name: 'Speed Demon',      reward: 15 },
  dd_photo_finish: { name: 'Photo Finish',     reward: 20 },
  dd_unbeatable:   { name: 'Unbeatable',       reward: 30 },
  dd_human_victor: { name: 'Rivalry',          reward: 50 },
};
function ggTry(id) { const a = DD_ACH[id]; if (a) ggUnlockAchievement(id, a.name, a.reward); }

const DD_STATS_KEY = 'dd-stats';
function ddLoadStats() {
  try { return JSON.parse(localStorage.getItem(DD_STATS_KEY)) || { wins: 0, mapWins: {} }; }
  catch(e) { return { wins: 0, mapWins: {} }; }
}
function ddSaveStats(s) { localStorage.setItem(DD_STATS_KEY, JSON.stringify(s)); }

// ============================================================
// EXTRACTED SOURCE — CONSTANTS
// ============================================================
const CANVAS_W = 832, CANVAS_H = 624;
const CAR_W = 12, CAR_H = 22;
const MAX_SPEED = 250;
const ACCEL = 180;
const BRAKE = 250;
const FRICTION = 80;
const TURN_SPEED = 3.2;
const DRIFT_THRESHOLD = 120;
const DRIFT_FACTOR = 0.92;
const TRACK_WIDTH = 120;
const TOTAL_LAPS = 3;
const POWERUP_RESPAWN = 10;
const BOOST_DURATION = 2;
const BOOST_MULTIPLIER = 1.6;
const SHIELD_DURATION = 5;
const OIL_LIFETIME = 15;
const SPINOUT_DURATION = 1.0;
const CAR_COLORS = ['#e91e63', '#2196f3', '#4caf50', '#ff9800'];
const CAR_NAMES = ['Pink', 'Blue', 'Green', 'Orange'];

// ============================================================
// EXTRACTED SOURCE — MAPS
// ============================================================
const MAPS = [
  {
    name: 'Oval Speedway',
    desc: 'Simple oval, great for beginners',
    grass: '#4a8c3f',
    road: '#555',
    waypoints: (function() {
      const pts = [];
      const cx = 416, cy = 312, rx = 300, ry = 200;
      for (let i = 0; i < 40; i++) {
        const a = (i / 40) * Math.PI * 2;
        pts.push([cx + Math.cos(a) * rx, cy + Math.sin(a) * ry]);
      }
      return pts;
    })(),
  },
  {
    name: 'Figure Eight',
    desc: 'Crossing paths, watch out!',
    grass: '#3d7a34',
    road: '#555',
    waypoints: (function() {
      const pts = [];
      for (let i = 0; i < 40; i++) {
        const t = (i / 40) * Math.PI * 2;
        const x = 416 + Math.sin(t) * 280;
        const y = 312 + Math.sin(t * 2) * 180;
        pts.push([x, y]);
      }
      return pts;
    })(),
  },
  {
    name: 'Seaside Circuit',
    desc: 'Tight hairpins along the coast',
    grass: '#c2b280',
    road: '#666',
    waypoints: [
      [150, 550], [100, 400], [80, 250], [120, 130], [250, 80],
      [400, 60], [550, 80], [650, 150], [720, 280],
      [750, 400], [700, 520], [600, 570], [450, 580],
      [300, 560], [200, 580],
    ],
  },
  {
    name: 'Mountain Pass',
    desc: 'Narrow winding switchbacks',
    grass: '#5a7a4a',
    road: '#777',
    waypoints: [
      [100, 570], [200, 520], [350, 560], [500, 500],
      [650, 540], [750, 470], [700, 350], [550, 300],
      [400, 340], [250, 280], [150, 200], [250, 120],
      [400, 80], [600, 100], [720, 160], [680, 260],
      [500, 220], [300, 180], [150, 250], [100, 400],
    ],
  },
  {
    name: 'Downtown',
    desc: 'City grid with sharp corners',
    grass: '#3a3a4a',
    road: '#555',
    waypoints: [
      [100, 100], [350, 100], [350, 250], [600, 250],
      [600, 100], [750, 100], [750, 350], [600, 350],
      [600, 500], [750, 500], [750, 570], [400, 570],
      [400, 400], [200, 400], [200, 570], [100, 570],
      [100, 350], [250, 350], [250, 250], [100, 250],
    ],
  },
  {
    name: 'Highway',
    desc: 'Long open road with gentle sweeps',
    grass: '#3a7a2a',
    road: '#666',
    waypoints: (function() {
      const pts = [];
      const segments = 80;
      for (let i = 0; i < segments; i++) {
        const t = (i / segments) * Math.PI * 2;
        const x = 800 + Math.cos(t) * 700 + Math.sin(t * 2) * 150;
        const y = 500 + Math.sin(t) * 400 + Math.cos(t * 3) * 80;
        pts.push([x, y]);
      }
      return pts;
    })(),
  },
];

// ============================================================
// EXTRACTED SOURCE — TRACK HELPERS
// ============================================================
function getTrackPoint(map, t) {
  const wp = map.waypoints;
  const len = wp.length;
  const i = Math.floor(t) % len;
  const j = (i + 1) % len;
  const f = t - Math.floor(t);
  return [
    wp[i][0] + (wp[j][0] - wp[i][0]) * f,
    wp[i][1] + (wp[j][1] - wp[i][1]) * f,
  ];
}

function getTrackAngle(map, idx) {
  const wp = map.waypoints;
  const len = wp.length;
  const i = idx % len;
  const j = (i + 1) % len;
  return Math.atan2(wp[j][1] - wp[i][1], wp[j][0] - wp[i][0]);
}

function distToTrack(map, x, y) {
  const wp = map.waypoints;
  let minD = Infinity;
  for (let i = 0; i < wp.length; i++) {
    const j = (i + 1) % wp.length;
    const d = pointToSegDist(x, y, wp[i][0], wp[i][1], wp[j][0], wp[j][1]);
    if (d < minD) minD = d;
  }
  return minD;
}

function pointToSegDist(px, py, ax, ay, bx, by) {
  const dx = bx - ax, dy = by - ay;
  const len2 = dx * dx + dy * dy;
  if (len2 === 0) return Math.hypot(px - ax, py - ay);
  let t = ((px - ax) * dx + (py - ay) * dy) / len2;
  t = Math.max(0, Math.min(1, t));
  return Math.hypot(px - (ax + t * dx), py - (ay + t * dy));
}

function nearestWaypoint(map, x, y) {
  const wp = map.waypoints;
  let best = 0, bestD = Infinity;
  for (let i = 0; i < wp.length; i++) {
    const d = Math.hypot(x - wp[i][0], y - wp[i][1]);
    if (d < bestD) { bestD = d; best = i; }
  }
  return best;
}

// ============================================================
// EXTRACTED SOURCE — CAR CREATION
// ============================================================
let currentMap = 0;
let cars = [];

function createCar(index, isPlayer, controlScheme) {
  const map = MAPS[currentMap];
  const wp = map.waypoints;
  const startAngle = getTrackAngle(map, 0);
  const perp = startAngle + Math.PI / 2;
  const offsetX = Math.cos(perp) * (index - 1.5) * 16;
  const offsetY = Math.sin(perp) * (index - 1.5) * 16;
  const backX = -Math.cos(startAngle) * index * 28;
  const backY = -Math.sin(startAngle) * index * 28;
  return {
    x: wp[0][0] + offsetX + backX,
    y: wp[0][1] + offsetY + backY,
    angle: startAngle,
    speed: 0,
    color: CAR_COLORS[index],
    name: CAR_NAMES[index],
    index,
    isPlayer,
    controlScheme,
    lap: 0,
    wayIdx: 0,
    prevWayIdx: -1,
    finishTime: 0,
    finished: false,
    powerup: null,
    boostTimer: 0,
    shieldTimer: 0,
    spinTimer: 0,
    driftTimer: 0,
    isDrifting: false,
    skidVX: 0,
    skidVY: 0,
  };
}

// ============================================================
// EXTRACTED SOURCE — INPUT & POSITION
// ============================================================
let keys = {};

function getInput(car) {
  if (car.controlScheme === 'wasd') {
    return {
      accel: keys['w'],
      brake: keys['s'],
      left: keys['a'],
      right: keys['d'],
      usePowerup: keys[' '],
    };
  } else if (car.controlScheme === 'arrows') {
    return {
      accel: keys['ArrowUp'],
      brake: keys['ArrowDown'],
      left: keys['ArrowLeft'],
      right: keys['ArrowRight'],
      usePowerup: keys['enter'],
    };
  } else if (car.controlScheme === 'ijkl') {
    return {
      accel: keys['i'],
      brake: keys['k'],
      left: keys['j'],
      right: keys['l'],
      usePowerup: keys['b'],
    };
  } else if (car.controlScheme === 'numpad') {
    return {
      accel: keys['8'],
      brake: keys['5'],
      left: keys['4'],
      right: keys['6'],
      usePowerup: keys['0'],
    };
  }
  return { accel: false, brake: false, left: false, right: false, usePowerup: false };
}

function getPosition(car) {
  let pos = 1;
  const myProgress = car.lap * 1000 + car.wayIdx;
  for (const other of cars) {
    if (other === car) continue;
    const otherProgress = other.lap * 1000 + other.wayIdx;
    if (otherProgress > myProgress) pos++;
  }
  return pos;
}

// ============================================================
// EXTRACTED SOURCE — AI
// ============================================================
let oilSlicks = [];

function getAIInput(car) {
  const map = MAPS[currentMap];
  const wp = map.waypoints;

  // Follow the track centerline
  const followDist = 60 + (car.speed / MAX_SPEED) * 120;
  let remaining = followDist;
  let segIdx = car.wayIdx;
  let tx, ty;
  while (remaining > 0) {
    const ni = (segIdx + 1) % wp.length;
    const segLen = Math.hypot(wp[ni][0] - wp[segIdx][0], wp[ni][1] - wp[segIdx][1]);
    if (remaining <= segLen && segLen > 0) {
      const t = remaining / segLen;
      tx = wp[segIdx][0] + (wp[ni][0] - wp[segIdx][0]) * t;
      ty = wp[segIdx][1] + (wp[ni][1] - wp[segIdx][1]) * t;
      break;
    }
    remaining -= segLen;
    segIdx = ni;
    if (segIdx === car.wayIdx) { tx = wp[segIdx][0]; ty = wp[segIdx][1]; break; }
  }
  if (tx === undefined) { tx = wp[(car.wayIdx + 1) % wp.length][0]; ty = wp[(car.wayIdx + 1) % wp.length][1]; }

  const nearIdx = nearestWaypoint(map, car.x, car.y);
  const nearWp = wp[nearIdx];
  const offDist = Math.hypot(car.x - nearWp[0], car.y - nearWp[1]);
  if (offDist > TRACK_WIDTH * 0.25) {
    const blend = Math.min(0.5, (offDist - TRACK_WIDTH * 0.25) / TRACK_WIDTH);
    tx = tx * (1 - blend) + nearWp[0] * blend;
    ty = ty * (1 - blend) + nearWp[1] * blend;
  }

  const dx = tx - car.x, dy = ty - car.y;
  const targetAngle = Math.atan2(dy, dx);
  let angleDiff = targetAngle - car.angle;
  while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
  while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;

  const input = { accel: true, brake: false, left: false, right: false, usePowerup: false };
  if (angleDiff > 0.05) input.right = true;
  else if (angleDiff < -0.05) input.left = true;

  const lookAhead = Math.max(2, Math.floor(3 + (car.speed / MAX_SPEED) * 5));
  const brakeCheckIdx = (car.wayIdx + lookAhead + 3) % wp.length;
  const nextIdx = (brakeCheckIdx + 1) % wp.length;
  const prevIdx = (brakeCheckIdx - 1 + wp.length) % wp.length;
  const turnAngle1 = Math.atan2(wp[nextIdx][1] - wp[brakeCheckIdx][1], wp[nextIdx][0] - wp[brakeCheckIdx][0]);
  const turnAngle0 = Math.atan2(wp[brakeCheckIdx][1] - wp[prevIdx][1], wp[brakeCheckIdx][0] - wp[prevIdx][0]);
  let upcomingTurn = turnAngle1 - turnAngle0;
  while (upcomingTurn > Math.PI) upcomingTurn -= Math.PI * 2;
  while (upcomingTurn < -Math.PI) upcomingTurn += Math.PI * 2;

  if (Math.abs(upcomingTurn) > 0.4 && car.speed > MAX_SPEED * 0.6) input.brake = true;
  if (Math.abs(angleDiff) > 0.6 && car.speed > MAX_SPEED * 0.4) input.brake = true;

  if (car.powerup) {
    if (car.powerup.type === 'boost' && Math.abs(angleDiff) < 0.2 && car.speed > MAX_SPEED * 0.5) {
      input.usePowerup = true;
    } else if (car.powerup.type === 'oil') {
      for (const other of cars) {
        if (other === car || other.finished) continue;
        const behindDist = Math.hypot(car.x - other.x, car.y - other.y);
        if (behindDist < 60 && other.wayIdx <= car.wayIdx + 2) {
          input.usePowerup = true;
          break;
        }
      }
    } else if (car.powerup.type === 'shield') {
      for (const other of cars) {
        if (other === car || other.finished) continue;
        if (Math.hypot(car.x - other.x, car.y - other.y) < 40) {
          input.usePowerup = true;
          break;
        }
      }
    }
  }

  for (const oil of oilSlicks) {
    if (oil.owner === car.index) continue;
    const oilDist = Math.hypot(car.x - oil.x, car.y - oil.y);
    if (oilDist < 50) {
      const oilAngle = Math.atan2(oil.y - car.y, oil.x - car.x);
      let oilDiff = oilAngle - car.angle;
      while (oilDiff > Math.PI) oilDiff -= Math.PI * 2;
      while (oilDiff < -Math.PI) oilDiff += Math.PI * 2;
      if (Math.abs(oilDiff) < 0.8) {
        if (oilDiff > 0) input.left = true;
        else input.right = true;
      }
    }
  }

  return input;
}

// ============================================================
// TESTS
// ============================================================

// --- MAP DEFINITIONS ---
group('Map Definitions');
assertEqual(MAPS.length, 6, 'There are 6 maps');
MAPS.forEach((m, i) => {
  assert(m.name && m.name.length > 0, 'Map ' + i + ' has a name: ' + m.name);
  assert(m.desc && m.desc.length > 0, 'Map ' + i + ' has a description');
  assert(m.grass && m.grass.startsWith('#'), 'Map ' + i + ' has grass color');
  assert(m.road && m.road.startsWith('#'), 'Map ' + i + ' has road color');
  assert(Array.isArray(m.waypoints), 'Map ' + i + ' has waypoints array');
  assert(m.waypoints.length >= 10, 'Map ' + i + ' has at least 10 waypoints (has ' + m.waypoints.length + ')');
  m.waypoints.forEach((wp, j) => {
    assert(Array.isArray(wp) && wp.length === 2 && typeof wp[0] === 'number' && typeof wp[1] === 'number',
      'Map ' + i + ' waypoint ' + j + ' is [x, y] pair');
  });
});
assertEqual(MAPS[0].name, 'Oval Speedway', 'Map 0 is Oval Speedway');
assertEqual(MAPS[1].name, 'Figure Eight', 'Map 1 is Figure Eight');
assertEqual(MAPS[2].name, 'Seaside Circuit', 'Map 2 is Seaside Circuit');
assertEqual(MAPS[3].name, 'Mountain Pass', 'Map 3 is Mountain Pass');
assertEqual(MAPS[4].name, 'Downtown', 'Map 4 is Downtown');
assertEqual(MAPS[5].name, 'Highway', 'Map 5 is Highway');

// --- CONSTANTS ---
group('Game Constants');
assertEqual(MAX_SPEED, 250, 'MAX_SPEED is 250');
assertEqual(ACCEL, 180, 'ACCEL is 180');
assertEqual(BRAKE, 250, 'BRAKE is 250');
assertEqual(FRICTION, 80, 'FRICTION is 80');
assertEqual(TURN_SPEED, 3.2, 'TURN_SPEED is 3.2');
assertEqual(DRIFT_THRESHOLD, 120, 'DRIFT_THRESHOLD is 120');
assertEqual(TRACK_WIDTH, 120, 'TRACK_WIDTH is 120');
assertEqual(TOTAL_LAPS, 3, 'TOTAL_LAPS is 3');
assertEqual(BOOST_DURATION, 2, 'BOOST_DURATION is 2');
assertEqual(BOOST_MULTIPLIER, 1.6, 'BOOST_MULTIPLIER is 1.6');
assertEqual(SHIELD_DURATION, 5, 'SHIELD_DURATION is 5');
assertEqual(OIL_LIFETIME, 15, 'OIL_LIFETIME is 15');
assertEqual(SPINOUT_DURATION, 1.0, 'SPINOUT_DURATION is 1.0');
assertEqual(POWERUP_RESPAWN, 10, 'POWERUP_RESPAWN is 10');
assertEqual(CAR_COLORS.length, 4, '4 car colors');
assertEqual(CAR_NAMES.length, 4, '4 car names');
assertEqual(CANVAS_W, 832, 'Canvas width is 832');
assertEqual(CANVAS_H, 624, 'Canvas height is 624');

// --- TRACK HELPERS ---
group('Track Helpers');

// getTrackPoint — interpolation between waypoints
const testMap = MAPS[0];
const pt0 = getTrackPoint(testMap, 0);
assertApprox(pt0[0], testMap.waypoints[0][0], 0.01, 'getTrackPoint(0) returns first waypoint X');
assertApprox(pt0[1], testMap.waypoints[0][1], 0.01, 'getTrackPoint(0) returns first waypoint Y');

const pt05 = getTrackPoint(testMap, 0.5);
const midX = (testMap.waypoints[0][0] + testMap.waypoints[1][0]) / 2;
const midY = (testMap.waypoints[0][1] + testMap.waypoints[1][1]) / 2;
assertApprox(pt05[0], midX, 0.01, 'getTrackPoint(0.5) interpolates X midpoint');
assertApprox(pt05[1], midY, 0.01, 'getTrackPoint(0.5) interpolates Y midpoint');

// getTrackAngle
const angle0 = getTrackAngle(testMap, 0);
assert(typeof angle0 === 'number' && !isNaN(angle0), 'getTrackAngle returns a number');
const angleManual = Math.atan2(
  testMap.waypoints[1][1] - testMap.waypoints[0][1],
  testMap.waypoints[1][0] - testMap.waypoints[0][0]
);
assertApprox(angle0, angleManual, 0.001, 'getTrackAngle matches manual calculation');

// pointToSegDist
assertApprox(pointToSegDist(5, 0, 0, 0, 10, 0), 0, 0.01, 'Point on segment has distance 0');
assertApprox(pointToSegDist(5, 3, 0, 0, 10, 0), 3, 0.01, 'Point 3 above segment has distance 3');
assertApprox(pointToSegDist(0, 0, 0, 0, 0, 0), 0, 0.01, 'Zero-length segment returns distance to point');
assertApprox(pointToSegDist(-5, 0, 0, 0, 10, 0), 5, 0.01, 'Point before segment start clamps to start');
assertApprox(pointToSegDist(15, 0, 0, 0, 10, 0), 5, 0.01, 'Point after segment end clamps to end');

// distToTrack
const onTrackDist = distToTrack(testMap, testMap.waypoints[0][0], testMap.waypoints[0][1]);
assertApprox(onTrackDist, 0, 1, 'Point on waypoint has ~0 distance to track');

const farDist = distToTrack(testMap, 0, 0);
assert(farDist > TRACK_WIDTH, 'Point far from track has large distance');

// nearestWaypoint
const nw0 = nearestWaypoint(testMap, testMap.waypoints[0][0], testMap.waypoints[0][1]);
assertEqual(nw0, 0, 'nearestWaypoint returns 0 for point at waypoint 0');
const nw5 = nearestWaypoint(testMap, testMap.waypoints[5][0], testMap.waypoints[5][1]);
assertEqual(nw5, 5, 'nearestWaypoint returns 5 for point at waypoint 5');

// --- CAR CREATION ---
group('Car Creation');
currentMap = 0;
const car0 = createCar(0, true, 'wasd');
assert(car0.isPlayer === true, 'Car 0 is player');
assertEqual(car0.controlScheme, 'wasd', 'Car 0 uses WASD');
assertEqual(car0.color, '#e91e63', 'Car 0 is pink');
assertEqual(car0.name, 'Pink', 'Car 0 name is Pink');
assertEqual(car0.lap, 0, 'Car starts on lap 0');
assertEqual(car0.speed, 0, 'Car starts at speed 0');
assertEqual(car0.wayIdx, 0, 'Car starts at waypoint 0');
assert(car0.powerup === null, 'Car starts with no powerup');
assertEqual(car0.boostTimer, 0, 'Car starts with no boost');
assertEqual(car0.shieldTimer, 0, 'Car starts with no shield');
assertEqual(car0.spinTimer, 0, 'Car starts with no spin');
assertEqual(car0.finished, false, 'Car starts unfinished');

const car1 = createCar(1, false, 'cpu');
assert(car1.isPlayer === false, 'Car 1 is not player');
assertEqual(car1.controlScheme, 'cpu', 'Car 1 is CPU');
assertEqual(car1.color, '#2196f3', 'Car 1 is blue');
assertEqual(car1.name, 'Blue', 'Car 1 name is Blue');

const car2 = createCar(2, false, 'cpu');
assertEqual(car2.color, '#4caf50', 'Car 2 is green');
const car3 = createCar(3, false, 'cpu');
assertEqual(car3.color, '#ff9800', 'Car 3 is orange');

// Cars start near waypoint 0
const wp0 = MAPS[0].waypoints[0];
assert(Math.hypot(car0.x - wp0[0], car0.y - wp0[1]) < 100, 'Car 0 starts near first waypoint');

// Cars at different positions (staggered)
assert(car0.x !== car1.x || car0.y !== car1.y, 'Car 0 and Car 1 start at different positions');

// Arrows control scheme
const carArrows = createCar(1, true, 'arrows');
assertEqual(carArrows.controlScheme, 'arrows', 'Can create car with arrows control');

// --- CAR CREATION ON DIFFERENT MAPS ---
group('Car Creation on All Maps');
for (let m = 0; m < MAPS.length; m++) {
  currentMap = m;
  const c = createCar(0, true, 'wasd');
  const wp = MAPS[m].waypoints[0];
  assert(Math.hypot(c.x - wp[0], c.y - wp[1]) < 100,
    'Car on map ' + m + ' (' + MAPS[m].name + ') starts near first waypoint');
  assert(typeof c.angle === 'number' && !isNaN(c.angle),
    'Car on map ' + m + ' has valid starting angle');
}
currentMap = 0;

// --- INPUT SYSTEM ---
group('Input System');
keys = {};
const wasdCar = createCar(0, true, 'wasd');
const input0 = getInput(wasdCar);
assertEqual(input0.accel, undefined, 'No keys pressed: accel is falsy');
assertEqual(input0.brake, undefined, 'No keys pressed: brake is falsy');
assertEqual(input0.left, undefined, 'No keys pressed: left is falsy');
assertEqual(input0.right, undefined, 'No keys pressed: right is falsy');

keys = { w: true };
const inputW = getInput(wasdCar);
assertEqual(inputW.accel, true, 'W key: accel is true');
assert(!inputW.brake, 'W key: brake is false');

keys = { s: true };
const inputS = getInput(wasdCar);
assertEqual(inputS.brake, true, 'S key: brake is true');

keys = { a: true };
const inputA = getInput(wasdCar);
assertEqual(inputA.left, true, 'A key: left is true');

keys = { d: true };
const inputD = getInput(wasdCar);
assertEqual(inputD.right, true, 'D key: right is true');

keys = { ' ': true };
const inputSpace = getInput(wasdCar);
assertEqual(inputSpace.usePowerup, true, 'Space: usePowerup is true');

// Arrow keys
const arrowCar = createCar(1, true, 'arrows');
keys = { ArrowUp: true };
assertEqual(getInput(arrowCar).accel, true, 'ArrowUp: accel is true');
keys = { ArrowDown: true };
assertEqual(getInput(arrowCar).brake, true, 'ArrowDown: brake is true');
keys = { ArrowLeft: true };
assertEqual(getInput(arrowCar).left, true, 'ArrowLeft: left is true');
keys = { ArrowRight: true };
assertEqual(getInput(arrowCar).right, true, 'ArrowRight: right is true');
keys = { enter: true };
assertEqual(getInput(arrowCar).usePowerup, true, 'Enter: usePowerup is true');

// IJKL keys
const ijklCar = createCar(2, true, 'ijkl');
keys = { i: true };
assertEqual(getInput(ijklCar).accel, true, 'I key: accel is true');
keys = { k: true };
assertEqual(getInput(ijklCar).brake, true, 'K key: brake is true');
keys = { j: true };
assertEqual(getInput(ijklCar).left, true, 'J key: left is true');
keys = { l: true };
assertEqual(getInput(ijklCar).right, true, 'L key: right is true');
keys = { b: true };
assertEqual(getInput(ijklCar).usePowerup, true, 'B key: usePowerup is true');

// Numpad keys
const numCar = createCar(3, true, 'numpad');
keys = { '8': true };
assertEqual(getInput(numCar).accel, true, 'Numpad 8: accel is true');
keys = { '5': true };
assertEqual(getInput(numCar).brake, true, 'Numpad 5: brake is true');
keys = { '4': true };
assertEqual(getInput(numCar).left, true, 'Numpad 4: left is true');
keys = { '6': true };
assertEqual(getInput(numCar).right, true, 'Numpad 6: right is true');
keys = { '0': true };
assertEqual(getInput(numCar).usePowerup, true, 'Numpad 0: usePowerup is true');

// CPU car returns no input from getInput
keys = {};
const cpuCar = createCar(2, false, 'cpu');
const cpuInput = getInput(cpuCar);
assert(!cpuInput.accel && !cpuInput.brake && !cpuInput.left && !cpuInput.right, 'CPU car getInput returns all false');

// --- POSITION TRACKING ---
group('Position Tracking');
cars = [];
const pCar = createCar(0, true, 'wasd');
const oCar1 = createCar(1, false, 'cpu');
const oCar2 = createCar(2, false, 'cpu');
const oCar3 = createCar(3, false, 'cpu');
cars = [pCar, oCar1, oCar2, oCar3];

// All at same position = 1st
pCar.lap = 0; pCar.wayIdx = 0;
oCar1.lap = 0; oCar1.wayIdx = 0;
oCar2.lap = 0; oCar2.wayIdx = 0;
oCar3.lap = 0; oCar3.wayIdx = 0;
assertEqual(getPosition(pCar), 1, 'All same progress = 1st place');

// Player ahead
pCar.wayIdx = 10;
assertEqual(getPosition(pCar), 1, 'Player at waypoint 10, others at 0 = 1st');

// Player behind
pCar.wayIdx = 0;
oCar1.wayIdx = 5;
oCar2.wayIdx = 10;
oCar3.wayIdx = 15;
assertEqual(getPosition(pCar), 4, 'Player behind all = 4th');

// Lap matters more
pCar.lap = 1; pCar.wayIdx = 0;
oCar1.lap = 0; oCar1.wayIdx = 39;
oCar2.lap = 0; oCar2.wayIdx = 39;
oCar3.lap = 0; oCar3.wayIdx = 39;
assertEqual(getPosition(pCar), 1, 'Lap 1 > Lap 0 even with low wayIdx = 1st');

// Mixed positions
pCar.lap = 0; pCar.wayIdx = 20;
oCar1.lap = 0; oCar1.wayIdx = 25;
oCar2.lap = 0; oCar2.wayIdx = 15;
oCar3.lap = 0; oCar3.wayIdx = 10;
assertEqual(getPosition(pCar), 2, 'Player at waypoint 20, one ahead = 2nd');

// --- AI SYSTEM ---
group('AI System');
currentMap = 0;
const aiCar = createCar(1, false, 'cpu');
aiCar.x = MAPS[0].waypoints[0][0];
aiCar.y = MAPS[0].waypoints[0][1];
aiCar.angle = getTrackAngle(MAPS[0], 0);
aiCar.speed = 0;

const aiInput = getAIInput(aiCar);
assert(typeof aiInput.accel === 'boolean', 'AI returns accel boolean');
assert(typeof aiInput.brake === 'boolean', 'AI returns brake boolean');
assert(typeof aiInput.left === 'boolean', 'AI returns left boolean');
assert(typeof aiInput.right === 'boolean', 'AI returns right boolean');
assertEqual(aiInput.accel, true, 'AI accelerates by default');

// AI brakes when facing wrong way at high speed
const aiBrakeCar = createCar(1, false, 'cpu');
aiBrakeCar.x = MAPS[0].waypoints[0][0];
aiBrakeCar.y = MAPS[0].waypoints[0][1];
aiBrakeCar.angle = getTrackAngle(MAPS[0], 0) + Math.PI; // facing wrong way
aiBrakeCar.speed = MAX_SPEED * 0.8;
const aiBrakeInput = getAIInput(aiBrakeCar);
assertEqual(aiBrakeInput.brake, true, 'AI brakes when angle diff > 0.6 and speed > 40% max');

// AI steers toward track centerline ahead
const aiSteerCar = createCar(1, false, 'cpu');
aiSteerCar.x = MAPS[0].waypoints[0][0];
aiSteerCar.y = MAPS[0].waypoints[0][1];
// Get the AI's target point by calling getAIInput with correct angle, then offset
const steerTarget = getAIInput(aiSteerCar); // just to confirm it works
aiSteerCar.angle = getTrackAngle(MAPS[0], 0) - 0.5; // off to the left
const aiSteerInput = getAIInput(aiSteerCar);
assertEqual(aiSteerInput.right, true, 'AI steers right when pointing left of track');

// AI uses boost when aligned with its own target (angleDiff < 0.2)
// First call AI without boost to find its target angle, then align and give boost
currentMap = 0;
const aiBoostCar = createCar(1, false, 'cpu');
aiBoostCar.x = MAPS[0].waypoints[10][0];
aiBoostCar.y = MAPS[0].waypoints[10][1];
aiBoostCar.wayIdx = 10;
aiBoostCar.speed = MAX_SPEED * 0.7;
// Get AI's target by running it once to see where it steers
const probeInput = getAIInput(aiBoostCar);
// Now align car perfectly: if neither left nor right, car is aligned
// Instead, compute the target point directly and aim at it
const bFollowDist = 60 + (aiBoostCar.speed / MAX_SPEED) * 120;
let bRemaining = bFollowDist, bSegIdx = aiBoostCar.wayIdx, btx, bty;
const bwp = MAPS[0].waypoints;
while (bRemaining > 0) {
  const ni = (bSegIdx + 1) % bwp.length;
  const segLen = Math.hypot(bwp[ni][0] - bwp[bSegIdx][0], bwp[ni][1] - bwp[bSegIdx][1]);
  if (bRemaining <= segLen && segLen > 0) { const t = bRemaining / segLen; btx = bwp[bSegIdx][0] + (bwp[ni][0] - bwp[bSegIdx][0]) * t; bty = bwp[bSegIdx][1] + (bwp[ni][1] - bwp[bSegIdx][1]) * t; break; }
  bRemaining -= segLen; bSegIdx = ni;
}
aiBoostCar.angle = Math.atan2(bty - aiBoostCar.y, btx - aiBoostCar.x);
aiBoostCar.powerup = { type: 'boost' };
const aiBoostInput = getAIInput(aiBoostCar);
assertEqual(aiBoostInput.usePowerup, true, 'AI uses boost when aligned with its target at speed');

// AI avoids oil slicks
const aiAvoidCar = createCar(1, false, 'cpu');
aiAvoidCar.x = MAPS[0].waypoints[5][0];
aiAvoidCar.y = MAPS[0].waypoints[5][1];
aiAvoidCar.angle = getTrackAngle(MAPS[0], 5);
oilSlicks = [{ x: aiAvoidCar.x + Math.cos(aiAvoidCar.angle + 0.3) * 30, y: aiAvoidCar.y + Math.sin(aiAvoidCar.angle + 0.3) * 30, owner: 0 }];
const aiAvoidInput = getAIInput(aiAvoidCar);
assertEqual(aiAvoidInput.left, true, 'AI steers away from oil slick ahead-right');
oilSlicks = [];

// AI look-ahead increases with speed
// AI follow distance increases with speed
const followSlow = 60 + (0 / MAX_SPEED) * 120;
const followFast = 60 + (MAX_SPEED / MAX_SPEED) * 120;
assertEqual(followSlow, 60, 'AI follow distance at 0 speed is 60px');
assertEqual(followFast, 180, 'AI follow distance at max speed is 180px');
assert(followFast > followSlow, 'AI looks further ahead at higher speed');

// --- G BUX INTEGRATION ---
group('G Bux Integration');
localStorage.clear();

assertEqual(Object.keys(DD_ACH).length, 10, '10 achievements defined');

// Total reward check
let totalReward = 0;
for (const id in DD_ACH) totalReward += DD_ACH[id].reward;
assertEqual(totalReward, 200, 'Total achievement reward is 200 G Bux');

// Individual achievement rewards
assertEqual(DD_ACH.dd_first_race.reward, 5, 'dd_first_race reward is 5');
assertEqual(DD_ACH.dd_first_win.reward, 10, 'dd_first_win reward is 10');
assertEqual(DD_ACH.dd_all_maps.reward, 25, 'dd_all_maps reward is 25');
assertEqual(DD_ACH.dd_no_walls.reward, 20, 'dd_no_walls reward is 20');
assertEqual(DD_ACH.dd_drift_king.reward, 15, 'dd_drift_king reward is 15');
assertEqual(DD_ACH.dd_oil_slick.reward, 10, 'dd_oil_slick reward is 10');
assertEqual(DD_ACH.dd_speed_demon.reward, 15, 'dd_speed_demon reward is 15');
assertEqual(DD_ACH.dd_photo_finish.reward, 20, 'dd_photo_finish reward is 20');
assertEqual(DD_ACH.dd_unbeatable.reward, 30, 'dd_unbeatable reward is 30');
assertEqual(DD_ACH.dd_human_victor.reward, 50, 'dd_human_victor reward is 50');

// Achievement names
assertEqual(DD_ACH.dd_first_race.name, "Learner's Permit", "dd_first_race name correct");
assertEqual(DD_ACH.dd_first_win.name, 'Checkered Flag', 'dd_first_win name correct');
assertEqual(DD_ACH.dd_all_maps.name, 'World Tour', 'dd_all_maps name correct');
assertEqual(DD_ACH.dd_human_victor.name, 'Rivalry', 'dd_human_victor name correct');

// ggTry unlocks achievement
localStorage.clear();
ggTry('dd_first_race');
const data1 = ggLoad();
assertEqual(data1.achievements.dd_first_race, true, 'ggTry unlocks achievement');
assertEqual(data1.gBux, 5, 'ggTry awards correct G Bux');

// ggTry does not double-award
ggTry('dd_first_race');
const data2 = ggLoad();
assertEqual(data2.gBux, 5, 'ggTry does not double-award');

// Multiple achievements
ggTry('dd_first_win');
const data3 = ggLoad();
assertEqual(data3.gBux, 15, 'Multiple achievements stack G Bux (5 + 10)');
assertEqual(data3.achievements.dd_first_win, true, 'Second achievement saved');

// Invalid achievement ID does nothing
ggTry('dd_nonexistent');
const data4 = ggLoad();
assertEqual(data4.gBux, 15, 'Invalid achievement ID does not change G Bux');

// --- STATS PERSISTENCE ---
group('Stats Persistence');
localStorage.clear();

const stats0 = ddLoadStats();
assertEqual(stats0.wins, 0, 'Initial stats: 0 wins');
assert(typeof stats0.mapWins === 'object', 'Initial stats: mapWins is object');
assertEqual(Object.keys(stats0.mapWins).length, 0, 'Initial stats: no map wins');

// Save and reload
const stats1 = { wins: 3, mapWins: { 0: true, 2: true } };
ddSaveStats(stats1);
const stats2 = ddLoadStats();
assertEqual(stats2.wins, 3, 'Stats round-trip: wins = 3');
assertEqual(stats2.mapWins[0], true, 'Stats round-trip: map 0 won');
assertEqual(stats2.mapWins[2], true, 'Stats round-trip: map 2 won');
assertEqual(stats2.mapWins[1], undefined, 'Stats round-trip: map 1 not won');

// Increment wins
stats2.wins++;
stats2.mapWins[4] = true;
ddSaveStats(stats2);
const stats3 = ddLoadStats();
assertEqual(stats3.wins, 4, 'Stats increment: wins = 4');
assertEqual(Object.keys(stats3.mapWins).length, 3, 'Stats increment: 3 maps won');

// --- G BUX LOAD/SAVE ROUND-TRIP ---
group('G Bux Load/Save Round-Trip');
localStorage.clear();

const freshData = ggLoad();
assertEqual(freshData.gBux, 0, 'Fresh load: 0 G Bux');
assertEqual(Object.keys(freshData.achievements).length, 0, 'Fresh load: no achievements');
assertEqual(Object.keys(freshData.shopPurchases).length, 0, 'Fresh load: no purchases');

freshData.gBux = 100;
freshData.achievements.dd_first_race = true;
freshData.shopPurchases.dd_turbo_start = true;
ggSave(freshData);

const reloaded = ggLoad();
assertEqual(reloaded.gBux, 100, 'Round-trip: gBux preserved');
assertEqual(reloaded.achievements.dd_first_race, true, 'Round-trip: achievement preserved');
assertEqual(reloaded.shopPurchases.dd_turbo_start, true, 'Round-trip: shop purchase preserved');

// Corrupt data fallback
localStorage.setItem(GG_KEY, '{invalid json');
const fallback = ggLoad();
assertEqual(fallback.gBux, 0, 'Corrupt localStorage: returns default gBux');
assertEqual(Object.keys(fallback.achievements).length, 0, 'Corrupt localStorage: returns empty achievements');

// --- POWERUP TYPES ---
group('Powerup Types');
assert(['boost', 'oil', 'shield'].length === 3, '3 powerup types exist');

// Boost timer
const boostCar = createCar(0, true, 'wasd');
boostCar.boostTimer = BOOST_DURATION;
assert(boostCar.boostTimer === 2, 'Boost timer starts at BOOST_DURATION (2s)');

// Shield timer
const shieldCar = createCar(0, true, 'wasd');
shieldCar.shieldTimer = SHIELD_DURATION;
assert(shieldCar.shieldTimer === 5, 'Shield timer starts at SHIELD_DURATION (5s)');

// Spinout timer
const spinCar = createCar(0, true, 'wasd');
spinCar.spinTimer = SPINOUT_DURATION;
assert(spinCar.spinTimer === 1.0, 'Spinout timer starts at SPINOUT_DURATION (1.0s)');

// --- DRIFT DETECTION ---
group('Drift Detection');
const driftCar = createCar(0, true, 'wasd');

// Not drifting at low speed
driftCar.speed = DRIFT_THRESHOLD - 1;
const shouldNotDrift = driftCar.speed > DRIFT_THRESHOLD;
assertEqual(shouldNotDrift, false, 'Below drift threshold: not drifting');

// Drifting at high speed while turning
driftCar.speed = DRIFT_THRESHOLD + 1;
const shouldDrift = driftCar.speed > DRIFT_THRESHOLD;
assertEqual(shouldDrift, true, 'Above drift threshold with turning: drifting possible');

assertEqual(DRIFT_FACTOR, 0.92, 'Drift factor is 0.92');

// --- TRACK COVERAGE ---
group('Track Coverage');

// All maps have valid closed tracks
MAPS.forEach((m, i) => {
  const wp = m.waypoints;
  // First and last waypoints should be different (track loops via closePath)
  assert(wp.length >= 10, 'Map ' + i + ' has >= 10 waypoints');

  // All waypoints on the canvas area (roughly)
  const allInBounds = wp.every(p => p[0] >= -100 && p[0] <= 1700 && p[1] >= -100 && p[1] <= 1100);
  assert(allInBounds, 'Map ' + i + ' waypoints are within reasonable bounds');

  // Track should be navigable (consecutive waypoints not too far apart)
  for (let j = 0; j < wp.length; j++) {
    const k = (j + 1) % wp.length;
    const d = Math.hypot(wp[k][0] - wp[j][0], wp[k][1] - wp[j][1]);
    assert(d < 400, 'Map ' + i + ' waypoints ' + j + '->' + k + ' distance=' + Math.round(d) + ' < 400');
  }
});

// --- CAR PHYSICS FORMULAS ---
group('Car Physics Formulas');

// Speed clamping
const REVERSE_MAX = MAX_SPEED * 0.35;
let testSpeed = MAX_SPEED + 100;
testSpeed = Math.max(-REVERSE_MAX, Math.min(MAX_SPEED, testSpeed));
assertEqual(testSpeed, MAX_SPEED, 'Speed clamped to MAX_SPEED');

testSpeed = -200;
testSpeed = Math.max(-REVERSE_MAX, Math.min(MAX_SPEED, testSpeed));
assertEqual(testSpeed, -REVERSE_MAX, 'Speed clamped to -REVERSE_MAX');

assertApprox(REVERSE_MAX, 87.5, 0.1, 'Reverse max is 35% of MAX_SPEED');

// Boost multiplier effect
const boostedMax = MAX_SPEED * BOOST_MULTIPLIER;
assertEqual(boostedMax, 400, 'Boosted max speed is 400');

// Turn rate proportional to absolute speed
const turnAtFull = TURN_SPEED * (Math.abs(MAX_SPEED) / MAX_SPEED);
assertEqual(turnAtFull, TURN_SPEED, 'Turn rate at max speed equals TURN_SPEED');

const turnAtHalf = TURN_SPEED * (Math.abs(MAX_SPEED * 0.5) / MAX_SPEED);
assertApprox(turnAtHalf, TURN_SPEED * 0.5, 0.001, 'Turn rate at half speed is half TURN_SPEED');

const turnAtZero = TURN_SPEED * (Math.abs(0) / MAX_SPEED);
assertEqual(turnAtZero, 0, 'Turn rate at zero speed is 0');

// Turn rate works in reverse too
const turnAtReverse = TURN_SPEED * (Math.abs(-REVERSE_MAX) / MAX_SPEED);
assert(turnAtReverse > 0, 'Turn rate is positive when reversing');

// --- ACCELERATION & DECELERATION ---
group('Acceleration & Deceleration');
const dt = 1/60; // typical frame dt

// Accelerating
let speed = 0;
speed += ACCEL * dt;
assertApprox(speed, 3, 0.1, 'One frame of acceleration adds ~3 speed');

// Braking
speed = 100;
speed -= BRAKE * dt;
assertApprox(speed, 100 - BRAKE * dt, 0.01, 'Braking subtracts BRAKE * dt');

// Friction
speed = 100;
speed -= FRICTION * dt;
assertApprox(speed, 100 - FRICTION * dt, 0.01, 'Friction subtracts FRICTION * dt');

// Braking stronger than friction
assert(BRAKE > FRICTION, 'Braking is stronger than friction');

// Reverse: braking at 0 speed goes negative
speed = 0;
speed -= ACCEL * 0.4 * dt;
assert(speed < 0, 'Braking from standstill goes into reverse');
assertApprox(speed, -ACCEL * 0.4 * dt, 0.01, 'Reverse acceleration is 40% of forward');

// Reverse speed is capped
speed = -REVERSE_MAX - 50;
speed = Math.max(-REVERSE_MAX, speed);
assertEqual(speed, -REVERSE_MAX, 'Reverse speed capped at REVERSE_MAX');

// --- LAP DETECTION LOGIC ---
group('Lap Detection Logic');

// Simulate crossing start line
const lapCar = createCar(0, true, 'wasd');
assertEqual(lapCar.lap, 0, 'Starts on lap 0');
assertEqual(lapCar.wayIdx, 0, 'Starts at waypoint 0');

// Simulate advancing through waypoints
const mapWpCount = MAPS[0].waypoints.length;
lapCar.prevWayIdx = mapWpCount - 2;
lapCar.wayIdx = mapWpCount - 1;
// Simulate crossing start (wayIdx goes to 0 from near end)
lapCar.prevWayIdx = mapWpCount - 1;
lapCar.wayIdx = 0;
if (lapCar.wayIdx === 0 && lapCar.prevWayIdx >= mapWpCount - 3) {
  lapCar.lap++;
}
assertEqual(lapCar.lap, 1, 'Lap increments when crossing start line');

// Finish condition
lapCar.lap = TOTAL_LAPS;
const isFinished = lapCar.lap >= TOTAL_LAPS;
assertEqual(isFinished, true, 'Car finishes when lap >= TOTAL_LAPS');

// --- CAR-CAR COLLISION ---
group('Car-Car Collision');
const collCar1 = createCar(0, true, 'wasd');
const collCar2 = createCar(1, false, 'cpu');

// Place cars overlapping
collCar1.x = 100; collCar1.y = 100;
collCar2.x = 110; collCar2.y = 100;
const collDist = Math.hypot(collCar1.x - collCar2.x, collCar1.y - collCar2.y);
assert(collDist < 18, 'Cars placed within collision distance (18 units)');

// Simulate collision push
const pushAngle = Math.atan2(collCar2.y - collCar1.y, collCar2.x - collCar1.x);
const overlap = 18 - collDist;
collCar1.x -= Math.cos(pushAngle) * overlap * 0.5;
collCar2.x += Math.cos(pushAngle) * overlap * 0.5;
const newDist = Math.hypot(collCar1.x - collCar2.x, collCar1.y - collCar2.y);
assert(newDist >= collDist, 'After collision push, cars are further apart');

// Faster car sends slower one skidding
collCar1.speed = 200; collCar2.speed = 100;
collCar1.skidVX = 0; collCar1.skidVY = 0;
collCar2.skidVX = 0; collCar2.skidVY = 0;
const skidForce = 300;
// car1 is faster, so car2 gets skidded
collCar2.skidVX = Math.cos(pushAngle) * skidForce * (collCar1.speed / MAX_SPEED + 0.3);
collCar2.skidVY = Math.sin(pushAngle) * skidForce * (collCar1.speed / MAX_SPEED + 0.3);
collCar2.speed *= 0.5;
collCar1.speed *= 0.85;
assert(Math.abs(collCar2.skidVX) > 0, 'Slower car gets skid velocity from collision');
assertApprox(collCar1.speed, 170, 0.1, 'Faster car loses 15% speed on impact');
assertApprox(collCar2.speed, 50, 0.1, 'Slower car loses 50% speed on impact');

// Skid decays
collCar2.skidVX *= 0.92;
collCar2.skidVY *= 0.92;
assert(Math.abs(collCar2.skidVX) > 0, 'Skid velocity decays but persists');

// Skid stops at low velocity
collCar2.skidVX = 0.5; collCar2.skidVY = 0.5;
if (Math.abs(collCar2.skidVX) < 1 && Math.abs(collCar2.skidVY) < 1) { collCar2.skidVX = 0; collCar2.skidVY = 0; }
assertEqual(collCar2.skidVX, 0, 'Skid stops when velocity below threshold');

// Car starts with no skid
const freshCar = createCar(0, true, 'wasd');
assertEqual(freshCar.skidVX, 0, 'New car has no skid X velocity');
assertEqual(freshCar.skidVY, 0, 'New car has no skid Y velocity');

// --- OIL SLICK MECHANICS ---
group('Oil Slick Mechanics');
const oilSlick = {
  x: 200, y: 200, owner: 0, life: OIL_LIFETIME,
};
assertEqual(oilSlick.life, 15, 'Oil slick starts with 15s lifetime');

// Simulate life decay
oilSlick.life -= 1;
assertEqual(oilSlick.life, 14, 'Oil slick life decreases');

// Oil doesn't affect owner
assert(oilSlick.owner === 0, 'Oil slick has owner index');

// Oil collision with another car
const oilTarget = createCar(1, false, 'cpu');
oilTarget.x = 201; oilTarget.y = 200;
const oilDist = Math.hypot(oilTarget.x - oilSlick.x, oilTarget.y - oilSlick.y);
assert(oilDist < 18, 'Target within oil slick radius');
assert(oilSlick.owner !== oilTarget.index, 'Oil does not belong to target');

// Shield blocks oil
const shieldedCar = createCar(2, false, 'cpu');
shieldedCar.shieldTimer = 3;
assert(shieldedCar.shieldTimer > 0, 'Shielded car has active shield');
// Shield absorbs hit: shieldTimer set to 0
shieldedCar.shieldTimer = 0;
assertEqual(shieldedCar.shieldTimer, 0, 'Shield consumed after blocking hit');

// --- OFF-ROAD DETECTION ---
group('Off-Road Detection');
currentMap = 0;
const offRoadMap = MAPS[0];

// On track = small distance
const onTrack = distToTrack(offRoadMap, offRoadMap.waypoints[5][0], offRoadMap.waypoints[5][1]);
assert(onTrack < TRACK_WIDTH / 2, 'Point on waypoint is within track width');

// Off track = large distance
const offTrack = distToTrack(offRoadMap, 0, 0);
assert(offTrack > TRACK_WIDTH / 2, 'Point at origin is off track');

// Off-road speed multiplier
const offRoadSpeed = 200 * 0.96;
assertApprox(offRoadSpeed, 192, 0.1, 'Off-road speed multiplier: 200 * 0.96 = 192');

// --- RACE MODE SETUP ---
group('Race Mode Setup');

// 1 player mode: 1 human, 3 CPU
currentMap = 0;
const schemes = ['wasd', 'arrows', 'ijkl', 'numpad'];
function buildRace(numPlayers) {
  const c = [];
  for (let i = 0; i < 4; i++) {
    if (i < numPlayers) c.push(createCar(i, true, schemes[i]));
    else c.push(createCar(i, false, 'cpu'));
  }
  return c;
}

const mode1 = buildRace(1);
assertEqual(mode1.length, 4, '1P mode: 4 cars total');
assertEqual(mode1.filter(c => c.isPlayer).length, 1, '1P mode: 1 player car');
assertEqual(mode1.filter(c => c.controlScheme === 'cpu').length, 3, '1P mode: 3 CPU cars');
assertEqual(mode1[0].controlScheme, 'wasd', '1P mode: P1 uses WASD');

// 2 player mode
const mode2 = buildRace(2);
assertEqual(mode2.filter(c => c.isPlayer).length, 2, '2P mode: 2 player cars');
assertEqual(mode2.filter(c => c.controlScheme === 'cpu').length, 2, '2P mode: 2 CPU cars');
assertEqual(mode2[0].controlScheme, 'wasd', '2P mode: P1 uses WASD');
assertEqual(mode2[1].controlScheme, 'arrows', '2P mode: P2 uses arrows');

// 3 player mode
const mode3 = buildRace(3);
assertEqual(mode3.filter(c => c.isPlayer).length, 3, '3P mode: 3 player cars');
assertEqual(mode3.filter(c => c.controlScheme === 'cpu').length, 1, '3P mode: 1 CPU car');
assertEqual(mode3[2].controlScheme, 'ijkl', '3P mode: P3 uses IJKL');

// 4 player mode
const mode4 = buildRace(4);
assertEqual(mode4.filter(c => c.isPlayer).length, 4, '4P mode: 4 player cars');
assertEqual(mode4.filter(c => c.controlScheme === 'cpu').length, 0, '4P mode: 0 CPU cars');
assertEqual(mode4[3].controlScheme, 'numpad', '4P mode: P4 uses numpad');

// --- ACHIEVEMENT TRIGGER CONDITIONS ---
group('Achievement Trigger Conditions');
localStorage.clear();

// dd_first_race: always on race completion
ggTry('dd_first_race');
assertEqual(ggLoad().achievements.dd_first_race, true, 'dd_first_race triggers on race complete');

// dd_first_win: on winning
localStorage.clear();
ggTry('dd_first_win');
assertEqual(ggLoad().achievements.dd_first_win, true, 'dd_first_win triggers on win');

// dd_no_walls: wallHits === 0 check
let testWallHits = 0;
assert(testWallHits === 0, 'dd_no_walls condition: wallHits === 0');
testWallHits = 1;
assert(testWallHits !== 0, 'dd_no_walls rejected: wallHits > 0');

// dd_drift_king: driftTime >= 5
let testDriftTime = 5.0;
assert(testDriftTime >= 5, 'dd_drift_king condition: driftTime >= 5');
testDriftTime = 4.9;
assert(testDriftTime < 5, 'dd_drift_king rejected: driftTime < 5');

// dd_speed_demon: boostsUsed >= 5
let testBoosts = 5;
assert(testBoosts >= 5, 'dd_speed_demon condition: boostsUsed >= 5');
testBoosts = 4;
assert(testBoosts < 5, 'dd_speed_demon rejected: boostsUsed < 5');

// dd_photo_finish: time diff < 1 second
const timeDiff = 0.8;
assert(timeDiff < 1, 'dd_photo_finish condition: time diff < 1s');

// dd_unbeatable: 10 wins
localStorage.clear();
const statsTest = { wins: 10, mapWins: {} };
ddSaveStats(statsTest);
const loaded = ddLoadStats();
assert(loaded.wins >= 10, 'dd_unbeatable condition: wins >= 10');

// dd_all_maps: all 6 maps won
const allMapsStats = { wins: 6, mapWins: { 0: true, 1: true, 2: true, 3: true, 4: true, 5: true } };
assert(Object.keys(allMapsStats.mapWins).length >= MAPS.length, 'dd_all_maps condition: all maps won');

// dd_oil_slick: oilHits > 0
let testOilHits = 1;
assert(testOilHits > 0, 'dd_oil_slick condition: oilHits > 0');

// dd_human_victor: numPlayers >= 2
let testNumPlayers = 2;
assert(testNumPlayers >= 2, 'dd_human_victor condition: 2+ players');
testNumPlayers = 1;
assert(testNumPlayers < 2, 'dd_human_victor rejected: solo mode');

// --- TRACK GETTRACKPOINT WRAPPING ---
group('Track Point Wrapping');
const wrapMap = MAPS[0];
const wrapLen = wrapMap.waypoints.length;

// t wraps around
const ptWrap = getTrackPoint(wrapMap, wrapLen);
assertApprox(ptWrap[0], wrapMap.waypoints[0][0], 0.01, 'getTrackPoint wraps at length');

const ptWrap2 = getTrackPoint(wrapMap, wrapLen + 5);
assertApprox(ptWrap2[0], wrapMap.waypoints[5][0], 0.01, 'getTrackPoint wraps beyond length');

// --- NEAREST WAYPOINT ACCURACY ---
group('Nearest Waypoint Accuracy');
MAPS.forEach((m, mi) => {
  m.waypoints.forEach((wp, wi) => {
    const found = nearestWaypoint(m, wp[0], wp[1]);
    assertEqual(found, wi, 'Map ' + mi + ': nearestWaypoint exact match at index ' + wi);
  });
});

// --- MULTIPLAYER CAMERA ---
group('Multiplayer Camera');

// Single player: camera centers on that player
const camCars1 = buildRace(1);
const humanCars1 = camCars1.filter(c => c.isPlayer);
let avgX1 = 0, avgY1 = 0;
for (const c of humanCars1) { avgX1 += c.x; avgY1 += c.y; }
avgX1 /= humanCars1.length;
avgY1 /= humanCars1.length;
assertApprox(avgX1, camCars1[0].x, 0.01, '1P camera centers on P1 X');
assertApprox(avgY1, camCars1[0].y, 0.01, '1P camera centers on P1 Y');

// Two players: camera centers between them
const camCars2 = buildRace(2);
camCars2[0].x = 100; camCars2[0].y = 200;
camCars2[1].x = 300; camCars2[1].y = 400;
const humanCars2 = camCars2.filter(c => c.isPlayer);
let avgX2 = 0, avgY2 = 0;
for (const c of humanCars2) { avgX2 += c.x; avgY2 += c.y; }
avgX2 /= humanCars2.length;
avgY2 /= humanCars2.length;
assertApprox(avgX2, 200, 0.01, '2P camera centers between players X');
assertApprox(avgY2, 300, 0.01, '2P camera centers between players Y');

// Zoom stays at 1 for single player
assertEqual(humanCars1.length, 1, '1P has 1 human car');
let targetZoom1 = 1;
if (humanCars1.length > 1) targetZoom1 = 0.5; // would zoom out
assertEqual(targetZoom1, 1, '1P zoom stays at 1.0');

// Zoom reduces when players spread apart
const spreadX = 800; // far apart
const spreadY = 600;
const fitZoom = Math.min(1, Math.min(CANVAS_W / (spreadX + 400), CANVAS_H / (spreadY + 300)));
assert(fitZoom < 1, 'Zoom < 1 when players spread far apart (got ' + fitZoom.toFixed(2) + ')');
assert(fitZoom >= 0.3, 'Zoom has minimum of 0.3');

// Zoom stays at 1 when players are close
const closeSpreadX = 100; const closeSpreadY = 100;
const closeZoom = Math.min(1, Math.min(CANVAS_W / (closeSpreadX + 400), CANVAS_H / (closeSpreadY + 300)));
assertEqual(closeZoom, 1, 'Zoom stays 1.0 when players are close together');

// Four players: camera includes all
const camCars4 = buildRace(4);
camCars4[0].x = 50; camCars4[0].y = 50;
camCars4[1].x = 750; camCars4[1].y = 50;
camCars4[2].x = 50; camCars4[2].y = 550;
camCars4[3].x = 750; camCars4[3].y = 550;
const humanCars4 = camCars4.filter(c => c.isPlayer);
let avgX4 = 0, avgY4 = 0;
for (const c of humanCars4) { avgX4 += c.x; avgY4 += c.y; }
avgX4 /= humanCars4.length;
avgY4 /= humanCars4.length;
assertApprox(avgX4, 400, 0.01, '4P camera centers at average X');
assertApprox(avgY4, 300, 0.01, '4P camera centers at average Y');

// CPU cars do not affect camera
const camMixed = buildRace(1);
camMixed[0].x = 100; camMixed[0].y = 100;
camMixed[1].x = 900; camMixed[1].y = 900; // CPU far away
const humanMixed = camMixed.filter(c => c.isPlayer);
let avgMX = 0, avgMY = 0;
for (const c of humanMixed) { avgMX += c.x; avgMY += c.y; }
avgMX /= humanMixed.length;
avgMY /= humanMixed.length;
assertApprox(avgMX, 100, 0.01, 'Camera ignores CPU car position X');
assertApprox(avgMY, 100, 0.01, 'Camera ignores CPU car position Y');

// --- PLAYER LABELS ---
group('Player Labels');
const labelCars = buildRace(3);
assertEqual(labelCars[0].isPlayer, true, 'P1 is human (gets label)');
assertEqual(labelCars[1].isPlayer, true, 'P2 is human (gets label)');
assertEqual(labelCars[2].isPlayer, true, 'P3 is human (gets label)');
assertEqual(labelCars[3].isPlayer, false, 'Car 4 is CPU (no label)');
assertEqual(labelCars[0].index, 0, 'P1 index is 0');
assertEqual(labelCars[1].index, 1, 'P2 index is 1');
assertEqual(labelCars[2].index, 2, 'P3 index is 2');

// ============================================================
// SUMMARY
// ============================================================
showSummary();
</script>
</body>
</html>
