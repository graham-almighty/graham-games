<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Ancient Warfare - Unit Tests</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1a2e; color: #eee; font-family: 'Segoe UI', monospace; padding: 20px; }
  h1 { color: #c9a84c; margin-bottom: 4px; }
  .summary { color: #aaa; margin-bottom: 20px; font-size: 0.9rem; }
  .pass { color: #4caf50; }
  .fail { color: #ff4444; }
  .group-title { color: #c9a84c; font-size: 1.1rem; margin: 16px 0 6px; border-bottom: 1px solid #333; padding-bottom: 4px; }
  .test { padding: 4px 12px; font-size: 0.85rem; border-left: 3px solid transparent; margin: 2px 0; }
  .test.pass { border-left-color: #4caf50; }
  .test.fail { border-left-color: #ff4444; background: #ff444411; }
  .test .label { display: inline; }
  .test .detail { color: #888; font-size: 0.75rem; margin-left: 8px; }
  #results { max-width: 800px; }
</style>
</head>
<body>
<h1>Ancient Warfare - Unit Tests</h1>
<div class="summary" id="summary"></div>
<div id="results"></div>

<script>
// ============================================================
// MINI TEST FRAMEWORK
// ============================================================
let _passed = 0, _failed = 0;
const _results = document.getElementById('results');

function group(name) {
  const h = document.createElement('div');
  h.className = 'group-title';
  h.textContent = name;
  _results.appendChild(h);
}

function assert(condition, name, detail) {
  const div = document.createElement('div');
  if (condition) {
    _passed++;
    div.className = 'test pass';
    div.innerHTML = '<span class="label">PASS</span> ' + name;
  } else {
    _failed++;
    div.className = 'test fail';
    div.innerHTML = '<span class="label">FAIL</span> ' + name + (detail ? '<span class="detail">(' + detail + ')</span>' : '');
  }
  _results.appendChild(div);
}

function assertEqual(actual, expected, name) {
  const pass = actual === expected;
  assert(pass, name, pass ? '' : 'expected ' + JSON.stringify(expected) + ', got ' + JSON.stringify(actual));
}

function assertApprox(actual, expected, tolerance, name) {
  const pass = Math.abs(actual - expected) <= tolerance;
  assert(pass, name, pass ? '' : 'expected ~' + expected + ' ±' + tolerance + ', got ' + actual);
}

function showSummary() {
  const total = _passed + _failed;
  document.getElementById('summary').innerHTML =
    '<span class="pass">' + _passed + ' passed</span> / ' +
    '<span class="fail">' + _failed + ' failed</span> / ' +
    total + ' total';
  document.title = (_failed === 0 ? 'ALL PASS' : _failed + ' FAIL') + ' - AW Tests';
}

// ============================================================
// MOCK BROWSER APIs
// ============================================================
const mockStorage = {};
const localStorage = {
  getItem(key) { return mockStorage[key] || null; },
  setItem(key, val) { mockStorage[key] = val; },
  removeItem(key) { delete mockStorage[key]; },
  clear() { for (const k in mockStorage) delete mockStorage[k]; },
};

function resetStorage() { localStorage.clear(); }

// ============================================================
// SOURCE CODE UNDER TEST (extracted from ancient-warfare/index.html)
// ============================================================
const GG_KEY = 'graham-games-data';

function ggLoad() {
  try { return JSON.parse(localStorage.getItem(GG_KEY)) || { gBux: 0, achievements: {}, shopPurchases: {} }; }
  catch(e) { return { gBux: 0, achievements: {}, shopPurchases: {} }; }
}
function ggSave(data) { localStorage.setItem(GG_KEY, JSON.stringify(data)); }

function ggUnlockAchievement(id, name, reward) {
  const data = ggLoad();
  if (data.achievements[id]) return false;
  data.achievements[id] = true;
  data.gBux += reward;
  ggSave(data);
  return true;
}

const AW_ACH = {
  aw_first_battle:    { name: 'First Blood',       reward: 5 },
  aw_victor:          { name: 'Victorious',         reward: 10 },
  aw_flawless:        { name: 'Flawless Victory',   reward: 30 },
  aw_cavalry_charge:  { name: 'Cavalry Charge',     reward: 15 },
  aw_archer_army:     { name: 'Rain of Arrows',     reward: 15 },
  aw_balanced:        { name: 'Balanced Forces',     reward: 20 },
  aw_underdog:        { name: 'Underdog',           reward: 25 },
  aw_speed_demon:     { name: 'Blitz',              reward: 20 },
  aw_commander:       { name: 'Commander',           reward: 25 },
  aw_warlord:         { name: 'Warlord',             reward: 50 },
};
function ggTry(id) { const a = AW_ACH[id]; if (a) ggUnlockAchievement(id, a.name, a.reward); }

const STATS_KEY = 'aw-stats';
function loadStats() {
  try {
    const s = JSON.parse(localStorage.getItem(STATS_KEY)) || {};
    return { wins: s.wins || 0, battles: s.battles || 0, bonusGold: s.bonusGold || 0 };
  } catch(e) { return { wins: 0, battles: 0, bonusGold: 0 }; }
}
function saveStats(s) { localStorage.setItem(STATS_KEY, JSON.stringify(s)); }

const UNIT_DEFS = {
  swordsman: { name: 'Swordsman', cost: 10, hp: 100, damage: 15, speed: 1.5, range: 1.5, special: 'Balanced melee fighter' },
  archer:    { name: 'Archer',    cost: 15, hp: 60,  damage: 12, speed: 1.2, range: 8,   special: 'Ranged, 5 dmg melee, retreats', meleeDamage: 5 },
  spearman:  { name: 'Spearman',  cost: 12, hp: 130, damage: 12, speed: 1.0, range: 1.8, special: '2x vs cavalry/elephant' },
  cavalry:   { name: 'Cavalry',   cost: 25, hp: 90,  damage: 20, speed: 3.0, range: 1.8, special: 'First hit 2x (charge)' },
  catapult:  { name: 'Catapult',  cost: 40, hp: 80,  damage: 45, speed: 0.4, range: 12,  special: 'Splash radius 3, very slow', splash: 3 },
  elephant:  { name: 'War Elephant', cost: 50, hp: 300, damage: 30, speed: 0.8, range: 2.0, special: 'Tank, trample', shopRequired: 'aw_war_elephant' },
};

const FIELD_W = 40, FIELD_D = 30;
const MAX_BUDGET = 200;

// Campaign level definitions (mirrored from index.html)
const LEVEL_DEFS = [
  { name: 'Border Skirmish', enemies: [{type:'swordsman',count:5},{type:'archer',count:2}], startGold: 100, healPct: 0.5 },
  { name: 'Forest Ambush', enemies: [{type:'swordsman',count:3},{type:'archer',count:5},{type:'spearman',count:2}], startGold: 80, healPct: 0.5 },
  { name: 'River Defense', enemies: [{type:'swordsman',count:4},{type:'spearman',count:4},{type:'cavalry',count:2}], startGold: 70, healPct: 0.5 },
  { name: 'The Open Plains', enemies: [{type:'cavalry',count:4},{type:'swordsman',count:4},{type:'archer',count:3}], startGold: 60, healPct: 0.4 },
  { name: 'The Siege Lines', enemies: [{type:'catapult',count:2},{type:'spearman',count:6},{type:'swordsman',count:5}], startGold: 60, healPct: 0.4 },
  { name: 'Mountain Pass', enemies: [{type:'swordsman',count:6},{type:'archer',count:4},{type:'spearman',count:4},{type:'cavalry',count:2}], startGold: 50, healPct: 0.4 },
  { name: 'The War Camp', enemies: [{type:'swordsman',count:6},{type:'archer',count:4},{type:'spearman',count:4},{type:'cavalry',count:3},{type:'catapult',count:2}], startGold: 50, healPct: 0.3 },
  { name: 'The Burning Fields', enemies: [{type:'cavalry',count:5},{type:'catapult',count:3},{type:'swordsman',count:6},{type:'spearman',count:4},{type:'elephant',count:1}], startGold: 40, healPct: 0.3 },
  { name: 'The Iron Fortress', enemies: [{type:'swordsman',count:8},{type:'spearman',count:6},{type:'archer',count:5},{type:'catapult',count:3},{type:'cavalry',count:3},{type:'elephant',count:2}], startGold: 40, healPct: 0.3 },
  { name: 'The Final Battle', enemies: [{type:'swordsman',count:10},{type:'archer',count:6},{type:'spearman',count:6},{type:'cavalry',count:5},{type:'catapult',count:4},{type:'elephant',count:3}], startGold: 30, healPct: 0.25 },
];

const CAMPAIGN_KEY = 'aw-campaign-progress';
function loadCampaignProgress() {
  try { return JSON.parse(localStorage.getItem(CAMPAIGN_KEY)) || { unlockedLevels: 1 }; }
  catch(e) { return { unlockedLevels: 1 }; }
}
function saveCampaignProgress(p) { localStorage.setItem(CAMPAIGN_KEY, JSON.stringify(p)); }

function getLevelEnemyBudget(index) {
  const def = LEVEL_DEFS[index];
  let total = 0;
  for (const e of def.enemies) total += UNIT_DEFS[e.type].cost * e.count;
  return total;
}

// Mock unit structure for combat tests
function mockUnit(type, team, overrides) {
  const def = UNIT_DEFS[type];
  return {
    position: { x: 0, z: 0, y: 0, clone() { return { ...this }; }, distanceTo(other) { return Math.sqrt((this.x - other.x)**2 + (this.z - other.z)**2); }, add(v) { this.x += v.x; this.z += v.z; }, sub(other) { return { x: this.x - other.x, z: this.z - other.z, normalize() { const l = Math.sqrt(this.x**2 + this.z**2) || 1; this.x /= l; this.z /= l; return this; }, multiplyScalar(s) { this.x *= s; this.z *= s; return this; } }; }, lerpVectors() { return this; } },
    userData: {
      type, team, def,
      hp: def.hp,
      maxHp: def.hp,
      damage: def.damage,
      speed: def.speed,
      range: def.range,
      alive: true,
      target: null,
      attackCooldown: 0,
      charged: type === 'cavalry',
      stationaryInBattle: false,
      ...overrides,
    },
  };
}

// Extracted combat damage calc
function getAttackDamage(attacker, defender, battleHornActive) {
  const aData = attacker.userData;
  const dData = defender.userData;
  let dmg = aData.damage;

  // Archer weak melee
  if (aData.type === 'archer' && aData.range > 2) {
    const dist = attacker.position.distanceTo(defender.position);
    if (dist <= 2) dmg = UNIT_DEFS.archer.meleeDamage;
  }

  // Spearman 2x vs cavalry/elephant
  if (aData.type === 'spearman' && (dData.type === 'cavalry' || dData.type === 'elephant')) {
    dmg *= 2;
  }

  // Cavalry charge (first hit)
  if (aData.type === 'cavalry' && aData.charged) {
    dmg *= 2;
    aData.charged = false;
  }

  // Battle Horn buff
  if (battleHornActive && attacker.userData.team === 'blue') {
    dmg *= 1.1;
  }

  return dmg;
}

// ============================================================
// TESTS
// ============================================================

// ─── UNIT DEFINITIONS ───
group('Unit Definitions');

assertEqual(UNIT_DEFS.swordsman.cost, 10, 'Swordsman cost = 10');
assertEqual(UNIT_DEFS.swordsman.hp, 100, 'Swordsman HP = 100');
assertEqual(UNIT_DEFS.swordsman.damage, 15, 'Swordsman damage = 15');
assertEqual(UNIT_DEFS.swordsman.speed, 1.5, 'Swordsman speed = 1.5');

assertEqual(UNIT_DEFS.archer.cost, 15, 'Archer cost = 15');
assertEqual(UNIT_DEFS.archer.hp, 60, 'Archer HP = 60');
assertEqual(UNIT_DEFS.archer.damage, 12, 'Archer damage = 12');
assertEqual(UNIT_DEFS.archer.range, 8, 'Archer range = 8');
assertEqual(UNIT_DEFS.archer.meleeDamage, 5, 'Archer melee damage = 5');

assertEqual(UNIT_DEFS.spearman.cost, 12, 'Spearman cost = 12');
assertEqual(UNIT_DEFS.spearman.hp, 130, 'Spearman HP = 130');
assertEqual(UNIT_DEFS.spearman.damage, 12, 'Spearman damage = 12');

assertEqual(UNIT_DEFS.cavalry.cost, 25, 'Cavalry cost = 25');
assertEqual(UNIT_DEFS.cavalry.hp, 90, 'Cavalry HP = 90');
assertEqual(UNIT_DEFS.cavalry.damage, 20, 'Cavalry damage = 20');
assertEqual(UNIT_DEFS.cavalry.speed, 3.0, 'Cavalry speed = 3.0');

assertEqual(UNIT_DEFS.catapult.cost, 40, 'Catapult cost = 40');
assertEqual(UNIT_DEFS.catapult.hp, 80, 'Catapult HP = 80');
assertEqual(UNIT_DEFS.catapult.damage, 45, 'Catapult damage = 45');
assertEqual(UNIT_DEFS.catapult.range, 12, 'Catapult range = 12');
assertEqual(UNIT_DEFS.catapult.splash, 3, 'Catapult splash = 3');

assertEqual(UNIT_DEFS.elephant.cost, 50, 'Elephant cost = 50');
assertEqual(UNIT_DEFS.elephant.hp, 300, 'Elephant HP = 300');
assertEqual(UNIT_DEFS.elephant.damage, 30, 'Elephant damage = 30');
assertEqual(UNIT_DEFS.elephant.shopRequired, 'aw_war_elephant', 'Elephant requires shop unlock');

// ─── BUDGET MATH ───
group('Budget Math');

{
  let budget = MAX_BUDGET;
  assertEqual(budget, 200, 'Starting budget = 200');

  budget -= UNIT_DEFS.swordsman.cost;
  assertEqual(budget, 190, 'After deploying swordsman: 190');

  budget -= UNIT_DEFS.cavalry.cost;
  assertEqual(budget, 165, 'After deploying cavalry: 165');

  budget -= UNIT_DEFS.catapult.cost;
  assertEqual(budget, 125, 'After deploying catapult: 125');

  assert(budget >= UNIT_DEFS.elephant.cost, 'Can afford elephant with 125 gold');
  assert(budget < UNIT_DEFS.elephant.cost * 3, 'Cannot afford 3 elephants with 125 gold');

  // Can't overspend
  let testBudget = 5;
  assert(testBudget < UNIT_DEFS.swordsman.cost, 'Cannot deploy swordsman with 5 gold (cost 10)');

  // Clear refunds
  budget = MAX_BUDGET;
  assertEqual(budget, 200, 'After clear all: budget restored to 200');
}

// All budget spent check
{
  let budget = MAX_BUDGET;
  let count = 0;
  while (budget >= UNIT_DEFS.swordsman.cost) {
    budget -= UNIT_DEFS.swordsman.cost;
    count++;
  }
  assertEqual(count, 20, 'Can deploy 20 swordsmen with 200 gold');
  assertEqual(budget, 0, 'Budget is 0 after 20 swordsmen');
}

// ─── COMBAT MATH ───
group('Combat Math');

// Basic swordsman damage
{
  const attacker = mockUnit('swordsman', 'blue');
  const defender = mockUnit('swordsman', 'red');
  const dmg = getAttackDamage(attacker, defender, false);
  assertEqual(dmg, 15, 'Swordsman deals 15 damage to swordsman');
}

// Spearman 2x vs cavalry
{
  const spear = mockUnit('spearman', 'blue');
  const cav = mockUnit('cavalry', 'red');
  const dmg = getAttackDamage(spear, cav, false);
  assertEqual(dmg, 24, 'Spearman deals 24 (12*2) damage to cavalry');
}

// Spearman 2x vs elephant
{
  const spear = mockUnit('spearman', 'blue');
  const ele = mockUnit('elephant', 'red');
  const dmg = getAttackDamage(spear, ele, false);
  assertEqual(dmg, 24, 'Spearman deals 24 (12*2) damage to elephant');
}

// Spearman normal vs swordsman
{
  const spear = mockUnit('spearman', 'blue');
  const sword = mockUnit('swordsman', 'red');
  const dmg = getAttackDamage(spear, sword, false);
  assertEqual(dmg, 12, 'Spearman deals 12 (no bonus) vs swordsman');
}

// Cavalry charge (first hit 2x)
{
  const cav = mockUnit('cavalry', 'blue');
  const sword = mockUnit('swordsman', 'red');
  assert(cav.userData.charged === true, 'Cavalry starts charged');
  const dmg1 = getAttackDamage(cav, sword, false);
  assertEqual(dmg1, 40, 'Cavalry charge deals 40 (20*2) damage');
  assert(cav.userData.charged === false, 'Cavalry loses charge after first hit');
  const dmg2 = getAttackDamage(cav, sword, false);
  assertEqual(dmg2, 20, 'Cavalry normal hit deals 20 damage');
}

// Archer weak melee (distance <= 2)
{
  const archer = mockUnit('archer', 'blue');
  const sword = mockUnit('swordsman', 'red');
  // Position them close (distance < 2)
  archer.position.x = 0;
  sword.position.x = 1;
  const dmg = getAttackDamage(archer, sword, false);
  assertEqual(dmg, 5, 'Archer melee damage is 5 when enemy within 2 units');
}

// Archer ranged (distance > 2)
{
  const archer = mockUnit('archer', 'blue');
  const sword = mockUnit('swordsman', 'red');
  archer.position.x = 0;
  sword.position.x = 5;
  const dmg = getAttackDamage(archer, sword, false);
  assertEqual(dmg, 12, 'Archer ranged damage is 12 at distance 5');
}

// Catapult splash damage
{
  const def = UNIT_DEFS.catapult;
  assertEqual(def.splash, 3, 'Catapult splash radius = 3');
  assertEqual(def.damage, 45, 'Catapult direct hit damage = 45');
  // Splash at distance 0 = full damage
  const fullDmg = def.damage * (1 - 0 / (def.splash + 1));
  assertEqual(fullDmg, 45, 'Splash at center = 45');
  // Splash at distance 2 = reduced
  const partialDmg = def.damage * (1 - 2 / (def.splash + 1));
  assertApprox(partialDmg, 22.5, 0.1, 'Splash at distance 2 ~= 22.5');
  // Splash at distance 3 = edge
  const edgeDmg = def.damage * (1 - 3 / (def.splash + 1));
  assertApprox(edgeDmg, 11.25, 0.1, 'Splash at distance 3 (edge) ~= 11.25');
}

// ─── BATTLE HORN ───
group('Battle Horn (+10% damage)');

{
  const sword = mockUnit('swordsman', 'blue');
  const enemy = mockUnit('swordsman', 'red');
  const dmg = getAttackDamage(sword, enemy, true);
  assertApprox(dmg, 16.5, 0.01, 'Swordsman with Battle Horn deals 16.5 (15*1.1)');
}

{
  const cav = mockUnit('cavalry', 'blue');
  const enemy = mockUnit('swordsman', 'red');
  const dmg = getAttackDamage(cav, enemy, true);
  assertApprox(dmg, 44, 0.01, 'Cavalry charge with Battle Horn deals 44 (20*2*1.1)');
}

// Battle Horn does NOT apply to red team
{
  const sword = mockUnit('swordsman', 'red');
  const enemy = mockUnit('swordsman', 'blue');
  const dmg = getAttackDamage(sword, enemy, true);
  assertEqual(dmg, 15, 'Battle Horn does not affect red team');
}

// Battle Horn timer: active for 10s then off
{
  let battleHornActive = true;
  let battleHornTimer = 10;
  // Simulate 5 seconds
  battleHornTimer -= 5;
  assert(battleHornTimer > 0, 'Battle Horn still active after 5s');
  assert(battleHornActive, 'Battle Horn flag still true at 5s');
  // Simulate 5 more seconds
  battleHornTimer -= 5;
  if (battleHornTimer <= 0) battleHornActive = false;
  assert(!battleHornActive, 'Battle Horn deactivates after 10s');
  assertEqual(battleHornTimer, 0, 'Battle Horn timer reaches 0');
}

// ─── WAR ELEPHANT UNLOCK ───
group('War Elephant Shop Unlock');

{
  resetStorage();
  const ggData = ggLoad();
  const available = Object.entries(UNIT_DEFS).filter(([k, d]) => !d.shopRequired || ggData.shopPurchases[d.shopRequired]);
  assert(!available.find(([k]) => k === 'elephant'), 'Elephant NOT available without shop purchase');
  assert(available.find(([k]) => k === 'swordsman'), 'Swordsman available without shop purchase');
  assert(available.find(([k]) => k === 'archer'), 'Archer available without shop purchase');
}

{
  resetStorage();
  const ggData = ggLoad();
  ggData.shopPurchases['aw_war_elephant'] = true;
  ggSave(ggData);
  const data2 = ggLoad();
  const available = Object.entries(UNIT_DEFS).filter(([k, d]) => !d.shopRequired || data2.shopPurchases[d.shopRequired]);
  assert(available.find(([k]) => k === 'elephant'), 'Elephant IS available after shop purchase');
}

// ─── AI ARMY GENERATION ───
group('AI Army Generation');

{
  resetStorage();
  // Simulate army generation logic
  const playerBudget = 100;
  let enemyBudget = playerBudget;
  const ggData = ggLoad();
  const available = Object.entries(UNIT_DEFS).filter(([k, d]) => !d.shopRequired || ggData.shopPurchases[d.shopRequired]);
  const units = [];

  while (enemyBudget > 0) {
    const affordable = available.filter(([k, d]) => d.cost <= enemyBudget);
    if (affordable.length === 0) break;
    const [key, def] = affordable[Math.floor(Math.random() * affordable.length)];
    units.push({ type: key, cost: def.cost });
    enemyBudget -= def.cost;
  }

  const totalSpent = units.reduce((s, u) => s + u.cost, 0);
  assert(totalSpent <= playerBudget, 'AI army does not exceed budget (' + totalSpent + ' <= ' + playerBudget + ')');
  assert(units.length > 0, 'AI army has at least 1 unit');
  assert(enemyBudget >= 0, 'Remaining enemy budget is non-negative');

  // No elephants without shop purchase
  assert(!units.find(u => u.type === 'elephant'), 'AI army has no elephants without shop purchase');
}

// AI places units in right half (x > 0)
{
  for (let i = 0; i < 20; i++) {
    const px = Math.random() * (FIELD_W / 2 - 2) + 1;
    const pz = (Math.random() - 0.5) * (FIELD_D - 2);
    assert(px > 0, 'Enemy unit x > 0 (right half): ' + px.toFixed(2));
    assert(px < FIELD_W / 2, 'Enemy unit x < 20 (field bound): ' + px.toFixed(2));
    assert(pz > -FIELD_D / 2 && pz < FIELD_D / 2, 'Enemy unit z within field bounds');
  }
}

// ─── WIN/LOSS DETECTION ───
group('Win/Loss Detection');

{
  // Victory: all red dead, some blue alive
  const blueAlive = 3;
  const redAlive = 0;
  const victory = redAlive === 0 && blueAlive > 0;
  assert(victory, 'Victory when red=0, blue=3');
}

{
  // Defeat: all blue dead, some red alive
  const blueAlive = 0;
  const redAlive = 5;
  const defeat = blueAlive === 0 && redAlive > 0;
  assert(defeat, 'Defeat when blue=0, red=5');
}

{
  // Draw (both dead) = defeat
  const blueAlive = 0;
  const redAlive = 0;
  const isDefeat = blueAlive === 0 && redAlive === 0;
  assert(isDefeat, 'Draw (both 0) counts as defeat');
}

{
  // Battle still ongoing
  const blueAlive = 5;
  const redAlive = 3;
  const ongoing = blueAlive > 0 && redAlive > 0;
  assert(ongoing, 'Battle continues when both sides have units');
}

// ─── ACHIEVEMENT TRIGGERS ───
group('Achievement Triggers (10 achievements)');

resetStorage();

// aw_first_battle: Complete a battle
{
  resetStorage();
  ggTry('aw_first_battle');
  const data = ggLoad();
  assert(data.achievements['aw_first_battle'], 'aw_first_battle unlocked');
  assertEqual(data.gBux, 5, 'aw_first_battle awards 5 G Bux');
}

// aw_victor: Win a battle
{
  resetStorage();
  ggTry('aw_victor');
  const data = ggLoad();
  assert(data.achievements['aw_victor'], 'aw_victor unlocked');
  assertEqual(data.gBux, 10, 'aw_victor awards 10 G Bux');
}

// aw_flawless: Win without losing a unit
{
  resetStorage();
  const initialBlueCount = 10;
  const blueAlive = 10;
  if (blueAlive === initialBlueCount) ggTry('aw_flawless');
  const data = ggLoad();
  assert(data.achievements['aw_flawless'], 'aw_flawless unlocked when no units lost');
  assertEqual(data.gBux, 30, 'aw_flawless awards 30 G Bux');
}

// aw_flawless: NOT awarded when units lost
{
  resetStorage();
  const initialBlueCount = 10;
  const blueAlive = 8;
  if (blueAlive === initialBlueCount) ggTry('aw_flawless');
  const data = ggLoad();
  assert(!data.achievements['aw_flawless'], 'aw_flawless NOT unlocked when units were lost');
}

// aw_cavalry_charge: 5+ cavalry
{
  resetStorage();
  const cavCount = 5;
  if (cavCount >= 5) ggTry('aw_cavalry_charge');
  const data = ggLoad();
  assert(data.achievements['aw_cavalry_charge'], 'aw_cavalry_charge unlocked with 5 cavalry');
  assertEqual(data.gBux, 15, 'aw_cavalry_charge awards 15 G Bux');
}

// aw_cavalry_charge: NOT with 4
{
  resetStorage();
  const cavCount = 4;
  if (cavCount >= 5) ggTry('aw_cavalry_charge');
  const data = ggLoad();
  assert(!data.achievements['aw_cavalry_charge'], 'aw_cavalry_charge NOT unlocked with 4 cavalry');
}

// aw_archer_army: 5+ archers
{
  resetStorage();
  const archerCount = 6;
  if (archerCount >= 5) ggTry('aw_archer_army');
  const data = ggLoad();
  assert(data.achievements['aw_archer_army'], 'aw_archer_army unlocked with 6 archers');
  assertEqual(data.gBux, 15, 'aw_archer_army awards 15 G Bux');
}

// aw_balanced: all 5 base types
{
  resetStorage();
  const types = new Set(['swordsman', 'archer', 'spearman', 'cavalry', 'catapult']);
  const baseTypes = ['swordsman', 'archer', 'spearman', 'cavalry', 'catapult'];
  if (baseTypes.every(t => types.has(t))) ggTry('aw_balanced');
  const data = ggLoad();
  assert(data.achievements['aw_balanced'], 'aw_balanced unlocked with all 5 base types');
  assertEqual(data.gBux, 20, 'aw_balanced awards 20 G Bux');
}

// aw_balanced: NOT without all 5
{
  resetStorage();
  const types = new Set(['swordsman', 'archer', 'spearman', 'cavalry']);
  const baseTypes = ['swordsman', 'archer', 'spearman', 'cavalry', 'catapult'];
  if (baseTypes.every(t => types.has(t))) ggTry('aw_balanced');
  const data = ggLoad();
  assert(!data.achievements['aw_balanced'], 'aw_balanced NOT unlocked with only 4 types');
}

// aw_underdog: outnumbered 2:1
{
  resetStorage();
  const deployedCount = 5;
  const enemyCount = 10;
  if (enemyCount >= deployedCount * 2) ggTry('aw_underdog');
  const data = ggLoad();
  assert(data.achievements['aw_underdog'], 'aw_underdog unlocked when outnumbered 2:1');
  assertEqual(data.gBux, 25, 'aw_underdog awards 25 G Bux');
}

// aw_underdog: NOT when ratio < 2:1
{
  resetStorage();
  const deployedCount = 5;
  const enemyCount = 9;
  if (enemyCount >= deployedCount * 2) ggTry('aw_underdog');
  const data = ggLoad();
  assert(!data.achievements['aw_underdog'], 'aw_underdog NOT unlocked at 9 vs 5');
}

// aw_speed_demon: under 30 seconds
{
  resetStorage();
  const battleTime = 25;
  if (battleTime < 30) ggTry('aw_speed_demon');
  const data = ggLoad();
  assert(data.achievements['aw_speed_demon'], 'aw_speed_demon unlocked at 25s');
  assertEqual(data.gBux, 20, 'aw_speed_demon awards 20 G Bux');
}

// aw_speed_demon: NOT at 30s
{
  resetStorage();
  const battleTime = 30;
  if (battleTime < 30) ggTry('aw_speed_demon');
  const data = ggLoad();
  assert(!data.achievements['aw_speed_demon'], 'aw_speed_demon NOT unlocked at exactly 30s');
}

// aw_commander: 5 wins
{
  resetStorage();
  const stats = { wins: 5, battles: 8 };
  if (stats.wins >= 5) ggTry('aw_commander');
  const data = ggLoad();
  assert(data.achievements['aw_commander'], 'aw_commander unlocked at 5 wins');
  assertEqual(data.gBux, 25, 'aw_commander awards 25 G Bux');
}

// aw_warlord: 10 wins
{
  resetStorage();
  const stats = { wins: 10, battles: 15 };
  if (stats.wins >= 10) ggTry('aw_warlord');
  const data = ggLoad();
  assert(data.achievements['aw_warlord'], 'aw_warlord unlocked at 10 wins');
  assertEqual(data.gBux, 50, 'aw_warlord awards 50 G Bux');
}

// Achievement total
{
  const totalReward = Object.values(AW_ACH).reduce((s, a) => s + a.reward, 0);
  assertEqual(totalReward, 215, 'Total achievement rewards = 215 G Bux');
  assertEqual(Object.keys(AW_ACH).length, 10, 'Total achievements = 10');
}

// No duplicate unlock
{
  resetStorage();
  const r1 = ggUnlockAchievement('aw_victor', 'Victorious', 10);
  const r2 = ggUnlockAchievement('aw_victor', 'Victorious', 10);
  assert(r1 === true, 'First unlock returns true');
  assert(r2 === false, 'Duplicate unlock returns false');
  assertEqual(ggLoad().gBux, 10, 'G Bux only awarded once');
}

// ─── STATS PERSISTENCE ───
group('Stats Persistence');

{
  resetStorage();
  const s = loadStats();
  assertEqual(s.wins, 0, 'Initial wins = 0');
  assertEqual(s.battles, 0, 'Initial battles = 0');
}

{
  resetStorage();
  const s = loadStats();
  s.battles++;
  s.wins++;
  saveStats(s);
  const loaded = loadStats();
  assertEqual(loaded.wins, 1, 'Wins round-trips to 1');
  assertEqual(loaded.battles, 1, 'Battles round-trips to 1');
}

{
  resetStorage();
  saveStats({ wins: 7, battles: 12 });
  const s = loadStats();
  assertEqual(s.wins, 7, 'Multiple wins persist (7)');
  assertEqual(s.battles, 12, 'Multiple battles persist (12)');
}

// ─── VICTORY BONUS GOLD ───
group('Victory Bonus Gold');

{
  resetStorage();
  const s = loadStats();
  assertEqual(s.bonusGold, 0, 'Initial bonusGold = 0');
}

{
  resetStorage();
  // Simulate a battle win awarding 50 bonus gold
  const stats = loadStats();
  stats.battles++;
  stats.wins++;
  stats.bonusGold += 50;
  saveStats(stats);
  const loaded = loadStats();
  assertEqual(loaded.bonusGold, 50, 'Bonus gold = 50 after 1 win');
}

{
  resetStorage();
  // Simulate 3 wins accumulating bonus gold
  const stats = loadStats();
  for (let i = 0; i < 3; i++) {
    stats.battles++;
    stats.wins++;
    stats.bonusGold += 50;
  }
  saveStats(stats);
  const loaded = loadStats();
  assertEqual(loaded.bonusGold, 150, 'Bonus gold = 150 after 3 wins');
  assertEqual(loaded.wins, 3, 'Wins tracked correctly (3)');
}

{
  resetStorage();
  // Loss does NOT award bonus gold
  const stats = loadStats();
  stats.battles++;
  // no stats.wins++ or bonusGold += 50
  saveStats(stats);
  const loaded = loadStats();
  assertEqual(loaded.bonusGold, 0, 'Bonus gold = 0 after a loss');
  assertEqual(loaded.battles, 1, 'Battle count still incremented on loss');
}

{
  resetStorage();
  // Bonus gold adds to skirmish deployment budget
  saveStats({ wins: 2, battles: 3, bonusGold: 100 });
  const stats = loadStats();
  const skirmishBudget = MAX_BUDGET + stats.bonusGold;
  assertEqual(skirmishBudget, 300, 'Skirmish budget = 200 + 100 bonusGold = 300');
}

{
  resetStorage();
  // Zero bonus gold means default budget
  const stats = loadStats();
  const skirmishBudget = MAX_BUDGET + stats.bonusGold;
  assertEqual(skirmishBudget, 200, 'No bonus gold: skirmish budget = 200');
}

{
  resetStorage();
  // Bonus gold adds to campaign start gold
  saveStats({ wins: 1, battles: 1, bonusGold: 50 });
  const stats = loadStats();
  const campaignGold = LEVEL_DEFS[0].startGold + stats.bonusGold;
  assertEqual(campaignGold, LEVEL_DEFS[0].startGold + 50, 'Campaign level 1 gold includes bonusGold');
}

{
  resetStorage();
  // Old stats without bonusGold still load correctly
  localStorage.setItem(STATS_KEY, JSON.stringify({ wins: 5, battles: 10 }));
  const s = loadStats();
  assertEqual(s.wins, 5, 'Legacy stats: wins preserved');
  assertEqual(s.battles, 10, 'Legacy stats: battles preserved');
  assertEqual(s.bonusGold, 0, 'Legacy stats: bonusGold defaults to 0');
}

{
  resetStorage();
  // 10 wins = 500 bonus gold
  saveStats({ wins: 10, battles: 15, bonusGold: 500 });
  const loaded = loadStats();
  assertEqual(loaded.bonusGold, 500, '10 wins: bonusGold = 500');
  assertEqual(MAX_BUDGET + loaded.bonusGold, 700, 'Skirmish budget = 200 + 500 = 700');
}

// ─── G BUX INTEGRATION ───
group('G Bux Integration');

{
  resetStorage();
  const data = ggLoad();
  assertEqual(data.gBux, 0, 'Default gBux = 0');
  assert(typeof data.achievements === 'object', 'achievements is an object');
  assert(typeof data.shopPurchases === 'object', 'shopPurchases is an object');
}

{
  resetStorage();
  ggUnlockAchievement('aw_first_battle', 'First Blood', 5);
  ggUnlockAchievement('aw_victor', 'Victorious', 10);
  const data = ggLoad();
  assertEqual(data.gBux, 15, 'G Bux accumulates: 5 + 10 = 15');
  assert(data.achievements['aw_first_battle'], 'First achievement saved');
  assert(data.achievements['aw_victor'], 'Second achievement saved');
}

// Shop purchase check
{
  resetStorage();
  const data = ggLoad();
  data.gBux = 100;
  data.shopPurchases['aw_war_elephant'] = true;
  ggSave(data);
  const loaded = ggLoad();
  assertEqual(loaded.gBux, 100, 'G Bux preserved after shop save');
  assert(loaded.shopPurchases['aw_war_elephant'], 'Shop purchase persists');
}

// ─── LAUNCHER TOTALS ───
group('Launcher Totals');

// These test the expected totals in the launcher
{
  // From CLAUDE.md plan: 48 achievements, 1145G earnable, 9 shop items, 675G shop total
  // Hurgvibbit: 10 ach, 225G
  // Mini Life: 18 ach, 520G
  // Tower Defense: 10 ach, 185G
  // Ancient Warfare: 10 ach, 215G
  const totalAch = 10 + 18 + 10 + 10;
  assertEqual(totalAch, 48, 'Total achievements across all games = 48');

  const totalG = 225 + 520 + 185 + 215;
  assertEqual(totalG, 1145, 'Total earnable G Bux = 1145');

  // Shop items: Hurg(2) + ML(3) + TD(2) + AW(2) = 9
  const shopCount = 2 + 3 + 2 + 2;
  assertEqual(shopCount, 9, 'Total shop items = 9');

  // Shop costs: 50+75+50+100+150+75+50+75+50 = 675
  const shopTotal = 50 + 75 + 50 + 100 + 150 + 75 + 50 + 75 + 50;
  assertEqual(shopTotal, 675, 'Total shop cost = 675 G Bux');
}

// ─── PROJECTILE LIFECYCLE ───
group('Projectile Lifecycle');

{
  // Arrow: straight line, single target
  const start = { x: 0, y: 1.2, z: 0 };
  const end = { x: 5, y: 1.2, z: 0 };
  const totalDist = Math.sqrt((end.x - start.x)**2 + (end.z - start.z)**2);
  assertEqual(totalDist, 5, 'Arrow travel distance = 5');

  // Progress simulation
  const speed = 15;
  let progress = 0;
  const dt = 0.1;
  progress += (speed * dt) / totalDist;
  assertApprox(progress, 0.3, 0.001, 'Arrow progress after 0.1s at speed 15 over dist 5 = 0.3');

  // Reaches target
  let steps = 0;
  progress = 0;
  while (progress < 1 && steps < 100) {
    progress += (speed * dt) / totalDist;
    steps++;
  }
  assert(progress >= 1, 'Arrow reaches target');
  assert(steps <= 4, 'Arrow arrives in ~4 steps (0.4s)');
}

{
  // Boulder: parabolic arc
  const progress = 0.5;
  const totalDist = 10;
  const arc = Math.sin(progress * Math.PI) * totalDist * 0.3;
  assertApprox(arc, 3, 0.01, 'Boulder arc height at midpoint = 3 (dist*0.3)');

  const arcStart = Math.sin(0 * Math.PI) * totalDist * 0.3;
  assertEqual(arcStart, 0, 'Boulder arc at start = 0');

  const arcEnd = Math.sin(1 * Math.PI) * totalDist * 0.3;
  assertApprox(arcEnd, 0, 0.01, 'Boulder arc at end ≈ 0');
}

// ─── CAMERA CLAMPS ───
group('Camera Clamps');

{
  // Camera distance clamps
  const CAM_MIN_DIST = 10, CAM_MAX_DIST = 50;
  let dist = 30;
  dist = Math.max(CAM_MIN_DIST, Math.min(CAM_MAX_DIST, dist + 100));
  assertEqual(dist, 50, 'Camera distance clamped to max 50');

  dist = 30;
  dist = Math.max(CAM_MIN_DIST, Math.min(CAM_MAX_DIST, dist - 100));
  assertEqual(dist, 10, 'Camera distance clamped to min 10');
}

{
  // Camera pitch clamps
  let pitch = Math.PI / 4;
  pitch = Math.max(0.2, Math.min(Math.PI / 2 - 0.1, pitch + 10));
  assertApprox(pitch, Math.PI / 2 - 0.1, 0.001, 'Camera pitch clamped to max ~1.47');

  pitch = Math.PI / 4;
  pitch = Math.max(0.2, Math.min(Math.PI / 2 - 0.1, pitch - 10));
  assertEqual(pitch, 0.2, 'Camera pitch clamped to min 0.2');
}

{
  // Camera target clamps to field
  let tx = 100;
  tx = Math.max(-FIELD_W / 2, Math.min(FIELD_W / 2, tx));
  assertEqual(tx, 20, 'Camera target X clamped to field edge 20');

  let tz = -50;
  tz = Math.max(-FIELD_D / 2, Math.min(FIELD_D / 2, tz));
  assertEqual(tz, -15, 'Camera target Z clamped to field edge -15');
}

// ─── DEPLOYMENT BOUNDS ───
group('Deployment Bounds');

{
  // Blue team deploys in left half (x <= 0)
  assert(0 <= 0, 'x=0 is valid deployment position');
  assert(-19 >= -FIELD_W / 2, 'x=-19 is within left edge');
  assert(1 > 0, 'x=1 is NOT valid (right side is enemy zone)');
}

{
  // Z bounds
  assert(14 < FIELD_D / 2, 'z=14 within field depth');
  assert(-14 > -FIELD_D / 2, 'z=-14 within field depth');
}

// ─── UNIT ALIVE/DEATH ───
group('Unit Alive/Death');

{
  const unit = mockUnit('swordsman', 'blue');
  assert(unit.userData.alive, 'Unit starts alive');
  assertEqual(unit.userData.hp, 100, 'Unit starts at full HP');

  // Apply damage
  unit.userData.hp -= 50;
  assert(unit.userData.alive, 'Unit alive at 50 HP');

  // Kill
  unit.userData.hp -= 60;
  if (unit.userData.hp <= 0) {
    unit.userData.hp = 0;
    unit.userData.alive = false;
  }
  assert(!unit.userData.alive, 'Unit dead at 0 HP');
  assertEqual(unit.userData.hp, 0, 'HP clamped to 0');
}

// ─── HEALTH BAR SCALE ───
group('Health Bar Scale');

{
  const hp = 100, maxHp = 100;
  const pct = Math.max(0, hp / maxHp);
  assertEqual(pct, 1, 'Full HP = scale 1.0');
}

{
  const hp = 50, maxHp = 100;
  const pct = Math.max(0, hp / maxHp);
  assertEqual(pct, 0.5, 'Half HP = scale 0.5');
}

{
  const hp = 0, maxHp = 100;
  const pct = Math.max(0, hp / maxHp);
  assertEqual(pct, 0, 'Zero HP = scale 0');
}

{
  const hp = -10, maxHp = 100;
  const pct = Math.max(0, hp / maxHp);
  assertEqual(pct, 0, 'Negative HP clamped to scale 0');
}

// ─── CAMPAIGN: LEVEL DEFINITIONS ───
group('Campaign: Level Definitions');

assertEqual(LEVEL_DEFS.length, 10, 'Exactly 10 campaign levels defined');

// All levels have required fields
{
  const requiredFields = ['name', 'enemies', 'startGold', 'healPct'];
  for (let i = 0; i < LEVEL_DEFS.length; i++) {
    const def = LEVEL_DEFS[i];
    for (const f of requiredFields) {
      assert(def[f] !== undefined, 'Level ' + (i+1) + ' has field: ' + f);
    }
  }
}

// Enemy budgets escalate
{
  const budgets = LEVEL_DEFS.map((_, i) => getLevelEnemyBudget(i));
  for (let i = 1; i < budgets.length; i++) {
    assert(budgets[i] >= budgets[i-1], 'Level ' + (i+1) + ' budget (' + budgets[i] + ') >= level ' + i + ' (' + budgets[i-1] + ')');
  }
}

// Starting gold decreases or stays same
{
  for (let i = 1; i < LEVEL_DEFS.length; i++) {
    assert(LEVEL_DEFS[i].startGold <= LEVEL_DEFS[i-1].startGold,
      'Level ' + (i+1) + ' startGold (' + LEVEL_DEFS[i].startGold + ') <= level ' + i + ' (' + LEVEL_DEFS[i-1].startGold + ')');
  }
}

// Heal percentages decrease or stay same
{
  for (let i = 1; i < LEVEL_DEFS.length; i++) {
    assert(LEVEL_DEFS[i].healPct <= LEVEL_DEFS[i-1].healPct,
      'Level ' + (i+1) + ' healPct (' + LEVEL_DEFS[i].healPct + ') <= level ' + i + ' (' + LEVEL_DEFS[i-1].healPct + ')');
  }
}

// All enemy types are valid UNIT_DEFS keys
{
  for (let i = 0; i < LEVEL_DEFS.length; i++) {
    for (const e of LEVEL_DEFS[i].enemies) {
      assert(UNIT_DEFS[e.type] !== undefined, 'Level ' + (i+1) + ' enemy type "' + e.type + '" exists in UNIT_DEFS');
      assert(e.count > 0, 'Level ' + (i+1) + ' "' + e.type + '" count > 0');
    }
  }
}

// Levels 8-10 include elephants
{
  for (let i = 7; i < 10; i++) {
    const hasElephant = LEVEL_DEFS[i].enemies.some(e => e.type === 'elephant');
    assert(hasElephant, 'Level ' + (i+1) + ' includes elephants');
  }
}

// Level 1 enemy budget
{
  const lvl1Budget = getLevelEnemyBudget(0);
  assertEqual(lvl1Budget, 5*10 + 2*15, 'Level 1 enemy budget = 80 (5 swordsman + 2 archer)');
}

// Level 10 enemy budget
{
  const lvl10Budget = getLevelEnemyBudget(9);
  const expected = 10*10 + 6*15 + 6*12 + 5*25 + 4*40 + 3*50;
  assertEqual(lvl10Budget, expected, 'Level 10 enemy budget = ' + expected);
}

// ─── CAMPAIGN: STATE MANAGEMENT ───
group('Campaign: State Management');

// Initial campaign state
{
  const cs = {
    levelIndex: 0,
    gold: LEVEL_DEFS[0].startGold,
    survivors: [],
    preBattleSnapshot: null,
  };
  assertEqual(cs.gold, 100, 'Level 1 starting gold = 100');
  assertEqual(cs.survivors.length, 0, 'No survivors at start');
  assertEqual(cs.levelIndex, 0, 'Starting at level index 0');
}

// Gold tracking through deployment
{
  let budget = 100; // campaignState.gold for level 1
  budget -= UNIT_DEFS.swordsman.cost; // 90
  budget -= UNIT_DEFS.archer.cost; // 75
  budget -= UNIT_DEFS.cavalry.cost; // 50
  assertEqual(budget, 50, 'Remaining gold after deploying sword+archer+cavalry = 50');
}

// ─── CAMPAIGN: SURVIVOR CARRY-OVER & HEAL ───
group('Campaign: Survivor Carry-Over & Heal');

{
  // Simulate victory: units survive with partial HP
  const healPct = 0.5;
  const survivors = [
    { type: 'swordsman', hp: 40, maxHp: 100 },
    { type: 'archer', hp: 30, maxHp: 60 },
    { type: 'cavalry', hp: 90, maxHp: 90 },  // full HP
  ];

  const healed = survivors.map(s => {
    const newHp = Math.min(s.maxHp, s.hp + (s.maxHp - s.hp) * healPct);
    return { ...s, hp: newHp };
  });

  assertEqual(healed[0].hp, 70, 'Swordsman healed from 40 to 70 (50% of 60 missing)');
  assertEqual(healed[1].hp, 45, 'Archer healed from 30 to 45 (50% of 30 missing)');
  assertEqual(healed[2].hp, 90, 'Full HP cavalry stays at 90');
}

{
  // Heal with 30% heal rate
  const healPct = 0.3;
  const s = { type: 'swordsman', hp: 40, maxHp: 100 };
  const healed = Math.min(s.maxHp, s.hp + (s.maxHp - s.hp) * healPct);
  assertEqual(healed, 58, 'Swordsman healed from 40 to 58 (30% of 60 missing)');
}

{
  // Heal does not exceed maxHp
  const healPct = 1.0;
  const s = { type: 'swordsman', hp: 90, maxHp: 100 };
  const healed = Math.min(s.maxHp, s.hp + (s.maxHp - s.hp) * healPct);
  assertEqual(healed, 100, 'Heal with 100% rate caps at maxHp');
}

// ─── CAMPAIGN: ENEMY SPAWN COUNTS ───
group('Campaign: Enemy Spawn Counts');

{
  for (let i = 0; i < LEVEL_DEFS.length; i++) {
    const def = LEVEL_DEFS[i];
    const totalEnemies = def.enemies.reduce((s, e) => s + e.count, 0);
    assert(totalEnemies > 0, 'Level ' + (i+1) + ' has ' + totalEnemies + ' total enemies');
  }
}

// Level 1: 5 swordsman + 2 archer = 7
{
  const count = LEVEL_DEFS[0].enemies.reduce((s, e) => s + e.count, 0);
  assertEqual(count, 7, 'Level 1 has 7 total enemies');
}

// Level 10: 10+6+6+5+4+3 = 34
{
  const count = LEVEL_DEFS[9].enemies.reduce((s, e) => s + e.count, 0);
  assertEqual(count, 34, 'Level 10 has 34 total enemies');
}

// ─── CAMPAIGN: PRE-BATTLE SNAPSHOT & RETRY ───
group('Campaign: Pre-Battle Snapshot & Retry');

{
  // Simulate snapshot before battle
  const originalGold = 100;
  const originalSurvivors = [
    { type: 'swordsman', hp: 80, maxHp: 100 },
    { type: 'archer', hp: 60, maxHp: 60 },
  ];
  const snapshot = {
    gold: originalGold,
    survivors: originalSurvivors.map(s => ({...s})),
  };

  // Simulate gold spent during deployment
  let goldAfterDeploy = originalGold - 50;

  // Verify snapshot is independent of current state
  assertEqual(snapshot.gold, 100, 'Snapshot preserves original gold (100)');
  assertEqual(goldAfterDeploy, 50, 'Gold after deployment is 50');

  // Retry restores snapshot
  const restoredGold = snapshot.gold;
  const restoredSurvivors = snapshot.survivors.map(s => ({...s}));
  assertEqual(restoredGold, 100, 'Retry restores gold to 100');
  assertEqual(restoredSurvivors.length, 2, 'Retry restores 2 survivors');
  assertEqual(restoredSurvivors[0].hp, 80, 'Restored swordsman HP = 80');
  assertEqual(restoredSurvivors[1].hp, 60, 'Restored archer HP = 60');
}

{
  // Snapshot is a deep copy (modifying restored doesn't affect snapshot)
  const snapshot = {
    gold: 75,
    survivors: [{ type: 'swordsman', hp: 50, maxHp: 100 }],
  };
  const restored = snapshot.survivors.map(s => ({...s}));
  restored[0].hp = 0; // simulate death after retry
  assertEqual(snapshot.survivors[0].hp, 50, 'Snapshot remains unmodified after restored copy is changed');
}

// ─── CAMPAIGN: LEVEL UNLOCK PROGRESSION ───
group('Campaign: Level Unlock Progression');

{
  resetStorage();
  const progress = loadCampaignProgress();
  assertEqual(progress.unlockedLevels, 1, 'Initial unlock = 1 (only level 1)');
}

{
  resetStorage();
  // Beat level 1 → unlock level 2
  const progress = loadCampaignProgress();
  const levelIndex = 0;
  if (levelIndex + 1 >= progress.unlockedLevels && levelIndex + 1 < LEVEL_DEFS.length) {
    progress.unlockedLevels = levelIndex + 2;
  }
  saveCampaignProgress(progress);
  const loaded = loadCampaignProgress();
  assertEqual(loaded.unlockedLevels, 2, 'After beating level 1: unlockedLevels = 2');
}

{
  resetStorage();
  // Beating level 5 unlocks level 6
  saveCampaignProgress({ unlockedLevels: 5 });
  const progress = loadCampaignProgress();
  const levelIndex = 4; // level 5 (0-indexed)
  if (levelIndex + 1 >= progress.unlockedLevels && levelIndex + 1 < LEVEL_DEFS.length) {
    progress.unlockedLevels = levelIndex + 2;
  }
  saveCampaignProgress(progress);
  const loaded = loadCampaignProgress();
  assertEqual(loaded.unlockedLevels, 6, 'After beating level 5: unlockedLevels = 6');
}

{
  resetStorage();
  // Replaying level 1 when level 5 is unlocked doesn't reset progress
  saveCampaignProgress({ unlockedLevels: 5 });
  const progress = loadCampaignProgress();
  const levelIndex = 0; // replay level 1
  if (levelIndex + 1 >= progress.unlockedLevels && levelIndex + 1 < LEVEL_DEFS.length) {
    progress.unlockedLevels = levelIndex + 2;
  }
  saveCampaignProgress(progress);
  const loaded = loadCampaignProgress();
  assertEqual(loaded.unlockedLevels, 5, 'Replaying level 1 does NOT reset unlock progress from 5');
}

{
  resetStorage();
  // Beating level 10 (last) caps at 10
  saveCampaignProgress({ unlockedLevels: 10 });
  const progress = loadCampaignProgress();
  const levelIndex = 9; // level 10
  if (levelIndex + 1 >= progress.unlockedLevels && levelIndex + 1 < LEVEL_DEFS.length) {
    progress.unlockedLevels = levelIndex + 2;
  }
  saveCampaignProgress(progress);
  const loaded = loadCampaignProgress();
  assertEqual(loaded.unlockedLevels, 10, 'After beating level 10: stays at 10 (no level 11)');
}

// ─── CAMPAIGN: BUDGET DISPLAY MODES ───
group('Campaign: Budget Display Modes');

{
  // Skirmish mode: budget shows "Gold: X / 200"
  const isCampaignMode = false;
  const budget = 150;
  const display = isCampaignMode ? 'Gold: ' + budget : 'Gold: ' + budget + ' / 200';
  assertEqual(display, 'Gold: 150 / 200', 'Skirmish displays "Gold: 150 / 200"');
}

{
  // Campaign mode: budget shows "Gold: X" (no max)
  const isCampaignMode = true;
  const budget = 75;
  const display = isCampaignMode ? 'Gold: ' + budget : 'Gold: ' + budget + ' / 200';
  assertEqual(display, 'Gold: 75', 'Campaign displays "Gold: 75" (no max)');
}

// ─── CAMPAIGN: CLEAR DEPLOYMENT BEHAVIOR ───
group('Campaign: Clear Deployment Behavior');

{
  // Skirmish: clear removes ALL units, resets to MAX_BUDGET
  const isCampaignMode = false;
  let deployedUnits = ['unit1', 'unit2', 'unit3'];
  let budget = 150;
  if (!isCampaignMode) {
    deployedUnits = [];
    budget = MAX_BUDGET;
  }
  assertEqual(deployedUnits.length, 0, 'Skirmish clear: all units removed');
  assertEqual(budget, 200, 'Skirmish clear: budget reset to 200');
}

{
  // Campaign: clear removes only new units, keeps survivors
  const isCampaignMode = true;
  const survivorUnits = ['survivor1', 'survivor2'];
  let deployedUnits = ['survivor1', 'survivor2', 'new1', 'new2'];
  let budget = 30;
  const newUnitCosts = [10, 15]; // cost of new1, new2
  if (isCampaignMode) {
    let refund = 0;
    const newUnits = deployedUnits.filter(u => !survivorUnits.includes(u));
    for (let i = 0; i < newUnits.length; i++) refund += newUnitCosts[i];
    deployedUnits = [...survivorUnits];
    budget += refund;
  }
  assertEqual(deployedUnits.length, 2, 'Campaign clear: only survivors remain (2)');
  assertEqual(budget, 55, 'Campaign clear: budget refunded for new units (30 + 10 + 15 = 55)');
}

// ─── CAMPAIGN: KILL GOLD CALCULATION ───
group('Campaign: Kill Gold Calculation');

{
  // Kill gold = sum of costs of killed enemy units
  const killedEnemies = [
    { type: 'swordsman' }, // 10
    { type: 'swordsman' }, // 10
    { type: 'archer' },    // 15
    { type: 'cavalry' },   // 25
  ];
  let killGold = 0;
  for (const u of killedEnemies) killGold += UNIT_DEFS[u.type].cost;
  assertEqual(killGold, 60, 'Kill gold for 2 swordsman + 1 archer + 1 cavalry = 60');
}

{
  // No kills = 0 gold
  const killedEnemies = [];
  let killGold = 0;
  for (const u of killedEnemies) killGold += UNIT_DEFS[u.type].cost;
  assertEqual(killGold, 0, 'No kills = 0 gold');
}

{
  // Full level 1 wipe
  const killedEnemies = LEVEL_DEFS[0].enemies.flatMap(e =>
    Array(e.count).fill({ type: e.type })
  );
  let killGold = 0;
  for (const u of killedEnemies) killGold += UNIT_DEFS[u.type].cost;
  assertEqual(killGold, getLevelEnemyBudget(0), 'Full level 1 wipe gold = level 1 enemy budget (' + getLevelEnemyBudget(0) + ')');
}

// ─── CAMPAIGN: GOLD FLOW ACROSS LEVELS ───
group('Campaign: Gold Flow Across Levels');

{
  // Simulate 2-level campaign: start L1 → win → start L2
  let gold = LEVEL_DEFS[0].startGold; // 100
  assertEqual(gold, 100, 'Start L1 with 100 gold');

  // Deploy 3 swordsmen (30g)
  gold -= 30;
  assertEqual(gold, 70, 'After deploying 3 swordsmen: 70 gold');

  // Win, earn kill gold for all level 1 enemies
  const killGold = getLevelEnemyBudget(0); // 80
  gold += killGold;
  assertEqual(gold, 150, 'After L1 victory: 70 + 80 kill gold = 150');

  // L2 adds its starting gold? No — gold carries over, startGold is only for fresh starts
  // Actually, looking at the code: startCampaignLevel sets gold = startGold for fresh level starts
  // But after victory, campaignState.gold = budget + killGold (carries over)
  // This means gold carries between levels within a campaign run
  assert(gold > 0, 'Gold is positive going into L2');
}

// ─── CAMPAIGN: PERSISTENCE ROUND-TRIP ───
group('Campaign: Persistence Round-Trip');

{
  resetStorage();
  saveCampaignProgress({ unlockedLevels: 7 });
  const loaded = loadCampaignProgress();
  assertEqual(loaded.unlockedLevels, 7, 'Campaign progress round-trips: unlockedLevels = 7');
}

{
  resetStorage();
  // Default when nothing saved
  const loaded = loadCampaignProgress();
  assertEqual(loaded.unlockedLevels, 1, 'Default campaign progress: unlockedLevels = 1');
}

{
  resetStorage();
  // Corrupted data falls back to default
  localStorage.setItem(CAMPAIGN_KEY, 'not-json');
  const loaded = loadCampaignProgress();
  assertEqual(loaded.unlockedLevels, 1, 'Corrupted data falls back to default');
}

// ============================================================
showSummary();
</script>
</body>
</html>
