<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Brawl Monsters — Graham Games</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #0a0a0f;
  color: #eee;
  font-family: 'Segoe UI', Tahoma, sans-serif;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
}

.screen {
  display: none;
  position: absolute;
  top: 0; left: 0;
  width: 100%; height: 100%;
  flex-direction: column;
  align-items: center;
  overflow-y: auto;
}
.screen.active { display: flex; }

/* ═══ TITLE ═══ */
#title-screen {
  justify-content: center;
  background: radial-gradient(ellipse at center, #1a0818 0%, #0a0a0f 70%);
  gap: 16px;
}
.title-logo {
  font-size: 2.8rem;
  margin-bottom: 8px;
  text-shadow: 0 0 20px #e040fb44;
}
.title-name {
  font-family: 'Cinzel Decorative', serif;
  font-size: 2rem;
  color: #e040fb;
  text-shadow: 0 0 30px #e040fb66, 0 0 60px #e040fb22;
  letter-spacing: 0.08em;
}
.title-sub {
  font-size: 0.85rem;
  color: #888;
  margin-bottom: 24px;
}

/* ═══ BUTTONS ═══ */
.btn {
  font-family: 'Cinzel Decorative', serif;
  padding: 12px 36px;
  background: transparent;
  border: 2px solid #e040fb;
  color: #e040fb;
  font-size: 1rem;
  cursor: pointer;
  letter-spacing: 0.08em;
  transition: all 0.2s;
  border-radius: 4px;
}
.btn:hover { background: #e040fb22; box-shadow: 0 0 20px #e040fb33; }
.btn-sm {
  font-family: 'Segoe UI', sans-serif;
  padding: 8px 20px;
  font-size: 0.8rem;
  background: transparent;
  border: 1px solid #555;
  color: #888;
  cursor: pointer;
  transition: all 0.2s;
  border-radius: 4px;
}
.btn-sm:hover { border-color: #e040fb; color: #e040fb; }
.exit-btn {
  font-family: 'Cinzel Decorative', serif;
  display: inline-block;
  padding: 8px 24px;
  color: #666;
  text-decoration: none;
  font-size: 0.75rem;
  letter-spacing: 0.1em;
  border: 1px solid #333;
  transition: all 0.2s;
  margin-top: 8px;
  border-radius: 4px;
}
.exit-btn:hover { color: #e040fb; border-color: #e040fb; }

/* ═══ STATS OVERLAY ═══ */
.stats-overlay {
  display: none;
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  background: #141418;
  border: 2px solid #e040fb;
  border-radius: 8px;
  padding: 24px 32px;
  z-index: 100;
  min-width: 260px;
  text-align: center;
}
.stats-overlay.visible { display: block; }
.stats-overlay h3 { color: #e040fb; margin-bottom: 12px; font-family: 'Cinzel Decorative', serif; }
.stats-overlay .stat-row { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px solid #222; }
.stats-overlay .stat-row span:first-child { color: #888; }
.stats-overlay .stat-row span:last-child { color: #eee; font-weight: bold; }
.stats-backdrop {
  display: none;
  position: fixed;
  top: 0; left: 0; width: 100%; height: 100%;
  background: #000000aa;
  z-index: 99;
}
.stats-backdrop.visible { display: block; }

/* ═══ COLLECTION ═══ */
#collection-screen {
  justify-content: flex-start;
  padding: 24px 16px;
  background: radial-gradient(ellipse at top, #1a0818 0%, #0a0a0f 60%);
}
.collection-header { text-align: center; margin-bottom: 16px; }
.collection-title {
  font-family: 'Cinzel Decorative', serif;
  font-size: 1.5rem;
  color: #e040fb;
  text-shadow: 0 0 20px #e040fb44;
  margin-bottom: 6px;
}
.collection-count { color: #888; font-size: 0.85rem; }
.collection-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
  gap: 12px;
  width: 100%;
  max-width: 700px;
  padding: 0 8px;
}
.collection-card {
  background: #141418;
  border: 2px solid #333;
  border-radius: 8px;
  padding: 10px 8px;
  text-align: center;
  transition: border-color 0.2s;
}
.collection-card.collected { border-color: #e040fb55; }
.collection-card .cc-sprite { height: 60px; display: flex; align-items: center; justify-content: center; margin-bottom: 6px; }
.collection-card .cc-sprite.silhouette { filter: brightness(0) saturate(0); opacity: 0.3; }
.collection-card .cc-name { font-size: 0.85rem; font-weight: bold; margin-bottom: 4px; }
.collection-card .cc-element {
  display: inline-block;
  font-size: 0.65rem;
  padding: 2px 8px;
  border-radius: 10px;
  color: #fff;
  margin-bottom: 6px;
}
.collection-card .cc-stats { font-size: 0.65rem; color: #888; line-height: 1.4; }
.collection-card .cc-stats span { color: #bbb; }

/* ═══ DRAFT ═══ */
#draft-screen {
  justify-content: flex-start;
  padding: 30px 16px;
  background: radial-gradient(ellipse at top, #1a0818 0%, #0a0a0f 60%);
  gap: 12px;
}
.draft-title {
  font-family: 'Cinzel Decorative', serif;
  font-size: 1.4rem;
  color: #e040fb;
}
.draft-sub { font-size: 0.85rem; color: #888; margin-bottom: 8px; }
.draft-cards {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  justify-content: center;
  max-width: 900px;
}
.draft-card {
  width: 160px;
  background: #141418;
  border: 2px solid #333;
  border-radius: 8px;
  padding: 12px;
  cursor: pointer;
  transition: all 0.2s;
  text-align: left;
}
.draft-card:hover { border-color: #666; }
.draft-card.selected { border-color: #4caf50; box-shadow: 0 0 15px #4caf5044; }
.draft-card .dc-header {
  display: flex; align-items: center; gap: 6px; margin-bottom: 8px;
}
.draft-card .dc-icon { font-size: 1.4rem; }
.draft-card .dc-name { font-weight: bold; font-size: 0.9rem; }
.draft-card .dc-element {
  font-size: 0.65rem; padding: 2px 6px; border-radius: 10px; color: #fff;
  font-weight: bold; letter-spacing: 0.05em;
}
.draft-card .dc-stats {
  display: grid; grid-template-columns: 1fr 1fr; gap: 2px;
  font-size: 0.7rem; color: #aaa; margin-bottom: 8px;
}
.draft-card .dc-stats span { display: flex; align-items: center; gap: 3px; }
.draft-card .dc-stats .stat-val { color: #eee; font-weight: bold; }
.draft-card .dc-moves { font-size: 0.65rem; color: #777; }
.draft-card .dc-moves div { padding: 1px 0; }
.draft-selected {
  display: flex; gap: 8px; margin-top: 8px; align-items: center;
}
.draft-slot {
  width: 48px; height: 48px;
  background: #1a1a22;
  border: 2px dashed #444;
  border-radius: 8px;
  display: flex; align-items: center; justify-content: center;
  font-size: 1.3rem;
}
.draft-slot.filled { border-style: solid; border-color: #4caf50; }

/* ═══ BATTLE ═══ */
#battle-screen {
  justify-content: flex-start;
  background: #0a0a0f;
  padding: 0;
}
.battle-top-bar {
  width: 100%;
  background: #141418;
  border-bottom: 1px solid #222;
  padding: 8px 16px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.8rem;
  flex-shrink: 0;
}
.battle-top-bar .floor-label { color: #e040fb; font-weight: bold; }
.enemy-pips { display: flex; gap: 4px; }
.enemy-pips .pip {
  width: 10px; height: 10px; border-radius: 50%;
  border: 1px solid #444;
}
.battle-area {
  flex: 1;
  width: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
}

/* ═══ BATTLE SCENE (fullscreen-ish) ═══ */
.battle-scene {
  flex: 1;
  width: 100%;
  background: linear-gradient(180deg, #08081a 0%, #0c0c1a 30%, #101820 55%, #1a2a18 80%, #1e3320 100%);
  position: relative;
  overflow: hidden;
  display: flex;
  align-items: flex-end;
  justify-content: space-around;
  padding: 0 24px;
  min-height: 180px;
}
.battle-scene .ground {
  position: absolute;
  bottom: 0; left: 0; right: 0; height: 30px;
  background: linear-gradient(180deg, #1e3320, #162818);
  border-top: 1px solid #2a4a28;
}
.battle-scene .grass-tuft {
  position: absolute;
  bottom: 29px;
  width: 14px; height: 10px;
  border-radius: 50% 50% 0 0;
  background: #2a5a28;
  opacity: 0.5;
}

/* Sprite wrapper with HUD overlay */
.sprite-wrapper {
  position: relative;
  z-index: 2;
  margin-bottom: 26px;
  display: flex;
  flex-direction: column;
  align-items: center;
}
.sprite-hud {
  width: 120px;
  margin-bottom: 4px;
  pointer-events: none;
}
.sprite-hud .sh-header {
  display: flex;
  align-items: center;
  gap: 4px;
  margin-bottom: 2px;
}
.sprite-hud .sh-name {
  font-weight: bold;
  font-size: 0.7rem;
  text-shadow: 0 1px 4px #000, 0 0 8px #000;
}
.sprite-hud .sh-element {
  font-size: 0.5rem;
  padding: 1px 5px;
  border-radius: 8px;
  color: #fff;
  font-weight: bold;
  margin-left: auto;
}
.sprite-hud .sh-enemy-stats {
  font-size: 0.55rem;
  color: #aaa;
  text-shadow: 0 1px 3px #000;
  margin-left: 2px;
}
.sprite-hud .hp-bar-container {
  width: 100%;
  height: 10px;
  background: #00000088;
  border-radius: 5px;
  overflow: hidden;
  position: relative;
  border: 1px solid #ffffff22;
}
.sprite-hud .hp-bar {
  height: 100%;
  border-radius: 5px;
  transition: width 0.4s ease-out;
}
.sprite-hud .hp-text {
  position: absolute;
  top: 0; left: 0; right: 0; bottom: 0;
  display: flex; align-items: center; justify-content: center;
  font-size: 0.5rem; font-weight: bold;
  text-shadow: 0 0 3px #000;
}
.sprite-hud .status-icons {
  display: flex; gap: 3px; margin-top: 2px; min-height: 14px; justify-content: center;
}
.sprite-hud .status-icon {
  font-size: 0.55rem;
  padding: 1px 4px;
  background: #00000088;
  border-radius: 3px;
  animation: scaleIn 0.2s;
  text-shadow: 0 0 3px #000;
}
@keyframes scaleIn { from { transform: scale(0); } to { transform: scale(1); } }

.sprite-container {
  position: relative;
  transition: opacity 0.4s;
}
.sprite-container.enemy-sprite {
  animation: monBob 2s ease-in-out infinite;
}
.sprite-container.player-sprite {
  animation: monBob 2s ease-in-out infinite 0.5s;
}

/* Flash effects on the sprite wrappers */
.sprite-wrapper.flash-red .sprite-container svg { filter: drop-shadow(0 4px 8px #00000088) brightness(2) saturate(0.5); }
.sprite-wrapper.flash-green .sprite-container svg { filter: drop-shadow(0 4px 8px #00000088) brightness(1.5) hue-rotate(90deg); }
.sprite-container.attacking-right {
  animation: monAttackRight 0.35s ease-out !important;
}
.sprite-container.attacking-left {
  animation: monAttackLeft 0.35s ease-out !important;
}
.sprite-container.hit {
  animation: monHit 0.25s ease-out !important;
}
.sprite-container.faint {
  animation: monFaint 0.5s ease-out forwards !important;
}
.sprite-container svg {
  display: block;
  filter: drop-shadow(0 4px 8px #00000088);
}

@keyframes monBob {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-5px); }
}
@keyframes monAttackRight {
  0% { transform: translateX(0); }
  40% { transform: translateX(25px); }
  100% { transform: translateX(0); }
}
@keyframes monAttackLeft {
  0% { transform: translateX(0); }
  40% { transform: translateX(-25px); }
  100% { transform: translateX(0); }
}
@keyframes monHit {
  0% { transform: translateX(0); }
  20% { transform: translateX(-6px); }
  40% { transform: translateX(6px); }
  60% { transform: translateX(-4px); }
  80% { transform: translateX(4px); }
  100% { transform: translateX(0); }
}
@keyframes monFaint {
  0% { transform: translateY(0); opacity: 1; }
  100% { transform: translateY(20px); opacity: 0; }
}

.team-bar {
  display: flex;
  gap: 4px;
  justify-content: center;
  padding: 4px 0;
  flex-shrink: 0;
  position: absolute;
  bottom: 4px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 5;
}
.team-pip {
  width: 28px; height: 28px;
  background: #00000088;
  border: 2px solid #ffffff33;
  border-radius: 6px;
  display: flex; align-items: center; justify-content: center;
  font-size: 0.8rem;
  transition: all 0.2s;
  backdrop-filter: blur(4px);
}
.team-pip.active { border-color: #e040fb; background: #e040fb22; }
.team-pip.fainted { opacity: 0.3; }

.battle-log {
  background: #0a0a10;
  border-top: 1px solid #1a1a22;
  padding: 4px 12px;
  font-size: 0.65rem;
  color: #777;
  height: 48px;
  overflow-y: auto;
  flex-shrink: 0;
}
.battle-log div { padding: 1px 0; }
.battle-log .log-super { color: #ffcc00; }
.battle-log .log-nve { color: #666; }
.battle-log .log-status { color: #e040fb; }
.battle-log .log-faint { color: #ff4444; }
.battle-log .log-heal { color: #4caf50; }

.action-panel {
  width: 100%;
  max-width: 500px;
  align-self: center;
  padding: 8px 16px 16px;
  flex-shrink: 0;
}
.move-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 6px;
  margin-bottom: 8px;
}
.move-btn {
  padding: 10px 12px;
  background: #1a1a22;
  border: 1px solid #333;
  border-radius: 6px;
  color: #eee;
  cursor: pointer;
  font-family: 'Segoe UI', sans-serif;
  font-size: 0.8rem;
  transition: all 0.15s;
  text-align: left;
  display: flex;
  align-items: center;
  gap: 8px;
}
.move-btn:hover:not(:disabled) { border-color: #e040fb; background: #e040fb11; }
.move-btn:disabled { opacity: 0.4; cursor: not-allowed; }
.move-btn .type-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
.move-btn .move-info { display: flex; flex-direction: column; flex: 1; }
.move-btn .move-name { font-weight: bold; }
.move-btn .move-detail { font-size: 0.6rem; color: #888; }
.move-btn .eff-badge {
  font-size: 0.55rem;
  padding: 1px 4px;
  border-radius: 3px;
  font-weight: bold;
}
.eff-badge.super { background: #ffcc0033; color: #ffcc00; }
.eff-badge.nve { background: #66666633; color: #666; }
.switch-btn {
  width: 100%;
  padding: 8px;
  background: #1a1a22;
  border: 1px solid #333;
  border-radius: 6px;
  color: #aaa;
  cursor: pointer;
  font-family: 'Segoe UI', sans-serif;
  font-size: 0.75rem;
  transition: all 0.15s;
}
.switch-btn:hover { border-color: #e040fb; color: #e040fb; }

.switch-panel {
  display: none;
  flex-direction: column;
  gap: 6px;
}
.switch-panel.visible { display: flex; }
.switch-option {
  display: flex;
  align-items: center;
  gap: 10px;
  padding: 10px;
  background: #1a1a22;
  border: 1px solid #333;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.15s;
}
.switch-option:hover { border-color: #e040fb; }
.switch-option .so-icon { font-size: 1.2rem; }
.switch-option .so-name { font-weight: bold; font-size: 0.85rem; }
.switch-option .so-hp { font-size: 0.7rem; color: #888; margin-left: auto; }

.battle-msg {
  display: none;
  position: fixed;
  top: 50%; left: 50%;
  transform: translate(-50%, -50%);
  font-family: 'Cinzel Decorative', serif;
  font-size: 1.6rem;
  z-index: 50;
  text-shadow: 0 0 30px #000;
  animation: popIn 0.4s ease-out;
}
@keyframes popIn { from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; } to { transform: translate(-50%, -50%) scale(1); opacity: 1; } }

/* ═══ REWARD ═══ */
#reward-screen {
  justify-content: center;
  background: radial-gradient(ellipse at center, #1a0818 0%, #0a0a0f 70%);
  gap: 16px;
}
.reward-title {
  font-family: 'Cinzel Decorative', serif;
  font-size: 1.3rem;
  color: #e040fb;
}
.reward-sub { font-size: 0.8rem; color: #888; }
.reward-cards {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  justify-content: center;
}
.reward-card {
  width: 150px;
  background: #141418;
  border: 2px solid #333;
  border-radius: 8px;
  padding: 16px;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
}
.reward-card:hover { border-color: #e040fb; box-shadow: 0 0 15px #e040fb33; }
.reward-card .rc-icon { font-size: 2rem; margin-bottom: 8px; }
.reward-card .rc-name { font-weight: bold; font-size: 0.9rem; margin-bottom: 6px; }
.reward-card .rc-desc { font-size: 0.7rem; color: #888; }

/* ═══ MOVE TUTOR ═══ */
#tutor-screen {
  justify-content: center;
  background: radial-gradient(ellipse at center, #1a0818 0%, #0a0a0f 70%);
  gap: 12px;
}
.tutor-title {
  font-family: 'Cinzel Decorative', serif;
  font-size: 1.2rem;
  color: #e040fb;
}
.tutor-sub { font-size: 0.8rem; color: #888; }
.tutor-monsters { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
.tutor-mon {
  padding: 10px 16px;
  background: #141418;
  border: 2px solid #333;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
}
.tutor-mon:hover { border-color: #e040fb; }
.tutor-mon.selected { border-color: #4caf50; }
.tutor-mon .tm-icon { font-size: 1.4rem; }
.tutor-mon .tm-name { font-size: 0.8rem; font-weight: bold; }
.tutor-moves { display: flex; gap: 6px; flex-wrap: wrap; justify-content: center; }
.tutor-move-btn {
  padding: 8px 14px;
  background: #1a1a22;
  border: 1px solid #444;
  border-radius: 6px;
  color: #eee;
  cursor: pointer;
  font-size: 0.75rem;
  transition: all 0.15s;
}
.tutor-move-btn:hover { border-color: #ff4444; color: #ff4444; }
.tutor-new-move {
  background: #141418;
  border: 2px solid #4caf50;
  border-radius: 8px;
  padding: 12px 20px;
  text-align: center;
}
.tutor-new-move .tnm-name { font-weight: bold; color: #4caf50; }
.tutor-new-move .tnm-detail { font-size: 0.75rem; color: #888; margin-top: 4px; }

/* ═══ RESULT SCREENS ═══ */
#defeat-screen, #victory-screen {
  justify-content: center;
  gap: 12px;
}
#defeat-screen { background: radial-gradient(ellipse at center, #1a0808 0%, #0a0a0f 70%); }
#victory-screen { background: radial-gradient(ellipse at center, #1a1808 0%, #0a0a0f 70%); }
.result-title {
  font-family: 'Cinzel Decorative', serif;
  font-size: 2rem;
}
.result-title.win { color: #ffcc00; text-shadow: 0 0 30px #ffcc0044; }
.result-title.lose { color: #ff4444; text-shadow: 0 0 30px #ff444444; }
.result-stats {
  background: #141418;
  border: 1px solid #222;
  border-radius: 8px;
  padding: 16px 24px;
  min-width: 220px;
}
.result-stats .rs-row {
  display: flex; justify-content: space-between; padding: 4px 0;
  font-size: 0.85rem;
}
.result-stats .rs-row span:first-child { color: #888; }
.result-stats .rs-row span:last-child { font-weight: bold; }

/* ═══ TOAST ═══ */
.gg-toast {
  position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(80px);
  z-index: 200; background: linear-gradient(135deg, #1a1a22 0%, #2a2220 100%);
  border: 2px solid #c9a84c; border-radius: 8px; padding: 12px 24px;
  display: flex; align-items: center; gap: 12px;
  box-shadow: 0 0 30px #c9a84c44, 0 4px 20px #00000088;
  opacity: 0; transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
  pointer-events: none; font-family: 'Segoe UI', Tahoma, sans-serif;
}
.gg-toast.visible { opacity: 1; transform: translateX(-50%) translateY(0); }
.gg-toast-icon { font-size: 1.8rem; }
.gg-toast-title { font-size: 0.65rem; color: #c9a84c; text-transform: uppercase; letter-spacing: 0.1em; }
.gg-toast-name { font-size: 0.95rem; color: #eee; font-weight: bold; }
.gg-toast-reward { font-size: 0.85rem; color: #c9a84c; font-weight: bold; }

/* ═══ TUTORIAL ═══ */
.tutorial-backdrop {
  display: none;
  position: fixed;
  top: 0; left: 0; width: 100%; height: 100%;
  background: #000000aa;
  z-index: 300;
}
.tutorial-backdrop.visible { display: block; }
.tutorial-tooltip {
  display: none;
  position: fixed;
  z-index: 310;
  background: #1a1a22;
  border: 2px solid #e040fb;
  border-radius: 8px;
  padding: 16px 20px;
  max-width: 320px;
  box-shadow: 0 0 30px #e040fb33, 0 4px 20px #00000088;
  animation: ttFadeIn 0.3s ease-out;
}
.tutorial-tooltip.visible { display: block; }
.tutorial-tooltip.arrow-up::before {
  content: '';
  position: absolute;
  top: -8px; left: 50%; transform: translateX(-50%);
  border-left: 8px solid transparent;
  border-right: 8px solid transparent;
  border-bottom: 8px solid #e040fb;
}
.tutorial-tooltip.arrow-down::after {
  content: '';
  position: absolute;
  bottom: -8px; left: 50%; transform: translateX(-50%);
  border-left: 8px solid transparent;
  border-right: 8px solid transparent;
  border-top: 8px solid #e040fb;
}
.tt-title {
  font-family: 'Cinzel Decorative', serif;
  font-size: 0.9rem;
  color: #e040fb;
  margin-bottom: 6px;
}
.tt-text {
  font-size: 0.8rem;
  color: #ccc;
  line-height: 1.4;
  margin-bottom: 12px;
}
.tt-buttons { display: flex; align-items: center; gap: 8px; }
.tt-btn {
  padding: 6px 20px;
  background: #e040fb22;
  border: 1px solid #e040fb;
  color: #e040fb;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.75rem;
  font-weight: bold;
  letter-spacing: 0.05em;
  transition: all 0.2s;
}
.tt-btn:hover { background: #e040fb44; }
.tt-skip {
  padding: 4px 8px;
  background: transparent;
  border: none;
  color: #555;
  cursor: pointer;
  font-size: 0.65rem;
  transition: color 0.2s;
}
.tt-skip:hover { color: #888; }
.tutorial-highlight {
  position: relative !important;
  z-index: 305 !important;
}
@keyframes ttFadeIn {
  from { opacity: 0; transform: translateY(8px); }
  to { opacity: 1; transform: translateY(0); }
}

/* ═══ TRAINER SCREEN ═══ */
#trainer-screen {
  justify-content: flex-start;
  padding: 20px;
  gap: 12px;
  background: radial-gradient(ellipse at center, #1a0818 0%, #0a0a0f 70%);
}
.trainer-title {
  font-family: 'Cinzel Decorative', serif;
  font-size: 1.3rem;
  color: #e040fb;
}
.trainer-layout {
  display: flex;
  gap: 24px;
  align-items: flex-start;
  width: 100%;
  max-width: 540px;
}
.trainer-preview {
  flex-shrink: 0;
  width: 120px;
  height: 160px;
  background: #141418;
  border: 2px solid #333;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
}
.trainer-options {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.trainer-row {
  display: flex;
  align-items: center;
  gap: 8px;
}
.trainer-row-label {
  font-size: 0.7rem;
  color: #888;
  width: 48px;
  flex-shrink: 0;
  text-transform: uppercase;
}
.trainer-swatches {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
}
.trainer-swatch {
  width: 32px;
  height: 32px;
  border-radius: 6px;
  border: 2px solid #333;
  cursor: pointer;
  transition: all 0.15s;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.65rem;
  color: #aaa;
  background: #1a1a22;
  overflow: hidden;
}
.trainer-swatch:hover { border-color: #888; }
.trainer-swatch.selected { border-color: #e040fb; box-shadow: 0 0 8px #e040fb44; }
.trainer-name-input {
  background: #141418;
  border: 2px solid #333;
  border-radius: 6px;
  color: #eee;
  padding: 8px 12px;
  font-size: 0.9rem;
  width: 100%;
  max-width: 200px;
  outline: none;
  transition: border-color 0.2s;
}
.trainer-name-input:focus { border-color: #e040fb; }
.trainer-name-warn {
  color: #ff4444;
  font-size: 0.7rem;
  min-height: 16px;
}
.trainer-name-label {
  font-size: 0.8rem;
  color: #ccc;
}

/* ═══ TRAINER IN BATTLE ═══ */
.trainer-battle {
  position: absolute;
  right: 12%;
  bottom: 32px;
  z-index: 1;
  opacity: 0.9;
  animation: trainerSway 3s ease-in-out infinite;
}
.trainer-name-tag {
  position: absolute;
  bottom: 2px;
  right: 10%;
  transform: none;
  z-index: 6;
  font-size: 0.5rem;
  color: #aaa;
  background: #00000088;
  padding: 1px 6px;
  border-radius: 4px;
  white-space: nowrap;
  text-shadow: 0 0 3px #000;
  pointer-events: none;
}
@keyframes trainerSway {
  0%, 100% { transform: translateX(0); }
  50% { transform: translateX(2px); }
}

/* ═══ MOBILE ═══ */
@media (max-width: 600px) {
  .title-name { font-size: 1.4rem; }
  .title-logo { font-size: 2rem; }
  .draft-card { width: 140px; padding: 10px; }
  .draft-card .dc-name { font-size: 0.8rem; }
  .battle-area { padding: 8px; }
  .battle-scene { min-height: 120px; padding: 0 10px; }
  .battle-scene svg { max-width: 60px; max-height: 60px; }
  .sprite-hud { width: 90px; }
  .sprite-hud .sh-name { font-size: 0.6rem; }
  .sprite-hud .sh-element { font-size: 0.45rem; }
  .sprite-hud .hp-bar-container { height: 8px; }
  .sprite-wrapper { margin-bottom: 20px; }
  .team-bar { bottom: 2px; }
  .team-pip { width: 22px; height: 22px; font-size: 0.7rem; }
  .action-panel { padding: 6px 8px 12px; }
  .move-btn { padding: 8px; font-size: 0.75rem; }
  .reward-card { width: 130px; padding: 12px; }
  .result-title { font-size: 1.4rem; }
  .tutorial-tooltip { max-width: 280px; padding: 12px 16px; }
  .tt-title { font-size: 0.8rem; }
  .tt-text { font-size: 0.75rem; }
  .trainer-layout { flex-direction: column; align-items: center; }
  .trainer-preview { width: 100px; height: 130px; }
  .trainer-swatch { width: 24px; height: 24px; }
  .trainer-battle { right: 6%; }
  .trainer-battle svg { max-width: 50px; max-height: 50px; }
  .collection-title { font-size: 1.1rem; }
  .collection-grid { grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap: 8px; }
  .collection-card { padding: 8px 6px; }
  .collection-card .cc-sprite { height: 45px; }
  .collection-card .cc-sprite svg { max-width: 45px; max-height: 45px; }
  .collection-card .cc-name { font-size: 0.75rem; }
}

@keyframes shake {
  0%,100% { transform: translateX(0); }
  25% { transform: translateX(-4px); }
  75% { transform: translateX(4px); }
}
.shake { animation: shake 0.2s; }
</style>
</head>
<body>

<!-- Title Screen -->
<div class="screen active" id="title-screen">
  <div class="title-logo">&#128126;&#9876;&#128126;</div>
  <div class="title-name">BRAWL MONSTERS</div>
  <div class="title-sub">A Monster Battler Roguelike</div>
  <button class="btn" onclick="startDraft()">START RUN</button>
  <button class="btn-sm" onclick="showCollection()">COLLECTION</button>
  <button class="btn-sm" onclick="showStats()">BEST RUNS</button>
  <button class="btn-sm" onclick="showTrainerScreen()">EDIT TRAINER</button>
  <a href="../index.html" class="exit-btn">EXIT TO LAUNCHER</a>
</div>

<!-- Trainer Screen -->
<div class="screen" id="trainer-screen">
  <div class="trainer-title">CREATE YOUR TRAINER</div>
  <div class="trainer-layout">
    <div class="trainer-preview" id="trainer-preview"></div>
    <div class="trainer-options">
      <div>
        <div class="trainer-name-label">Name</div>
        <input class="trainer-name-input" id="trainer-name" type="text" maxlength="12" placeholder="Your Name" oninput="onTrainerNameInput()">
        <div class="trainer-name-warn" id="trainer-name-warn"></div>
      </div>
      <div class="trainer-row"><span class="trainer-row-label">Skin</span><div class="trainer-swatches" id="sw-skin"></div></div>
      <div class="trainer-row"><span class="trainer-row-label">Hair</span><div class="trainer-swatches" id="sw-hairColor"></div></div>
      <div class="trainer-row"><span class="trainer-row-label">Style</span><div class="trainer-swatches" id="sw-hairStyle"></div></div>
      <div class="trainer-row"><span class="trainer-row-label">Shirt</span><div class="trainer-swatches" id="sw-shirtColor"></div></div>
      <div class="trainer-row"><span class="trainer-row-label">Extra</span><div class="trainer-swatches" id="sw-accessory"></div></div>
    </div>
  </div>
  <button class="btn" id="trainer-done-btn" onclick="saveTrainerAndContinue()">DONE</button>
  <button class="btn-sm" onclick="showScreen('title-screen')">BACK</button>
</div>

<!-- Stats Overlay -->
<div class="stats-backdrop" id="stats-backdrop" onclick="hideStats()"></div>
<div class="stats-overlay" id="stats-overlay">
  <h3>RUN STATS</h3>
  <div id="stats-content"></div>
  <button class="btn-sm" onclick="hideStats()" style="margin-top:12px">CLOSE</button>
</div>

<!-- Collection Screen -->
<div class="screen" id="collection-screen">
  <div class="collection-header">
    <div class="collection-title">MONSTER COLLECTION</div>
    <div class="collection-count" id="collection-count"></div>
  </div>
  <div class="collection-grid" id="collection-grid"></div>
  <button class="btn-sm" onclick="showScreen('title-screen')" style="margin:16px 0 24px">BACK</button>
</div>

<!-- Draft Screen -->
<div class="screen" id="draft-screen">
  <div class="draft-title">CHOOSE YOUR TEAM</div>
  <div class="draft-sub" id="draft-sub">Select 3 monsters (0/3)</div>
  <div class="draft-cards" id="draft-cards"></div>
  <div class="draft-selected" id="draft-selected">
    <div class="draft-slot" id="ds0">?</div>
    <div class="draft-slot" id="ds1">?</div>
    <div class="draft-slot" id="ds2">?</div>
  </div>
  <button class="btn" id="draft-begin-btn" style="display:none" onclick="beginRun()">BEGIN RUN</button>
  <button class="btn-sm" onclick="showScreen('title-screen')">BACK</button>
</div>

<!-- Battle Screen -->
<div class="screen" id="battle-screen">
  <div class="battle-top-bar">
    <span class="floor-label" id="floor-label">FLOOR 1/8</span>
    <div class="enemy-pips" id="enemy-pips"></div>
  </div>
  <div class="battle-area">
    <div class="battle-scene" id="battle-scene">
      <div class="ground"></div>
      <div class="grass-tuft" style="left:8%"></div>
      <div class="grass-tuft" style="left:25%"></div>
      <div class="grass-tuft" style="left:50%"></div>
      <div class="grass-tuft" style="left:72%"></div>
      <div class="grass-tuft" style="left:92%"></div>
      <!-- Enemy side -->
      <div class="sprite-wrapper" id="enemy-wrapper">
        <div class="sprite-hud">
          <div class="sh-header">
            <span class="sh-name" id="ep-name"></span>
            <span class="sh-enemy-stats" id="ep-stats"></span>
            <span class="sh-element" id="ep-element"></span>
          </div>
          <div class="hp-bar-container">
            <div class="hp-bar" id="ep-hp-bar" style="width:100%"></div>
            <div class="hp-text" id="ep-hp-text"></div>
          </div>
          <div class="status-icons" id="ep-statuses"></div>
        </div>
        <div class="sprite-container enemy-sprite" id="enemy-sprite"></div>
      </div>
      <!-- Player side -->
      <div class="sprite-wrapper" id="player-wrapper">
        <div class="sprite-hud">
          <div class="sh-header">
            <span class="sh-name" id="pp-name"></span>
            <span class="sh-element" id="pp-element"></span>
          </div>
          <div class="hp-bar-container">
            <div class="hp-bar" id="pp-hp-bar" style="width:100%"></div>
            <div class="hp-text" id="pp-hp-text"></div>
          </div>
          <div class="status-icons" id="pp-statuses"></div>
        </div>
        <div class="sprite-container player-sprite" id="player-sprite"></div>
      </div>
      <div class="trainer-battle" id="trainer-battle"></div>
      <div class="trainer-name-tag" id="trainer-name-tag"></div>
      <div class="team-bar" id="team-bar"></div>
    </div>
    <div class="battle-log" id="battle-log"></div>
  </div>
  <div class="action-panel" id="action-panel">
    <div class="move-grid" id="move-grid"></div>
    <button class="switch-btn" id="switch-btn" onclick="toggleSwitchPanel()">SWITCH MONSTER</button>
    <div class="switch-panel" id="switch-panel"></div>
  </div>
  <div class="battle-msg" id="battle-msg"></div>
</div>

<!-- Reward Screen -->
<div class="screen" id="reward-screen">
  <div class="reward-title" id="reward-title">FLOOR COMPLETE!</div>
  <div class="reward-sub">Choose your reward:</div>
  <div class="reward-cards" id="reward-cards"></div>
</div>

<!-- Move Tutor Screen -->
<div class="screen" id="tutor-screen">
  <div class="tutor-title">MOVE TUTOR</div>
  <div class="tutor-sub" id="tutor-sub">Pick a monster:</div>
  <div class="tutor-monsters" id="tutor-monsters"></div>
  <div class="tutor-sub" id="tutor-replace-label" style="display:none">Replace which move?</div>
  <div class="tutor-moves" id="tutor-moves"></div>
  <div class="tutor-new-move" id="tutor-new-move" style="display:none"></div>
  <button class="btn-sm" id="tutor-confirm" style="display:none" onclick="confirmTutor()">CONFIRM</button>
  <button class="btn-sm" onclick="cancelTutor()">CANCEL</button>
</div>

<!-- Defeat Screen -->
<div class="screen" id="defeat-screen">
  <div class="result-title lose">DEFEATED</div>
  <div style="color:#888;font-size:0.85rem" id="defeat-floor-text"></div>
  <div class="result-stats" id="defeat-stats"></div>
  <button class="btn" onclick="startDraft()">TRY AGAIN</button>
  <a href="../index.html" class="exit-btn">EXIT TO LAUNCHER</a>
</div>

<!-- Victory Screen -->
<div class="screen" id="victory-screen">
  <div class="result-title win">VICTORY!</div>
  <div style="color:#888;font-size:0.85rem">You defeated the Chimera Rex!</div>
  <div class="result-stats" id="victory-stats"></div>
  <button class="btn" onclick="startDraft()">PLAY AGAIN</button>
  <a href="../index.html" class="exit-btn">EXIT TO LAUNCHER</a>
</div>

<!-- Toast -->
<div class="gg-toast" id="gg-toast">
  <div class="gg-toast-icon">&#127942;</div>
  <div style="display:flex;flex-direction:column">
    <div class="gg-toast-title">Achievement Unlocked!</div>
    <div class="gg-toast-name" id="gg-toast-name"></div>
  </div>
  <div class="gg-toast-reward" id="gg-toast-reward"></div>
</div>

<!-- Tutorial overlay -->
<div class="tutorial-backdrop" id="tutorial-backdrop"></div>
<div class="tutorial-tooltip" id="tutorial-tooltip">
  <div class="tt-title" id="tt-title"></div>
  <div class="tt-text" id="tt-text"></div>
  <div class="tt-buttons">
    <button class="tt-btn" id="tt-btn" onclick="dismissTutorialStep()">GOT IT</button>
    <button class="tt-skip" id="tt-skip" onclick="skipTutorial()">Skip Tutorial</button>
  </div>
</div>

<script>
// ═══════════════════════════════════════════
// G BUX SYSTEM
// ═══════════════════════════════════════════
const GG_KEY = 'graham-games-data';
function ggLoad() {
  try { return JSON.parse(localStorage.getItem(GG_KEY)) || { gBux: 0, achievements: {}, shopPurchases: {} }; }
  catch(e) { return { gBux: 0, achievements: {}, shopPurchases: {} }; }
}
function ggSave(data) { localStorage.setItem(GG_KEY, JSON.stringify(data)); }
function ggUnlockAchievement(id, name, reward) {
  const data = ggLoad();
  if (data.achievements[id]) return false;
  data.achievements[id] = true;
  data.gBux += reward;
  ggSave(data);
  showAchievementToast(name, reward);
  return true;
}

let ggToastQueue = [], ggToastShowing = false;
function showAchievementToast(name, reward) {
  ggToastQueue.push({ name, reward });
  if (!ggToastShowing) processToastQueue();
}
function processToastQueue() {
  if (!ggToastQueue.length) { ggToastShowing = false; return; }
  ggToastShowing = true;
  const { name, reward } = ggToastQueue.shift();
  document.getElementById('gg-toast-name').textContent = name;
  document.getElementById('gg-toast-reward').textContent = '+' + reward + ' G Bux';
  document.getElementById('gg-toast').classList.add('visible');
  setTimeout(() => {
    document.getElementById('gg-toast').classList.remove('visible');
    setTimeout(processToastQueue, 400);
  }, 3000);
}

const BM_ACH = {
  bm_first_fight:   { name: 'Monster Tamer',     reward: 5 },
  bm_floor_4:       { name: 'Rising Challenger',  reward: 10 },
  bm_floor_8:       { name: 'Champion',           reward: 50 },
  bm_sweep:         { name: 'Clean Sweep',        reward: 25 },
  bm_super_eff_5:   { name: 'Type Master',        reward: 15 },
  bm_full_team_win: { name: 'Untouchable',        reward: 30 },
  bm_all_elements:  { name: 'Elemental Scholar',  reward: 20 },
  bm_3_wins:        { name: 'Veteran Trainer',     reward: 15 },
  bm_10_wins:       { name: 'Monster Master',     reward: 25 },
  bm_no_heal:       { name: 'No Mercy',           reward: 20 },
  bm_collect_all:   { name: 'Gotta Catch Em All', reward: 30 },
};
function ggTry(id) { const a = BM_ACH[id]; if (a) ggUnlockAchievement(id, a.name, a.reward); }

// ═══════════════════════════════════════════
// STATS PERSISTENCE
// ═══════════════════════════════════════════
const BM_STATS_KEY = 'bm-stats';
function defaultStats() {
  return { totalRuns: 0, wins: 0, bestFloor: 0, totalBattlesWon: 0, totalEnemiesDefeated: 0, elementsUsed: [] };
}
function loadStats() {
  try { return JSON.parse(localStorage.getItem(BM_STATS_KEY)) || defaultStats(); }
  catch(e) { return defaultStats(); }
}
function saveStats(s) { localStorage.setItem(BM_STATS_KEY, JSON.stringify(s)); }

// ═══════════════════════════════════════════
// MONSTER COLLECTION
// ═══════════════════════════════════════════
const BM_COLLECTION_KEY = 'bm-collection';
function loadCollection() {
  try { return JSON.parse(localStorage.getItem(BM_COLLECTION_KEY)) || []; }
  catch(e) { return []; }
}
function saveCollection(c) { localStorage.setItem(BM_COLLECTION_KEY, JSON.stringify(c)); }
function addToCollection(monsterKey) {
  const c = loadCollection();
  if (c.includes(monsterKey)) return false;
  c.push(monsterKey);
  saveCollection(c);
  return true;
}

// ═══════════════════════════════════════════
// SOUND EFFECTS
// ═══════════════════════════════════════════
let audioCtx;
function getAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); return audioCtx; }

const SFX = {
  hit() {
    const ctx = getAudio(), t = ctx.currentTime;
    const buf = ctx.createBuffer(1, ctx.sampleRate * 0.08, ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / d.length);
    const s = ctx.createBufferSource(), g = ctx.createGain();
    s.buffer = buf; g.gain.setValueAtTime(0.15, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
    s.connect(g); g.connect(ctx.destination); s.start(t);
  },
  superHit() {
    const ctx = getAudio(), t = ctx.currentTime;
    const o = ctx.createOscillator(), g = ctx.createGain();
    o.type = 'sawtooth'; o.frequency.setValueAtTime(300, t); o.frequency.exponentialRampToValueAtTime(800, t + 0.15);
    g.gain.setValueAtTime(0.12, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    o.connect(g); g.connect(ctx.destination); o.start(t); o.stop(t + 0.2);
  },
  miss() {
    const ctx = getAudio(), t = ctx.currentTime;
    const o = ctx.createOscillator(), g = ctx.createGain();
    o.type = 'sine'; o.frequency.setValueAtTime(400, t); o.frequency.exponentialRampToValueAtTime(150, t + 0.15);
    g.gain.setValueAtTime(0.06, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
    o.connect(g); g.connect(ctx.destination); o.start(t); o.stop(t + 0.15);
  },
  heal() {
    const ctx = getAudio(), t = ctx.currentTime;
    [400, 600, 800].forEach((f, i) => {
      const o = ctx.createOscillator(), g = ctx.createGain();
      o.type = 'sine'; o.frequency.value = f;
      g.gain.setValueAtTime(0.08, t + i * 0.1); g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.1 + 0.15);
      o.connect(g); g.connect(ctx.destination); o.start(t + i * 0.1); o.stop(t + i * 0.1 + 0.15);
    });
  },
  faint() {
    const ctx = getAudio(), t = ctx.currentTime;
    const o = ctx.createOscillator(), g = ctx.createGain();
    o.type = 'square'; o.frequency.setValueAtTime(300, t); o.frequency.exponentialRampToValueAtTime(80, t + 0.4);
    g.gain.setValueAtTime(0.08, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.4);
    o.connect(g); g.connect(ctx.destination); o.start(t); o.stop(t + 0.4);
  },
  select() {
    const ctx = getAudio(), t = ctx.currentTime;
    const o = ctx.createOscillator(), g = ctx.createGain();
    o.type = 'sine'; o.frequency.value = 800;
    g.gain.setValueAtTime(0.06, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
    o.connect(g); g.connect(ctx.destination); o.start(t); o.stop(t + 0.05);
  },
  victory() {
    const ctx = getAudio(), t = ctx.currentTime;
    [523, 659, 784, 1047].forEach((f, i) => {
      const o = ctx.createOscillator(), g = ctx.createGain();
      o.type = 'sine'; o.frequency.value = f;
      g.gain.setValueAtTime(0.1, t + i * 0.15); g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.15 + 0.3);
      o.connect(g); g.connect(ctx.destination); o.start(t + i * 0.15); o.stop(t + i * 0.15 + 0.3);
    });
  },
  defeat() {
    const ctx = getAudio(), t = ctx.currentTime;
    [400, 350, 300, 200].forEach((f, i) => {
      const o = ctx.createOscillator(), g = ctx.createGain();
      o.type = 'sine'; o.frequency.value = f;
      g.gain.setValueAtTime(0.08, t + i * 0.2); g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.2 + 0.3);
      o.connect(g); g.connect(ctx.destination); o.start(t + i * 0.2); o.stop(t + i * 0.2 + 0.3);
    });
  },
  buff() {
    const ctx = getAudio(), t = ctx.currentTime;
    const o = ctx.createOscillator(), g = ctx.createGain();
    o.type = 'triangle'; o.frequency.setValueAtTime(500, t); o.frequency.exponentialRampToValueAtTime(1200, t + 0.2);
    g.gain.setValueAtTime(0.08, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    o.connect(g); g.connect(ctx.destination); o.start(t); o.stop(t + 0.2);
  },
  status() {
    const ctx = getAudio(), t = ctx.currentTime;
    const o = ctx.createOscillator(), g = ctx.createGain();
    o.type = 'sawtooth'; o.frequency.setValueAtTime(200, t); o.frequency.exponentialRampToValueAtTime(100, t + 0.2);
    g.gain.setValueAtTime(0.06, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    o.connect(g); g.connect(ctx.destination); o.start(t); o.stop(t + 0.2);
  },
};

// ═══════════════════════════════════════════
// TUTORIAL SYSTEM
// ═══════════════════════════════════════════
const TUTORIAL_KEY = 'bm-tutorial-done';
let tutorialActive = false;
let tutorialStep = -1;
let tutorialShownSteps = new Set();

const TUTORIAL_STEPS = [
  {
    id: 'draft-intro', trigger: 'draft', anchor: '#draft-cards', position: 'below', arrowDir: 'up',
    title: 'Build Your Team',
    text: 'Tap 3 monsters to draft your squad. Check their elements, stats, and moves!'
  },
  {
    id: 'draft-elements', trigger: 'draft-select-1', anchor: '.draft-card.selected', position: 'below', arrowDir: 'up',
    title: 'Elements Matter',
    text: 'Fire beats Plant, Plant beats Water, Water beats Fire. Electric beats Water. Shadow and Light counter each other.'
  },
  {
    id: 'battle-intro', trigger: 'battle-start', anchor: '#battle-scene', position: 'below', arrowDir: 'up',
    title: 'Battle!',
    text: 'Your monster is on the right, the enemy on the left. Defeat all enemies to advance!'
  },
  {
    id: 'battle-moves', trigger: 'battle-start-delayed', anchor: '#move-grid', position: 'above', arrowDir: 'down',
    title: 'Choose a Move',
    text: 'Pick one of your 4 moves each turn. Each has power, accuracy, and an element type.'
  },
  {
    id: 'battle-effectiveness', trigger: 'battle-moves-dismissed', anchor: '#move-grid', position: 'above', arrowDir: 'down',
    title: 'Type Advantage',
    text: 'Look for SE! (super effective — 1.5x damage) and NVE (not very effective) badges on your moves!'
  },
  {
    id: 'battle-switch', trigger: 'effectiveness-dismissed', anchor: '#switch-btn', position: 'above', arrowDir: 'down',
    title: 'Switch Monsters',
    text: 'Swap to another monster when the enemy has a type advantage against yours!'
  },
  {
    id: 'reward-intro', trigger: 'reward', anchor: '#reward-cards', position: 'below', arrowDir: 'up',
    title: 'Pick a Reward',
    text: 'After each floor, choose a reward — heals, stat boosts, or new moves to power up your team!'
  },
];

function isTutorialDone() {
  return localStorage.getItem(TUTORIAL_KEY) === '1';
}

function markTutorialDone() {
  localStorage.setItem(TUTORIAL_KEY, '1');
  tutorialActive = false;
  tutorialStep = -1;
  hideTutorialTooltip();
}

function initTutorial() {
  if (isTutorialDone()) return;
  tutorialActive = true;
  tutorialStep = -1;
  tutorialShownSteps.clear();
}

function tryTutorialStep(trigger) {
  if (!tutorialActive) return;
  for (let i = 0; i < TUTORIAL_STEPS.length; i++) {
    const step = TUTORIAL_STEPS[i];
    if (step.trigger === trigger && !tutorialShownSteps.has(step.id)) {
      tutorialStep = i;
      tutorialShownSteps.add(step.id);
      showTutorialTooltip(step);
      return;
    }
  }
}

function showTutorialTooltip(step) {
  const backdrop = document.getElementById('tutorial-backdrop');
  const tooltip = document.getElementById('tutorial-tooltip');

  document.querySelectorAll('.tutorial-highlight').forEach(el => el.classList.remove('tutorial-highlight'));

  const anchor = document.querySelector(step.anchor);
  if (anchor) anchor.classList.add('tutorial-highlight');

  document.getElementById('tt-title').textContent = step.title;
  document.getElementById('tt-text').textContent = step.text;

  tooltip.className = 'tutorial-tooltip visible';
  if (step.arrowDir === 'up') tooltip.classList.add('arrow-up');
  if (step.arrowDir === 'down') tooltip.classList.add('arrow-down');

  backdrop.classList.add('visible');

  requestAnimationFrame(() => {
    positionTooltip(tooltip, anchor, step.position);
  });
}

function positionTooltip(tooltip, anchor, position) {
  if (!anchor) {
    tooltip.style.left = '50%';
    tooltip.style.top = '50%';
    tooltip.style.transform = 'translate(-50%, -50%)';
    return;
  }
  const rect = anchor.getBoundingClientRect();
  const ttRect = tooltip.getBoundingClientRect();
  const margin = 12;
  let left = rect.left + rect.width / 2 - ttRect.width / 2;
  let top;
  if (position === 'below') {
    top = rect.bottom + margin;
  } else {
    top = rect.top - ttRect.height - margin;
  }
  left = Math.max(8, Math.min(left, window.innerWidth - ttRect.width - 8));
  top = Math.max(8, Math.min(top, window.innerHeight - ttRect.height - 8));
  tooltip.style.left = left + 'px';
  tooltip.style.top = top + 'px';
  tooltip.style.transform = 'none';
}

function hideTutorialTooltip() {
  document.getElementById('tutorial-backdrop').classList.remove('visible');
  const tt = document.getElementById('tutorial-tooltip');
  tt.classList.remove('visible');
  tt.style.left = '';
  tt.style.top = '';
  tt.style.transform = '';
  document.querySelectorAll('.tutorial-highlight').forEach(el => el.classList.remove('tutorial-highlight'));
}

function dismissTutorialStep() {
  const step = TUTORIAL_STEPS[tutorialStep];
  hideTutorialTooltip();
  if (!step) return;

  // Chain battle steps automatically
  if (step.id === 'battle-intro') {
    setTimeout(() => tryTutorialStep('battle-start-delayed'), 600);
  } else if (step.id === 'battle-moves') {
    setTimeout(() => tryTutorialStep('battle-moves-dismissed'), 300);
  } else if (step.id === 'battle-effectiveness') {
    setTimeout(() => tryTutorialStep('effectiveness-dismissed'), 300);
  }

  // Mark done after final step
  if (tutorialShownSteps.size >= TUTORIAL_STEPS.length) {
    markTutorialDone();
  }
}

function skipTutorial() {
  markTutorialDone();
}

// ═══════════════════════════════════════════
// TRAINER SYSTEM
// ═══════════════════════════════════════════
const TRAINER_KEY = 'bm-trainer';
const SKIN_TONES = ['#ffe0bd','#f1c27d','#c68642','#8d5524','#5c3310'];
const HAIR_COLORS = ['#1a1a1a','#6b4226','#d4a543','#cc3333','#3366cc','#8833aa'];
const HAIR_STYLES = ['short','spiky','long','ponytail'];
const SHIRT_COLORS = ['#cc3333','#3366cc','#33aa33','#ddcc22','#8833aa','#eeeedd'];
const ACCESSORIES = ['none','cap','glasses','headband'];

function getHairSwatchSVG(index, color) {
  const c = color || '#888';
  const svgs = [
    // short: close-cropped sides
    `<svg viewBox="0 0 24 24" width="20" height="20"><circle cx="12" cy="13" r="7" fill="#555"/><path d="M5,13 Q5,6 12,5 Q19,6 19,13" fill="none" stroke="${c}" stroke-width="2.5"/><rect x="4" y="11" width="2.5" height="4" rx="1" fill="${c}"/><rect x="17.5" y="11" width="2.5" height="4" rx="1" fill="${c}"/></svg>`,
    // spiky: pointed spikes
    `<svg viewBox="0 0 24 24" width="20" height="20"><circle cx="12" cy="13" r="7" fill="#555"/><polygon points="5,13 7,3 9,11 12,1 15,11 17,3 19,13" fill="${c}"/></svg>`,
    // long: flowing down sides
    `<svg viewBox="0 0 24 24" width="20" height="20"><circle cx="12" cy="13" r="7" fill="#555"/><ellipse cx="12" cy="8" rx="8" ry="5" fill="${c}"/><rect x="3" y="8" width="3.5" height="12" rx="1.5" fill="${c}"/><rect x="17.5" y="8" width="3.5" height="12" rx="1.5" fill="${c}"/></svg>`,
    // ponytail: bun on side
    `<svg viewBox="0 0 24 24" width="20" height="20"><circle cx="12" cy="13" r="7" fill="#555"/><ellipse cx="12" cy="8" rx="8" ry="5" fill="${c}"/><rect x="17" y="6" width="3" height="10" rx="1.5" fill="${c}" transform="rotate(15,18,6)"/></svg>`,
  ];
  return svgs[index] || svgs[0];
}

function getAccessorySwatchSVG(index) {
  const svgs = [
    // none
    `<svg viewBox="0 0 24 24" width="20" height="20"><line x1="6" y1="6" x2="18" y2="18" stroke="#555" stroke-width="2"/><line x1="18" y1="6" x2="6" y2="18" stroke="#555" stroke-width="2"/></svg>`,
    // cap
    `<svg viewBox="0 0 24 24" width="20" height="20"><path d="M5,14 Q5,4 12,3 Q19,4 19,14" fill="#444"/><rect x="5" y="12" width="14" height="3" rx="1" fill="#444"/><rect x="2" y="14" width="10" height="2.5" rx="1" fill="#555"/></svg>`,
    // glasses
    `<svg viewBox="0 0 24 24" width="20" height="20"><circle cx="8" cy="12" r="4" fill="none" stroke="#777" stroke-width="1.5"/><circle cx="16" cy="12" r="4" fill="none" stroke="#777" stroke-width="1.5"/><line x1="12" y1="12" x2="12" y2="12" stroke="#777" stroke-width="2"/><rect x="11" y="11" width="2" height="2" rx="0.5" fill="#777"/></svg>`,
    // headband
    `<svg viewBox="0 0 24 24" width="20" height="20"><circle cx="12" cy="13" r="7" fill="#555"/><rect x="4" y="9" width="16" height="3" rx="1" fill="#e040fb"/></svg>`,
  ];
  return svgs[index] || svgs[0];
}

const BAD_WORDS = ['shit','fuck','ass','damn','hell','bitch','dick','cock','cunt','piss',
  'bastard','slut','whore','nigger','faggot','retard','nazi','porn','sex','penis','vagina',
  'tits','boob','anus','wank','twat','bollock','bugger','crap','prick'];

function isNameClean(name) {
  const lower = name.toLowerCase().replace(/[^a-z]/g, '');
  if (lower.length === 0) return true; // empty is ok (handled separately)
  return !BAD_WORDS.some(w => lower.includes(w));
}

function loadTrainer() {
  try { return JSON.parse(localStorage.getItem(TRAINER_KEY)); }
  catch(e) { return null; }
}

function saveTrainer(data) {
  localStorage.setItem(TRAINER_KEY, JSON.stringify(data));
}

let trainerEditing = { name: '', skin: 0, hairColor: 0, hairStyle: 0, shirtColor: 0, accessory: 0 };

function showTrainerScreen() {
  const existing = loadTrainer();
  if (existing) {
    trainerEditing = { ...existing };
  } else {
    trainerEditing = { name: '', skin: 0, hairColor: 0, hairStyle: 0, shirtColor: 0, accessory: 0 };
  }
  document.getElementById('trainer-name').value = trainerEditing.name;
  document.getElementById('trainer-name-warn').textContent = '';
  renderTrainerSwatches();
  updateTrainerPreview();
  showScreen('trainer-screen');
}

function renderTrainerSwatches() {
  renderSwatchRow('sw-skin', SKIN_TONES, 'skin', (c) => `background:${c}`);
  renderSwatchRow('sw-hairColor', HAIR_COLORS, 'hairColor', (c) => `background:${c}`);
  renderSwatchRowSVG('sw-hairStyle', HAIR_STYLES.length, 'hairStyle', (i) => getHairSwatchSVG(i, HAIR_COLORS[trainerEditing.hairColor]));
  renderSwatchRow('sw-shirtColor', SHIRT_COLORS, 'shirtColor', (c) => `background:${c}`);
  renderSwatchRowSVG('sw-accessory', ACCESSORIES.length, 'accessory', (i) => getAccessorySwatchSVG(i));
}

function renderSwatchRow(containerId, items, field, styleFn) {
  const el = document.getElementById(containerId);
  el.innerHTML = '';
  for (let i = 0; i < items.length; i++) {
    const sw = document.createElement('div');
    sw.className = 'trainer-swatch' + (trainerEditing[field] === i ? ' selected' : '');
    const style = styleFn(items[i]);
    if (style) sw.setAttribute('style', style);
    sw.onclick = () => {
      trainerEditing[field] = i;
      renderTrainerSwatches();
      updateTrainerPreview();
    };
    el.appendChild(sw);
  }
}

function renderSwatchRowSVG(containerId, count, field, svgFn) {
  const el = document.getElementById(containerId);
  el.innerHTML = '';
  for (let i = 0; i < count; i++) {
    const sw = document.createElement('div');
    sw.className = 'trainer-swatch' + (trainerEditing[field] === i ? ' selected' : '');
    sw.innerHTML = svgFn(i);
    sw.onclick = () => {
      trainerEditing[field] = i;
      renderTrainerSwatches();
      updateTrainerPreview();
    };
    el.appendChild(sw);
  }
}

function updateTrainerPreview() {
  document.getElementById('trainer-preview').innerHTML = getTrainerSVG(trainerEditing);
}

function onTrainerNameInput() {
  const name = document.getElementById('trainer-name').value.trim();
  trainerEditing.name = name;
  const warn = document.getElementById('trainer-name-warn');
  if (name.length > 0 && !isNameClean(name)) {
    warn.textContent = 'Please choose a different name';
  } else {
    warn.textContent = '';
  }
}

function saveTrainerAndContinue() {
  const name = document.getElementById('trainer-name').value.trim();
  if (!name) {
    document.getElementById('trainer-name-warn').textContent = 'Enter a name first!';
    return;
  }
  if (!isNameClean(name)) {
    document.getElementById('trainer-name-warn').textContent = 'Please choose a different name';
    return;
  }
  trainerEditing.name = name;
  saveTrainer(trainerEditing);
  startDraft();
}

function getTrainerSVG(data) {
  const skin = SKIN_TONES[data.skin] || SKIN_TONES[0];
  const hair = HAIR_COLORS[data.hairColor] || HAIR_COLORS[0];
  const shirt = SHIRT_COLORS[data.shirtColor] || SHIRT_COLORS[0];
  const style = HAIR_STYLES[data.hairStyle] || 'short';
  const acc = ACCESSORIES[data.accessory] || 'none';

  let hairPath = '';
  if (style === 'short') {
    // Close-cropped sides — hair hugs the head, not piled on top
    hairPath = `<path d="M11,16 Q11,8 20,7 Q29,8 29,16" fill="none" stroke="${hair}" stroke-width="3"/><rect x="10" y="14" width="3" height="5" rx="1" fill="${hair}"/><rect x="27" y="14" width="3" height="5" rx="1" fill="${hair}"/>`;
  } else if (style === 'spiky') {
    hairPath = `<polygon points="10,14 13,2 16,12 20,0 24,12 27,2 30,14" fill="${hair}"/>`;
  } else if (style === 'long') {
    hairPath = `<ellipse cx="20" cy="10" rx="11" ry="7" fill="${hair}"/><rect x="9" y="10" width="4" height="16" rx="2" fill="${hair}"/><rect x="27" y="10" width="4" height="16" rx="2" fill="${hair}"/>`;
  } else if (style === 'ponytail') {
    hairPath = `<ellipse cx="20" cy="10" rx="10" ry="6" fill="${hair}"/><rect x="26" y="8" width="4" height="14" rx="2" fill="${hair}" transform="rotate(20,28,8)"/>`;
  }

  let accPath = '';
  if (acc === 'cap') {
    accPath = `<path d="M10,11 Q10,2 20,1 Q30,2 30,11" fill="#444"/><rect x="10" y="9" width="20" height="4" rx="1" fill="#444"/><rect x="6" y="11" width="14" height="3" rx="1" fill="#555"/>`;
  } else if (acc === 'glasses') {
    accPath = `<circle cx="16" cy="17" r="3" fill="none" stroke="#555" stroke-width="1.2"/><circle cx="24" cy="17" r="3" fill="none" stroke="#555" stroke-width="1.2"/><line x1="19" y1="17" x2="21" y2="17" stroke="#555" stroke-width="1"/>`;
  } else if (acc === 'headband') {
    accPath = `<rect x="9" y="11" width="22" height="3" rx="1" fill="#e040fb"/>`;
  }

  return `<svg width="60" height="70" viewBox="0 0 40 60">
    <!-- Hair behind -->
    ${hairPath}
    <!-- Head -->
    <circle cx="20" cy="16" r="9" fill="${skin}"/>
    <!-- Eyes -->
    <circle cx="16" cy="15" r="1.5" fill="#222"/>
    <circle cx="24" cy="15" r="1.5" fill="#222"/>
    <!-- Mouth -->
    <path d="M17,20 Q20,23 23,20" stroke="#222" fill="none" stroke-width="0.8"/>
    <!-- Accessory -->
    ${accPath}
    <!-- Body -->
    <rect x="12" y="25" width="16" height="18" rx="3" fill="${shirt}"/>
    <!-- Arms -->
    <rect x="6" y="27" width="6" height="12" rx="3" fill="${skin}"/>
    <rect x="28" y="27" width="6" height="12" rx="3" fill="${skin}"/>
    <!-- Legs -->
    <rect x="13" y="42" width="6" height="14" rx="2" fill="#334"/>
    <rect x="21" y="42" width="6" height="14" rx="2" fill="#334"/>
    <!-- Shoes -->
    <rect x="12" y="54" width="8" height="4" rx="2" fill="#222"/>
    <rect x="20" y="54" width="8" height="4" rx="2" fill="#222"/>
  </svg>`;
}

// ═══════════════════════════════════════════
// CONSTANTS
// ═══════════════════════════════════════════
const ELEMENT_COLORS = {
  Fire: '#ff6b35', Water: '#3399ff', Plant: '#44bb44',
  Electric: '#ffcc00', Shadow: '#9966cc', Light: '#ffee88',
  Normal: '#aaaaaa',
};

const TYPE_CHART = {
  Fire:     { Plant: 1.5, Water: 0.67, Fire: 0.67 },
  Water:    { Fire: 1.5, Plant: 0.67, Water: 0.67 },
  Plant:    { Water: 1.5, Fire: 0.67, Electric: 1.5, Plant: 0.67 },
  Electric: { Water: 1.5, Plant: 0.67, Electric: 0.67 },
  Shadow:   { Light: 1.5, Shadow: 0.67 },
  Light:    { Shadow: 1.5, Light: 0.67 },
  Normal:   {},
};

function getEffectiveness(atkElement, defElement) {
  return (TYPE_CHART[atkElement] && TYPE_CHART[atkElement][defElement]) || 1.0;
}

const MONSTER_DEFS = {
  emberon: {
    name: 'Emberon', element: 'Fire', icon: '\uD83D\uDD25', hp: 110, atk: 75, def: 55, spd: 65,
    moves: [
      { name: 'Flame Burst', element: 'Fire', power: 70, accuracy: 95, effect: null },
      { name: 'Inferno Charge', element: 'Fire', power: 95, accuracy: 80, effect: { type: 'buffSelf', stat: 'atk', amount: 20, turns: 2 } },
      { name: 'Smoke Screen', element: 'Fire', power: 0, accuracy: 100, effect: { type: 'debuff', stat: 'accuracy', amount: 25, turns: 2 } },
      { name: 'Tackle', element: 'Normal', power: 50, accuracy: 100, effect: null },
    ]
  },
  tidalin: {
    name: 'Tidalin', element: 'Water', icon: '\uD83C\uDF0A', hp: 120, atk: 60, def: 70, spd: 55,
    moves: [
      { name: 'Hydro Blast', element: 'Water', power: 70, accuracy: 95, effect: null },
      { name: 'Tidal Wave', element: 'Water', power: 90, accuracy: 80, effect: { type: 'debuff', stat: 'spd', amount: 25, turns: 2, chance: 30 } },
      { name: 'Shell Guard', element: 'Water', power: 0, accuracy: 100, effect: { type: 'buffSelf', stat: 'def', amount: 40, turns: 2 } },
      { name: 'Headbutt', element: 'Normal', power: 55, accuracy: 95, effect: { type: 'stun', chance: 10 } },
    ]
  },
  thornvine: {
    name: 'Thornvine', element: 'Plant', icon: '\uD83C\uDF3F', hp: 130, atk: 55, def: 65, spd: 50,
    moves: [
      { name: 'Vine Whip', element: 'Plant', power: 65, accuracy: 100, effect: null },
      { name: 'Spore Cloud', element: 'Plant', power: 0, accuracy: 90, effect: { type: 'debuff', stat: 'atk', amount: 25, turns: 3 } },
      { name: 'Thorn Barrage', element: 'Plant', power: 80, accuracy: 85, effect: null },
      { name: 'Root Drain', element: 'Plant', power: 55, accuracy: 95, effect: { type: 'drain', percent: 50 } },
    ]
  },
  voltpaw: {
    name: 'Voltpaw', element: 'Electric', icon: '\u26A1', hp: 90, atk: 80, def: 45, spd: 85,
    moves: [
      { name: 'Spark Bolt', element: 'Electric', power: 65, accuracy: 100, effect: null },
      { name: 'Thunder Strike', element: 'Electric', power: 95, accuracy: 75, effect: { type: 'stun', chance: 30 } },
      { name: 'Quick Charge', element: 'Electric', power: 0, accuracy: 100, effect: { type: 'buffSelf', stat: 'spd', amount: 30, turns: 3 } },
      { name: 'Pounce', element: 'Normal', power: 55, accuracy: 95, effect: { type: 'priority' } },
    ]
  },
  grimshade: {
    name: 'Grimshade', element: 'Shadow', icon: '\uD83D\uDC7B', hp: 95, atk: 85, def: 50, spd: 70,
    moves: [
      { name: 'Shadow Claw', element: 'Shadow', power: 70, accuracy: 95, effect: { type: 'debuff', stat: 'def', amount: 20, turns: 2, chance: 15 } },
      { name: 'Nightmare', element: 'Shadow', power: 85, accuracy: 85, effect: { type: 'stun', chance: 25 } },
      { name: 'Life Steal', element: 'Shadow', power: 60, accuracy: 100, effect: { type: 'drain', percent: 40 } },
      { name: 'Hex', element: 'Shadow', power: 0, accuracy: 90, effect: { type: 'debuff', stat: 'atk', amount: 30, turns: 3 } },
    ]
  },
  solarius: {
    name: 'Solarius', element: 'Light', icon: '\u2600\uFE0F', hp: 105, atk: 70, def: 60, spd: 60,
    moves: [
      { name: 'Radiant Beam', element: 'Light', power: 75, accuracy: 95, effect: null },
      { name: 'Holy Flash', element: 'Light', power: 90, accuracy: 80, effect: { type: 'stun', chance: 20 } },
      { name: 'Healing Light', element: 'Light', power: 0, accuracy: 100, effect: { type: 'healSelf', percent: 35 } },
      { name: 'Dazzle', element: 'Light', power: 60, accuracy: 100, effect: { type: 'debuff', stat: 'accuracy', amount: 20, turns: 2 } },
    ]
  },
  drakovex: {
    name: 'Drakovex', element: 'Shadow', icon: '\uD83D\uDC32', hp: 100, atk: 90, def: 45, spd: 75,
    moves: [
      { name: 'Dark Flame', element: 'Shadow', power: 80, accuracy: 90, effect: { type: 'debuff', stat: 'def', amount: 20, turns: 2, chance: 20 } },
      { name: 'Dragon Fang', element: 'Fire', power: 85, accuracy: 90, effect: { type: 'stun', chance: 15 } },
      { name: 'Shadow Veil', element: 'Shadow', power: 0, accuracy: 100, effect: { type: 'buffSelf', stat: 'spd', amount: 30, turns: 2 } },
      { name: 'Inferno Rush', element: 'Fire', power: 95, accuracy: 75, effect: null },
    ]
  },
  blazetail: {
    name: 'Blazetail', element: 'Fire', icon: '\uD83E\uDD8A', hp: 100, atk: 80, def: 50, spd: 70,
    moves: [
      { name: 'Fire Fang', element: 'Fire', power: 65, accuracy: 95, effect: null },
      { name: 'Wildfire', element: 'Fire', power: 85, accuracy: 85, effect: { type: 'debuff', stat: 'def', amount: 20, turns: 2, chance: 25 } },
      { name: 'Agility', element: 'Normal', power: 0, accuracy: 100, effect: { type: 'buffSelf', stat: 'spd', amount: 50, turns: 2 } },
      { name: 'Bite', element: 'Normal', power: 60, accuracy: 100, effect: { type: 'stun', chance: 10 } },
    ]
  },
  aquarion: {
    name: 'Aquarion', element: 'Water', icon: '\uD83D\uDC22', hp: 115, atk: 65, def: 75, spd: 50,
    moves: [
      { name: 'Aqua Jet', element: 'Water', power: 60, accuracy: 100, effect: { type: 'priority' } },
      { name: 'Torrent', element: 'Water', power: 85, accuracy: 85, effect: { type: 'debuff', stat: 'atk', amount: 20, turns: 2, chance: 30 } },
      { name: 'Iron Shell', element: 'Normal', power: 0, accuracy: 100, effect: { type: 'buffSelf', stat: 'def', amount: 50, turns: 2 } },
      { name: 'Ram', element: 'Normal', power: 65, accuracy: 95, effect: null },
    ]
  },
  petalynx: {
    name: 'Petalynx', element: 'Plant', icon: '\uD83C\uDF38', hp: 95, atk: 70, def: 55, spd: 80,
    moves: [
      { name: 'Leaf Slash', element: 'Plant', power: 65, accuracy: 95, effect: null },
      { name: 'Bloom Burst', element: 'Plant', power: 85, accuracy: 85, effect: { type: 'drain', percent: 30 } },
      { name: 'Petal Dance', element: 'Normal', power: 0, accuracy: 100, effect: { type: 'buffSelf', stat: 'spd', amount: 50, turns: 2 } },
      { name: 'Scratch', element: 'Normal', power: 55, accuracy: 100, effect: { type: 'debuff', stat: 'def', amount: 15, turns: 2, chance: 20 } },
    ]
  },
  zapplin: {
    name: 'Zapplin', element: 'Electric', icon: '\uD83D\uDC7E', hp: 85, atk: 75, def: 40, spd: 90,
    moves: [
      { name: 'Zap', element: 'Electric', power: 60, accuracy: 100, effect: null },
      { name: 'Overcharge', element: 'Electric', power: 90, accuracy: 80, effect: { type: 'stun', chance: 20 } },
      { name: 'Static Field', element: 'Normal', power: 0, accuracy: 100, effect: { type: 'buffSelf', stat: 'atk', amount: 50, turns: 2 } },
      { name: 'Headbutt', element: 'Normal', power: 60, accuracy: 95, effect: { type: 'stun', chance: 10 } },
    ]
  },
  spectrion: {
    name: 'Spectrion', element: 'Shadow', icon: '\uD83D\uDC41\uFE0F', hp: 100, atk: 80, def: 55, spd: 65,
    moves: [
      { name: 'Phantom Strike', element: 'Shadow', power: 70, accuracy: 90, effect: null },
      { name: 'Soul Drain', element: 'Shadow', power: 75, accuracy: 90, effect: { type: 'drain', percent: 40 } },
      { name: 'Shadow Cloak', element: 'Normal', power: 0, accuracy: 100, effect: { type: 'buffSelf', stat: 'def', amount: 50, turns: 2 } },
      { name: 'Glare', element: 'Normal', power: 0, accuracy: 90, effect: { type: 'debuff', stat: 'atk', amount: 25, turns: 2 } },
    ]
  },
  celestine: {
    name: 'Celestine', element: 'Light', icon: '\uD83D\uDC8E', hp: 110, atk: 65, def: 70, spd: 55,
    moves: [
      { name: 'Light Shard', element: 'Light', power: 65, accuracy: 95, effect: null },
      { name: 'Divine Beam', element: 'Light', power: 90, accuracy: 85, effect: { type: 'stun', chance: 15 } },
      { name: 'Barrier', element: 'Normal', power: 0, accuracy: 100, effect: { type: 'buffSelf', stat: 'def', amount: 50, turns: 2 } },
      { name: 'Restore', element: 'Light', power: 0, accuracy: 100, effect: { type: 'healSelf', percent: 25 } },
    ]
  },
};

const BOSS_DEF = {
  name: 'Chimera Rex', element: 'Shadow', icon: '\uD83D\uDC09', hp: 300, atk: 90, def: 70, spd: 60,
  moves: [
    { name: 'Chaos Blast', element: 'Shadow', power: 90, accuracy: 90, effect: { type: 'debuff', stat: 'def', amount: 20, turns: 2, chance: 30 } },
    { name: 'Void Crush', element: 'Shadow', power: 75, accuracy: 95, effect: { type: 'debuff', stat: 'def', amount: 25, turns: 2, chance: 40 } },
    { name: 'Elemental Fury', element: 'Fire', power: 80, accuracy: 85, effect: null },
    { name: 'Dark Regenerate', element: 'Shadow', power: 0, accuracy: 100, effect: { type: 'healSelf', percent: 15 } },
  ],
};

const LEARNABLE_MOVES = [
  { name: 'Power Strike', element: 'Normal', power: 80, accuracy: 90, effect: null },
  { name: 'Vine Lash', element: 'Plant', power: 65, accuracy: 95, effect: { type: 'debuff', stat: 'spd', amount: 20, turns: 2, chance: 30 } },
  { name: 'Frost Bolt', element: 'Water', power: 70, accuracy: 90, effect: { type: 'debuff', stat: 'spd', amount: 20, turns: 2, chance: 30 } },
  { name: 'Lightning Jab', element: 'Electric', power: 60, accuracy: 100, effect: { type: 'stun', chance: 15 } },
  { name: 'Dark Pulse', element: 'Shadow', power: 75, accuracy: 90, effect: { type: 'debuff', stat: 'atk', amount: 20, turns: 2, chance: 25 } },
  { name: 'Sun Flare', element: 'Light', power: 75, accuracy: 90, effect: { type: 'stun', chance: 15 } },
  { name: 'Iron Wall', element: 'Normal', power: 0, accuracy: 100, effect: { type: 'buffSelf', stat: 'def', amount: 50, turns: 2 } },
  { name: 'Berserk', element: 'Normal', power: 0, accuracy: 100, effect: { type: 'buffSelf', stat: 'atk', amount: 50, turns: 2 } },
];

const REWARD_TYPES = [
  { type: 'atkBoost', weight: 25, label: 'ATK Crystal',     desc: 'All monsters gain +10% ATK permanently', icon: '\u2694\uFE0F' },
  { type: 'defBoost', weight: 25, label: 'DEF Crystal',     desc: 'All monsters gain +10% DEF permanently', icon: '\uD83D\uDEE1\uFE0F' },
  { type: 'spdBoost', weight: 15, label: 'SPD Crystal',     desc: 'All monsters gain +10% SPD permanently', icon: '\uD83D\uDCA8' },
  { type: 'hpBoost',  weight: 20, label: 'HP Crystal',      desc: 'All monsters gain +15 max HP',         icon: '\u2764\uFE0F\u200D\uD83D\uDD25' },
  { type: 'newMove',  weight: 15, label: 'Move Tutor',      desc: 'Replace a move on one monster',        icon: '\uD83D\uDCDA' },
];

const TOTAL_FLOORS = 8;

// ═══════════════════════════════════════════
// GAME STATE
// ═══════════════════════════════════════════
let playerTeam = [];
let enemyTeam = [];
let playerActive = 0;
let enemyActive = 0;
let currentFloor = 1;
let battleState = 'idle'; // idle, playerTurn, animating, enemyTurn, battleOver
let runActive = false;
let superEffectiveCount = 0;
let healsTaken = 0;
let enemiesDefeated = 0;
let battlesWon = 0;
let runSweeps = 0;

// ═══════════════════════════════════════════
// SCREEN MANAGEMENT
// ═══════════════════════════════════════════
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}

// ═══════════════════════════════════════════
// STATS DISPLAY
// ═══════════════════════════════════════════
function showStats() {
  const s = loadStats();
  const el = document.getElementById('stats-content');
  el.innerHTML = [
    ['Total Runs', s.totalRuns],
    ['Wins', s.wins],
    ['Best Floor', s.bestFloor + '/' + TOTAL_FLOORS],
    ['Battles Won', s.totalBattlesWon],
    ['Enemies Defeated', s.totalEnemiesDefeated],
  ].map(([k, v]) => `<div class="stat-row"><span>${k}</span><span>${v}</span></div>`).join('');
  document.getElementById('stats-overlay').classList.add('visible');
  document.getElementById('stats-backdrop').classList.add('visible');
}

function hideStats() {
  document.getElementById('stats-overlay').classList.remove('visible');
  document.getElementById('stats-backdrop').classList.remove('visible');
}

function showCollection() {
  renderCollection();
  showScreen('collection-screen');
}

function renderCollection() {
  const collected = loadCollection();
  const allDefs = Object.entries(MONSTER_DEFS).map(([key, def]) => ({ key, def }));
  allDefs.push({ key: '_boss', def: BOSS_DEF });
  const total = allDefs.length;
  const count = collected.length;
  document.getElementById('collection-count').textContent = `${count} / ${total} Collected`;

  const grid = document.getElementById('collection-grid');
  grid.innerHTML = '';
  for (const { key, def } of allDefs) {
    const owned = collected.includes(key);
    const card = document.createElement('div');
    card.className = 'collection-card' + (owned ? ' collected' : '');
    const elColor = ELEMENT_COLORS[def.element] || '#888';
    card.innerHTML = `
      <div class="cc-sprite${owned ? '' : ' silhouette'}">${getMonsterSVG(def.name, 'right')}</div>
      <div class="cc-name">${owned ? def.name : '???'}</div>
      <div class="cc-element" style="background:${elColor}88">${owned ? def.element : '???'}</div>
      ${owned ? `<div class="cc-stats">HP <span>${def.hp}</span> ATK <span>${def.atk}</span><br>DEF <span>${def.def}</span> SPD <span>${def.spd}</span></div>` : '<div class="cc-stats" style="color:#555">Not yet discovered</div>'}
    `;
    grid.appendChild(card);
  }
}

// ═══════════════════════════════════════════
// MONSTER CREATION
// ═══════════════════════════════════════════
function createMonster(def, scale) {
  scale = scale || 1;
  return {
    name: def.name, element: def.element, icon: def.icon,
    hp: Math.floor(def.hp * scale), maxHp: Math.floor(def.hp * scale),
    atk: Math.floor(def.atk * scale), baseAtk: Math.floor(def.atk * scale),
    def: Math.floor(def.def * scale), baseDef: Math.floor(def.def * scale),
    spd: Math.floor(def.spd * scale), baseSpd: Math.floor(def.spd * scale),
    moves: def.moves.map(m => ({ ...m, effect: m.effect ? { ...m.effect } : null })),
    buffs: {},     // { atk: { amount, turns }, def: {...}, spd: {...}, accuracy: {...} }
    statuses: [],
    stunned: false,
    kos: 0,
  };
}

// ═══════════════════════════════════════════
// DRAFT
// ═══════════════════════════════════════════
let draftPool = [];
let draftSelected = [];

function startDraft() {
  // Check for trainer first
  if (!loadTrainer()) {
    showTrainerScreen();
    return;
  }

  draftPool = [];
  draftSelected = [];
  const gg = ggLoad();
  const hasDrakovex = !!gg.shopPurchases['bm_drakovex'];
  const keys = Object.keys(MONSTER_DEFS).filter(k => k !== 'drakovex' || hasDrakovex);

  // Pick 5 random unique
  const shuffled = keys.sort(() => Math.random() - 0.5);
  draftPool = shuffled.slice(0, Math.min(5, keys.length));

  renderDraft();
  showScreen('draft-screen');
  initTutorial();
  tryTutorialStep('draft');
}

function renderDraft() {
  const container = document.getElementById('draft-cards');
  container.innerHTML = '';
  for (const key of draftPool) {
    const def = MONSTER_DEFS[key];
    const card = document.createElement('div');
    card.className = 'draft-card' + (draftSelected.includes(key) ? ' selected' : '');
    card.onclick = () => toggleDraftSelect(key);
    card.innerHTML = `
      <div class="dc-header">
        <span class="dc-icon">${def.icon}</span>
        <span class="dc-name">${def.name}</span>
        <span class="dc-element" style="background:${ELEMENT_COLORS[def.element]}">${def.element}</span>
      </div>
      <div class="dc-stats">
        <span>HP <span class="stat-val">${def.hp}</span></span>
        <span>ATK <span class="stat-val">${def.atk}</span></span>
        <span>DEF <span class="stat-val">${def.def}</span></span>
        <span>SPD <span class="stat-val">${def.spd}</span></span>
      </div>
      <div class="dc-moves">
        ${def.moves.map(m => `<div>&#8227; ${m.name} <span style="color:${ELEMENT_COLORS[m.element]}">(${m.element})</span></div>`).join('')}
      </div>
    `;
    container.appendChild(card);
  }

  document.getElementById('draft-sub').textContent = `Select 3 monsters (${draftSelected.length}/3)`;
  for (let i = 0; i < 3; i++) {
    const slot = document.getElementById('ds' + i);
    if (draftSelected[i]) {
      const def = MONSTER_DEFS[draftSelected[i]];
      slot.textContent = def.icon;
      slot.className = 'draft-slot filled';
    } else {
      slot.textContent = '?';
      slot.className = 'draft-slot';
    }
  }
  document.getElementById('draft-begin-btn').style.display = draftSelected.length === 3 ? '' : 'none';
}

function toggleDraftSelect(key) {
  SFX.select();
  const idx = draftSelected.indexOf(key);
  if (idx >= 0) {
    draftSelected.splice(idx, 1);
  } else if (draftSelected.length < 3) {
    draftSelected.push(key);
  }
  renderDraft();
  if (draftSelected.length === 1) tryTutorialStep('draft-select-1');
}

function beginRun() {
  // Track elements used for achievement
  const stats = loadStats();
  for (const key of draftSelected) {
    const el = MONSTER_DEFS[key].element;
    if (!stats.elementsUsed.includes(el)) stats.elementsUsed.push(el);
  }
  saveStats(stats);
  if (stats.elementsUsed.length >= 6) ggTry('bm_all_elements');

  playerTeam = draftSelected.map(k => createMonster(MONSTER_DEFS[k]));
  currentFloor = 1;
  runActive = true;
  superEffectiveCount = 0;
  healsTaken = 0;
  enemiesDefeated = 0;
  battlesWon = 0;
  runSweeps = 0;
  startBattle();
}

// ═══════════════════════════════════════════
// ENEMY GENERATION
// ═══════════════════════════════════════════
function generateEnemyTeam(floor) {
  if (floor >= TOTAL_FLOORS) {
    // Boss floor
    const scale = 1 + (floor - 1) * 0.15;
    const boss = createMonster(BOSS_DEF, scale);
    boss.defKey = '_boss';
    return [boss];
  }
  const count = floor <= 1 ? 1 : floor <= 3 ? 2 : 3;
  const gg = ggLoad();
  const hasDrakovex = !!gg.shopPurchases['bm_drakovex'];
  const keys = Object.keys(MONSTER_DEFS).filter(k => k !== 'drakovex' || hasDrakovex);
  const team = [];
  const scale = floor <= 1 ? 0.7 : 1 + (floor - 1) * 0.15;
  for (let i = 0; i < count; i++) {
    const key = keys[Math.floor(Math.random() * keys.length)];
    const m = createMonster(MONSTER_DEFS[key], scale);
    m.defKey = key;
    team.push(m);
  }
  return team;
}

// ═══════════════════════════════════════════
// COMBAT ENGINE
// ═══════════════════════════════════════════
function calculateDamage(attacker, defender, move) {
  if (move.power === 0) return 0;
  const effectiveness = getEffectiveness(move.element, defender.element);
  const atkMod = attacker.buffs.atk ? (1 + attacker.buffs.atk.amount / 100) : 1;
  const defMod = defender.buffs.def ? (1 + defender.buffs.def.amount / 100) : 1;
  const atkStat = attacker.atk * atkMod;
  const defStat = defender.def * defMod;
  const baseDmg = ((move.power * (atkStat / defStat)) / 4) + 2;
  const variance = 0.85 + Math.random() * 0.15;
  return Math.max(1, Math.floor(baseDmg * effectiveness * variance));
}

function doesHit(attacker, move) {
  const accMod = attacker.buffs.accuracy ? (1 + attacker.buffs.accuracy.amount / 100) : 1;
  const finalAcc = move.accuracy * accMod;
  return Math.random() * 100 < finalAcc;
}

function getEffSpd(mon) {
  const spdMod = mon.buffs.spd ? (1 + mon.buffs.spd.amount / 100) : 1;
  return mon.spd * spdMod;
}

function applyEndOfTurnEffects(mon) {
  const log = [];
  // Tick buffs
  for (const stat in mon.buffs) {
    mon.buffs[stat].turns--;
    if (mon.buffs[stat].turns <= 0) delete mon.buffs[stat];
  }
  return log;
}

function executeMove(attacker, defender, move) {
  const log = [];
  let damage = 0;

  // Accuracy check
  if (!doesHit(attacker, move)) {
    log.push({ text: `${attacker.name} used ${move.name}... but missed!`, cls: '' });
    SFX.miss();
    return { log, damage: 0 };
  }

  // Damage
  damage = calculateDamage(attacker, defender, move);
  const eff = move.power > 0 ? getEffectiveness(move.element, defender.element) : 1;

  if (move.power > 0) {
    defender.hp = Math.max(0, defender.hp - damage);
    let effText = '';
    if (eff >= 1.5) { effText = ' Super effective!'; SFX.superHit(); }
    else if (eff <= 0.67) { effText = ' Not very effective...'; SFX.hit(); }
    else { SFX.hit(); }
    const cls = eff >= 1.5 ? 'log-super' : eff <= 0.67 ? 'log-nve' : '';
    log.push({ text: `${attacker.name} used ${move.name}! Dealt ${damage} damage.${effText}`, cls });
  } else {
    log.push({ text: `${attacker.name} used ${move.name}!`, cls: '' });
  }

  // Track super effective
  if (eff >= 1.5) superEffectiveCount++;

  // Apply effects
  if (move.effect && defender.hp > 0) {
    const eff_data = move.effect;
    const chance = eff_data.chance !== undefined ? eff_data.chance : 100;
    const roll = Math.random() * 100;

    if (eff_data.type === 'stun' && roll < chance) {
      defender.stunned = true;
      log.push({ text: `${defender.name} was stunned!`, cls: 'log-status' });
      SFX.status();
    } else if (eff_data.type === 'debuff' && roll < chance) {
      defender.buffs[eff_data.stat] = { amount: -eff_data.amount, turns: eff_data.turns };
      log.push({ text: `${defender.name}'s ${eff_data.stat.toUpperCase()} fell!`, cls: 'log-status' });
      SFX.status();
    } else if (eff_data.type === 'buffSelf') {
      attacker.buffs[eff_data.stat] = { amount: eff_data.amount, turns: eff_data.turns };
      log.push({ text: `${attacker.name}'s ${eff_data.stat.toUpperCase()} rose!`, cls: 'log-status' });
      SFX.buff();
    } else if (eff_data.type === 'drain') {
      const healed = Math.max(1, Math.floor(damage * eff_data.percent / 100));
      attacker.hp = Math.min(attacker.maxHp, attacker.hp + healed);
      log.push({ text: `${attacker.name} drained ${healed} HP!`, cls: 'log-heal' });
      SFX.heal();
    } else if (eff_data.type === 'healSelf') {
      const healed = Math.max(1, Math.floor(attacker.maxHp * eff_data.percent / 100));
      attacker.hp = Math.min(attacker.maxHp, attacker.hp + healed);
      log.push({ text: `${attacker.name} healed ${healed} HP!`, cls: 'log-heal' });
      SFX.heal();
    }
    // priority is handled in turn order, not as an effect
  }

  // Handle buffSelf on zero-power moves (apply even if no defender interaction)
  if (move.effect && move.effect.type === 'buffSelf' && move.power === 0) {
    // Already handled above via the effect logic
  }

  return { log, damage };
}

// ═══════════════════════════════════════════
// AI
// ═══════════════════════════════════════════
function aiSelectAction(aiTeam, aiActiveIdx, playerMon) {
  const active = aiTeam[aiActiveIdx];
  if (active.hp <= 0) return null;

  let bestScore = -Infinity;
  let bestAction = { type: 'move', index: 0 };
  const smartness = currentFloor <= 1 ? 0.05 : Math.min(0.9, 0.3 + currentFloor * 0.08);

  for (let i = 0; i < active.moves.length; i++) {
    const move = active.moves[i];
    let score = 0;

    if (move.power > 0) {
      const eff = getEffectiveness(move.element, playerMon.element);
      score += move.power * eff * (move.accuracy / 100);
      if (eff >= 1.5) score += 30;
    }
    if (move.effect) {
      if (move.effect.type === 'buffSelf') score += 15;
      if (move.effect.type === 'debuff') score += 12;
      if (move.effect.type === 'stun') score += 20 * ((move.effect.chance || 100) / 100);
      if (move.effect.type === 'healSelf') score += 30 * (1 - active.hp / active.maxHp);
      if (move.effect.type === 'drain') score += 15 * (1 - active.hp / active.maxHp);
    }
    score += (Math.random() - 0.5) * (1 - smartness) * 60;
    if (score > bestScore) { bestScore = score; bestAction = { type: 'move', index: i }; }
  }

  // Consider switching
  for (let i = 0; i < aiTeam.length; i++) {
    if (i === aiActiveIdx || aiTeam[i].hp <= 0) continue;
    const switchEff = getEffectiveness(aiTeam[i].moves[0]?.element || 'Normal', playerMon.element);
    const currentEff = getEffectiveness(active.element, playerMon.element);
    let switchScore = 0;
    if (switchEff >= 1.5 && currentEff <= 1.0) switchScore = 40;
    if (active.hp < active.maxHp * 0.2 && aiTeam[i].hp > aiTeam[i].maxHp * 0.5) switchScore += 20;
    switchScore += (Math.random() - 0.5) * (1 - smartness) * 40;
    if (switchScore > bestScore) { bestScore = switchScore; bestAction = { type: 'switch', index: i }; }
  }

  return bestAction;
}

// ═══════════════════════════════════════════
// BATTLE FLOW
// ═══════════════════════════════════════════
function startBattle() {
  enemyTeam = generateEnemyTeam(currentFloor);
  playerActive = playerTeam.findIndex(m => m.hp > 0);
  enemyActive = 0;
  superEffectiveCount = 0;
  battleState = 'playerTurn';

  if (currentFloor >= 4) ggTry('bm_floor_4');

  document.getElementById('floor-label').textContent = `FLOOR ${currentFloor}/${TOTAL_FLOORS}`;
  clearBattleLog();
  addBattleLog(`Floor ${currentFloor} — ` + (currentFloor >= TOTAL_FLOORS ? 'BOSS BATTLE!' : `${enemyTeam.length} enemies approach!`), '');

  renderBattle();
  showScreen('battle-screen');
  enableActions(true);
  if (currentFloor === 1) tryTutorialStep('battle-start');
}

// ═══════════════════════════════════════════
// MONSTER SPRITES
// ═══════════════════════════════════════════
function getMonsterSVG(monsterName, facing) {
  const w = monsterName === 'Chimera Rex' ? 90 : 70;
  const h = monsterName === 'Chimera Rex' ? 90 : 70;
  const flip = facing === 'left' ? ` transform="scale(-1,1) translate(-${w},0)"` : '';
  const vb = `0 0 ${w} ${h}`;

  const sprites = {
    'Emberon': `<svg width="${w}" height="${h}" viewBox="${vb}"><g${flip}>
      <!-- body -->
      <ellipse cx="35" cy="42" rx="18" ry="16" fill="#ff6b35"/>
      <ellipse cx="35" cy="42" rx="14" ry="12" fill="#ff8a50"/>
      <!-- head -->
      <circle cx="35" cy="26" r="12" fill="#ff6b35"/>
      <circle cx="35" cy="26" r="9" fill="#ff8a50"/>
      <!-- eyes -->
      <circle cx="31" cy="24" r="3" fill="#fff"/>
      <circle cx="39" cy="24" r="3" fill="#fff"/>
      <circle cx="32" cy="23.5" r="1.5" fill="#222"/>
      <circle cx="40" cy="23.5" r="1.5" fill="#222"/>
      <!-- happy mouth -->
      <path d="M30 29 Q35 34 40 29" fill="none" stroke="#c44" stroke-width="1.5" stroke-linecap="round"/>
      <!-- flame tail -->
      <path d="M53 40 Q60 35 57 28 Q55 33 52 30 Q54 36 50 38" fill="#ffcc00" opacity="0.9"/>
      <path d="M53 42 Q58 38 56 32" fill="none" stroke="#ff6b35" stroke-width="1"/>
      <!-- spikes -->
      <polygon points="28,16 32,10 36,16" fill="#ff4400" opacity="0.7"/>
      <polygon points="34,14 37,8 40,14" fill="#ff4400" opacity="0.7"/>
      <!-- feet -->
      <ellipse cx="27" cy="56" rx="6" ry="4" fill="#e05a25"/>
      <ellipse cx="43" cy="56" rx="6" ry="4" fill="#e05a25"/>
      <!-- blush -->
      <circle cx="26" cy="28" r="3" fill="#ff4444" opacity="0.25"/>
      <circle cx="44" cy="28" r="3" fill="#ff4444" opacity="0.25"/>
    </g></svg>`,

    'Tidalin': `<svg width="${w}" height="${h}" viewBox="${vb}"><g${flip}>
      <!-- body -->
      <ellipse cx="35" cy="40" rx="20" ry="18" fill="#3399ff"/>
      <ellipse cx="35" cy="40" rx="16" ry="14" fill="#66bbff"/>
      <!-- droplet head -->
      <path d="M35 10 Q25 25 25 30 Q25 38 35 38 Q45 38 45 30 Q45 25 35 10Z" fill="#3399ff"/>
      <path d="M35 15 Q28 27 28 31 Q28 36 35 36 Q42 36 42 31 Q42 27 35 15Z" fill="#66bbff"/>
      <!-- eyes -->
      <circle cx="31" cy="29" r="3" fill="#fff"/>
      <circle cx="39" cy="29" r="3" fill="#fff"/>
      <circle cx="32" cy="28.5" r="1.5" fill="#223"/>
      <circle cx="40" cy="28.5" r="1.5" fill="#223"/>
      <!-- happy mouth -->
      <path d="M31 33 Q35 37 39 33" fill="none" stroke="#2266aa" stroke-width="1.5" stroke-linecap="round"/>
      <!-- wave fins -->
      <path d="M15 38 Q12 32 17 30 Q14 36 18 35" fill="#3399ff" opacity="0.7"/>
      <path d="M55 38 Q58 32 53 30 Q56 36 52 35" fill="#3399ff" opacity="0.7"/>
      <!-- feet -->
      <ellipse cx="28" cy="56" rx="6" ry="3" fill="#2288dd"/>
      <ellipse cx="42" cy="56" rx="6" ry="3" fill="#2288dd"/>
      <!-- shine -->
      <circle cx="30" cy="22" r="2" fill="#fff" opacity="0.5"/>
      <!-- blush -->
      <circle cx="26" cy="32" r="3" fill="#5599ff" opacity="0.3"/>
      <circle cx="44" cy="32" r="3" fill="#5599ff" opacity="0.3"/>
    </g></svg>`,

    'Thornvine': `<svg width="${w}" height="${h}" viewBox="${vb}"><g${flip}>
      <!-- body -->
      <ellipse cx="35" cy="42" rx="17" ry="16" fill="#44bb44"/>
      <ellipse cx="35" cy="42" rx="13" ry="12" fill="#66dd66"/>
      <!-- head -->
      <circle cx="35" cy="26" r="12" fill="#44bb44"/>
      <circle cx="35" cy="26" r="9" fill="#66dd66"/>
      <!-- leaf ears -->
      <path d="M22 20 Q18 10 25 15" fill="#33aa33" stroke="#228822" stroke-width="0.5"/>
      <path d="M48 20 Q52 10 45 15" fill="#33aa33" stroke="#228822" stroke-width="0.5"/>
      <!-- eyes -->
      <circle cx="31" cy="24" r="3" fill="#fff"/>
      <circle cx="39" cy="24" r="3" fill="#fff"/>
      <circle cx="32" cy="23.5" r="1.5" fill="#222"/>
      <circle cx="40" cy="23.5" r="1.5" fill="#222"/>
      <!-- happy mouth -->
      <path d="M30 29 Q35 34 40 29" fill="none" stroke="#228822" stroke-width="1.5" stroke-linecap="round"/>
      <!-- vine arms -->
      <path d="M18 40 Q10 35 8 42 Q12 40 14 44" fill="none" stroke="#33aa33" stroke-width="2.5" stroke-linecap="round"/>
      <path d="M52 40 Q60 35 62 42 Q58 40 56 44" fill="none" stroke="#33aa33" stroke-width="2.5" stroke-linecap="round"/>
      <!-- small leaves on vines -->
      <ellipse cx="9" cy="40" rx="3" ry="2" fill="#33aa33" transform="rotate(-20,9,40)"/>
      <ellipse cx="61" cy="40" rx="3" ry="2" fill="#33aa33" transform="rotate(20,61,40)"/>
      <!-- feet -->
      <ellipse cx="27" cy="56" rx="6" ry="4" fill="#33aa33"/>
      <ellipse cx="43" cy="56" rx="6" ry="4" fill="#33aa33"/>
      <!-- flower on head -->
      <circle cx="35" cy="15" r="4" fill="#ff88aa" opacity="0.7"/>
      <circle cx="35" cy="15" r="2" fill="#ffcc44" opacity="0.8"/>
      <!-- blush -->
      <circle cx="26" cy="28" r="3" fill="#88ee88" opacity="0.35"/>
      <circle cx="44" cy="28" r="3" fill="#88ee88" opacity="0.35"/>
    </g></svg>`,

    'Voltpaw': `<svg width="${w}" height="${h}" viewBox="${vb}"><g${flip}>
      <!-- body -->
      <ellipse cx="35" cy="42" rx="15" ry="14" fill="#ffcc00"/>
      <ellipse cx="35" cy="42" rx="11" ry="10" fill="#ffdd44"/>
      <!-- head -->
      <circle cx="35" cy="26" r="11" fill="#ffcc00"/>
      <circle cx="35" cy="26" r="8" fill="#ffdd44"/>
      <!-- pointy ears -->
      <polygon points="24,20 20,8 30,18" fill="#ffcc00"/>
      <polygon points="46,20 50,8 40,18" fill="#ffcc00"/>
      <polygon points="25,18 22,11 29,17" fill="#ffdd44"/>
      <polygon points="45,18 48,11 41,17" fill="#ffdd44"/>
      <!-- eyes -->
      <circle cx="31" cy="24" r="3" fill="#fff"/>
      <circle cx="39" cy="24" r="3" fill="#fff"/>
      <circle cx="32" cy="23.5" r="1.5" fill="#222"/>
      <circle cx="40" cy="23.5" r="1.5" fill="#222"/>
      <!-- happy mouth -->
      <path d="M31 29 Q35 33 39 29" fill="none" stroke="#bb8800" stroke-width="1.5" stroke-linecap="round"/>
      <!-- zigzag tail -->
      <polyline points="50,38 55,32 52,28 58,22 55,18" fill="none" stroke="#ffcc00" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/>
      <!-- spark marks -->
      <line x1="20" y1="14" x2="17" y2="10" stroke="#ffcc00" stroke-width="1.5" opacity="0.6"/>
      <line x1="50" y1="14" x2="53" y2="10" stroke="#ffcc00" stroke-width="1.5" opacity="0.6"/>
      <!-- feet -->
      <ellipse cx="27" cy="54" rx="5" ry="4" fill="#ddaa00"/>
      <ellipse cx="43" cy="54" rx="5" ry="4" fill="#ddaa00"/>
      <!-- blush -->
      <circle cx="26" cy="28" r="3" fill="#ffaa00" opacity="0.3"/>
      <circle cx="44" cy="28" r="3" fill="#ffaa00" opacity="0.3"/>
    </g></svg>`,

    'Grimshade': `<svg width="${w}" height="${h}" viewBox="${vb}"><g${flip}>
      <!-- ghostly body -->
      <path d="M20 25 Q20 12 35 12 Q50 12 50 25 L50 50 Q47 45 44 50 Q41 45 38 50 Q35 45 32 50 Q29 45 26 50 Q23 45 20 50 Z" fill="#9966cc"/>
      <path d="M24 25 Q24 16 35 16 Q46 16 46 25 L46 46 Q43 42 40 46 Q37 42 34 46 Q31 42 28 46 Q25 42 24 44 Z" fill="#bb88ee"/>
      <!-- eyes -->
      <circle cx="30" cy="26" r="4" fill="#fff"/>
      <circle cx="40" cy="26" r="4" fill="#fff"/>
      <circle cx="31" cy="25.5" r="2" fill="#440066"/>
      <circle cx="41" cy="25.5" r="2" fill="#440066"/>
      <!-- eye shine -->
      <circle cx="29" cy="24.5" r="1" fill="#fff" opacity="0.8"/>
      <circle cx="39" cy="24.5" r="1" fill="#fff" opacity="0.8"/>
      <!-- happy mouth -->
      <path d="M30 33 Q35 37 40 33" fill="none" stroke="#663399" stroke-width="1.5" stroke-linecap="round"/>
      <!-- wispy aura -->
      <ellipse cx="18" cy="30" rx="4" ry="8" fill="#9966cc" opacity="0.3"/>
      <ellipse cx="52" cy="30" rx="4" ry="8" fill="#9966cc" opacity="0.3"/>
      <!-- blush -->
      <circle cx="25" cy="30" r="3" fill="#cc88ff" opacity="0.3"/>
      <circle cx="45" cy="30" r="3" fill="#cc88ff" opacity="0.3"/>
    </g></svg>`,

    'Solarius': `<svg width="${w}" height="${h}" viewBox="${vb}"><g${flip}>
      <!-- ray spikes -->
      <polygon points="35,5 32,16 38,16" fill="#ffdd44" opacity="0.6"/>
      <polygon points="35,65 32,54 38,54" fill="#ffdd44" opacity="0.6"/>
      <polygon points="5,35 16,32 16,38" fill="#ffdd44" opacity="0.6"/>
      <polygon points="65,35 54,32 54,38" fill="#ffdd44" opacity="0.6"/>
      <polygon points="14,14 22,20 18,24" fill="#ffdd44" opacity="0.4"/>
      <polygon points="56,14 48,20 52,24" fill="#ffdd44" opacity="0.4"/>
      <polygon points="14,56 22,50 18,46" fill="#ffdd44" opacity="0.4"/>
      <polygon points="56,56 48,50 52,46" fill="#ffdd44" opacity="0.4"/>
      <!-- body glow -->
      <circle cx="35" cy="35" r="20" fill="#ffee88" opacity="0.3"/>
      <!-- body -->
      <circle cx="35" cy="35" r="16" fill="#ffdd44"/>
      <circle cx="35" cy="35" r="13" fill="#ffee88"/>
      <!-- eyes -->
      <circle cx="30" cy="33" r="3" fill="#fff"/>
      <circle cx="40" cy="33" r="3" fill="#fff"/>
      <circle cx="31" cy="32.5" r="1.5" fill="#885500"/>
      <circle cx="41" cy="32.5" r="1.5" fill="#885500"/>
      <!-- big happy smile -->
      <path d="M28 38 Q35 44 42 38" fill="none" stroke="#cc8800" stroke-width="1.5" stroke-linecap="round"/>
      <!-- blush -->
      <circle cx="25" cy="37" r="3" fill="#ffaa44" opacity="0.35"/>
      <circle cx="45" cy="37" r="3" fill="#ffaa44" opacity="0.35"/>
      <!-- feet -->
      <ellipse cx="28" cy="52" rx="5" ry="3" fill="#ddbb22"/>
      <ellipse cx="42" cy="52" rx="5" ry="3" fill="#ddbb22"/>
    </g></svg>`,

    'Drakovex': `<svg width="${w}" height="${h}" viewBox="${vb}"><g${flip}>
      <!-- wings -->
      <path d="M15 28 Q5 15 12 10 L22 25 Z" fill="#7744aa" opacity="0.6"/>
      <path d="M55 28 Q65 15 58 10 L48 25 Z" fill="#7744aa" opacity="0.6"/>
      <!-- body -->
      <ellipse cx="35" cy="42" rx="16" ry="15" fill="#7744aa"/>
      <ellipse cx="35" cy="42" rx="12" ry="11" fill="#9966cc"/>
      <!-- head -->
      <circle cx="35" cy="24" r="12" fill="#7744aa"/>
      <circle cx="35" cy="24" r="9" fill="#9966cc"/>
      <!-- horns -->
      <polygon points="26,16 22,4 30,14" fill="#553388"/>
      <polygon points="44,16 48,4 40,14" fill="#553388"/>
      <!-- eyes -->
      <circle cx="31" cy="22" r="3" fill="#fff"/>
      <circle cx="39" cy="22" r="3" fill="#fff"/>
      <circle cx="32" cy="21.5" r="1.5" fill="#ff4444"/>
      <circle cx="40" cy="21.5" r="1.5" fill="#ff4444"/>
      <!-- sly grin -->
      <path d="M29 28 Q35 33 41 28" fill="none" stroke="#442266" stroke-width="1.5" stroke-linecap="round"/>
      <!-- sharp tail -->
      <path d="M51 44 Q58 40 62 44 Q60 42 58 46" fill="#7744aa"/>
      <!-- belly -->
      <ellipse cx="35" cy="45" rx="8" ry="7" fill="#aa88dd" opacity="0.4"/>
      <!-- feet -->
      <ellipse cx="27" cy="55" rx="6" ry="4" fill="#6633aa"/>
      <ellipse cx="43" cy="55" rx="6" ry="4" fill="#6633aa"/>
      <!-- blush -->
      <circle cx="26" cy="26" r="3" fill="#aa66ee" opacity="0.3"/>
      <circle cx="44" cy="26" r="3" fill="#aa66ee" opacity="0.3"/>
    </g></svg>`,

    'Blazetail': `<svg width="${w}" height="${h}" viewBox="${vb}"><g${flip}>
      <!-- body -->
      <ellipse cx="35" cy="42" rx="16" ry="14" fill="#ff6633"/>
      <ellipse cx="35" cy="42" rx="12" ry="10" fill="#ff8844"/>
      <!-- head -->
      <ellipse cx="35" cy="26" rx="11" ry="10" fill="#ff6633"/>
      <ellipse cx="35" cy="26" rx="8" ry="7" fill="#ff8844"/>
      <!-- pointed fox ears -->
      <polygon points="24,20 18,6 30,16" fill="#ff6633"/>
      <polygon points="46,20 52,6 40,16" fill="#ff6633"/>
      <polygon points="25,18 21,10 29,16" fill="#ff8844"/>
      <polygon points="45,18 49,10 41,16" fill="#ff8844"/>
      <!-- eyes -->
      <ellipse cx="30" cy="24" rx="3" ry="2.5" fill="#fff"/>
      <ellipse cx="40" cy="24" rx="3" ry="2.5" fill="#fff"/>
      <ellipse cx="31" cy="23.5" rx="1.5" ry="1.5" fill="#222"/>
      <ellipse cx="41" cy="23.5" rx="1.5" ry="1.5" fill="#222"/>
      <!-- sly mouth -->
      <path d="M30 29 Q35 32 40 28" fill="none" stroke="#cc4411" stroke-width="1.5" stroke-linecap="round"/>
      <!-- nose -->
      <ellipse cx="35" cy="27" rx="1.5" ry="1" fill="#cc3300"/>
      <!-- big flame tail -->
      <path d="M51 38 Q60 30 58 22 Q56 28 54 24 Q55 32 52 34" fill="#ffcc00" opacity="0.9"/>
      <path d="M52 40 Q58 34 57 26 Q55 30 53 28 Q54 35 51 37" fill="#ff8800" opacity="0.7"/>
      <!-- feet -->
      <ellipse cx="27" cy="54" rx="5" ry="4" fill="#dd5522"/>
      <ellipse cx="43" cy="54" rx="5" ry="4" fill="#dd5522"/>
      <!-- blush -->
      <circle cx="25" cy="27" r="3" fill="#ff4444" opacity="0.25"/>
      <circle cx="45" cy="27" r="3" fill="#ff4444" opacity="0.25"/>
    </g></svg>`,

    'Aquarion': `<svg width="${w}" height="${h}" viewBox="${vb}"><g${flip}>
      <!-- shell -->
      <ellipse cx="35" cy="38" rx="20" ry="18" fill="#2288aa"/>
      <path d="M18 35 Q25 25 35 24 Q45 25 52 35" fill="#33aa88" stroke="#228866" stroke-width="1"/>
      <!-- shell pattern -->
      <path d="M27 28 L30 35" stroke="#228866" stroke-width="1" opacity="0.5"/>
      <path d="M35 24 L35 35" stroke="#228866" stroke-width="1" opacity="0.5"/>
      <path d="M43 28 L40 35" stroke="#228866" stroke-width="1" opacity="0.5"/>
      <!-- belly -->
      <ellipse cx="35" cy="44" rx="14" ry="10" fill="#88ddcc" opacity="0.5"/>
      <!-- head -->
      <circle cx="35" cy="22" r="10" fill="#2288aa"/>
      <circle cx="35" cy="22" r="7" fill="#44aacc"/>
      <!-- eyes -->
      <circle cx="31" cy="20" r="3" fill="#fff"/>
      <circle cx="39" cy="20" r="3" fill="#fff"/>
      <circle cx="32" cy="19.5" r="1.5" fill="#113344"/>
      <circle cx="40" cy="19.5" r="1.5" fill="#113344"/>
      <!-- happy mouth -->
      <path d="M31 25 Q35 29 39 25" fill="none" stroke="#115566" stroke-width="1.5" stroke-linecap="round"/>
      <!-- sturdy limbs -->
      <rect x="14" y="40" width="7" height="10" rx="3" fill="#2288aa"/>
      <rect x="49" y="40" width="7" height="10" rx="3" fill="#2288aa"/>
      <!-- feet -->
      <ellipse cx="17" cy="52" rx="5" ry="3" fill="#1a7799"/>
      <ellipse cx="53" cy="52" rx="5" ry="3" fill="#1a7799"/>
      <!-- blush -->
      <circle cx="26" cy="23" r="3" fill="#44cccc" opacity="0.3"/>
      <circle cx="44" cy="23" r="3" fill="#44cccc" opacity="0.3"/>
    </g></svg>`,

    'Petalynx': `<svg width="${w}" height="${h}" viewBox="${vb}"><g${flip}>
      <!-- body -->
      <ellipse cx="35" cy="42" rx="15" ry="13" fill="#55bb55"/>
      <ellipse cx="35" cy="42" rx="11" ry="9" fill="#77dd77"/>
      <!-- head -->
      <ellipse cx="35" cy="24" rx="11" ry="10" fill="#55bb55"/>
      <ellipse cx="35" cy="24" rx="8" ry="7" fill="#77dd77"/>
      <!-- cat ears -->
      <polygon points="24,18 20,6 30,14" fill="#55bb55"/>
      <polygon points="46,18 50,6 40,14" fill="#55bb55"/>
      <polygon points="25,16 22,9 29,14" fill="#77dd77"/>
      <polygon points="45,16 48,9 41,14" fill="#77dd77"/>
      <!-- flower petals around neck -->
      <circle cx="24" cy="33" r="4" fill="#ff88aa" opacity="0.7"/>
      <circle cx="46" cy="33" r="4" fill="#ff88aa" opacity="0.7"/>
      <circle cx="28" cy="30" r="3.5" fill="#ff99bb" opacity="0.6"/>
      <circle cx="42" cy="30" r="3.5" fill="#ff99bb" opacity="0.6"/>
      <circle cx="35" cy="31" r="3" fill="#ffaacc" opacity="0.5"/>
      <!-- eyes -->
      <circle cx="31" cy="22" r="3" fill="#fff"/>
      <circle cx="39" cy="22" r="3" fill="#fff"/>
      <circle cx="32" cy="21.5" r="1.5" fill="#224422"/>
      <circle cx="40" cy="21.5" r="1.5" fill="#224422"/>
      <!-- happy mouth -->
      <path d="M31 27 Q35 31 39 27" fill="none" stroke="#337733" stroke-width="1.5" stroke-linecap="round"/>
      <!-- whiskers -->
      <line x1="22" y1="25" x2="14" y2="23" stroke="#77dd77" stroke-width="0.8" opacity="0.5"/>
      <line x1="22" y1="27" x2="14" y2="28" stroke="#77dd77" stroke-width="0.8" opacity="0.5"/>
      <line x1="48" y1="25" x2="56" y2="23" stroke="#77dd77" stroke-width="0.8" opacity="0.5"/>
      <line x1="48" y1="27" x2="56" y2="28" stroke="#77dd77" stroke-width="0.8" opacity="0.5"/>
      <!-- leaf tail -->
      <path d="M50 40 Q58 35 60 30 Q56 36 54 32" fill="#44aa44" opacity="0.8"/>
      <path d="M51 42 Q56 38 58 34" fill="none" stroke="#338833" stroke-width="1"/>
      <!-- feet -->
      <ellipse cx="27" cy="53" rx="5" ry="3" fill="#44aa44"/>
      <ellipse cx="43" cy="53" rx="5" ry="3" fill="#44aa44"/>
      <!-- blush -->
      <circle cx="26" cy="26" r="3" fill="#88ee88" opacity="0.3"/>
      <circle cx="44" cy="26" r="3" fill="#88ee88" opacity="0.3"/>
    </g></svg>`,

    'Zapplin': `<svg width="${w}" height="${h}" viewBox="${vb}"><g${flip}>
      <!-- body -->
      <ellipse cx="35" cy="40" rx="14" ry="15" fill="#ccaa00"/>
      <ellipse cx="35" cy="40" rx="10" ry="11" fill="#eedd33"/>
      <!-- head -->
      <circle cx="35" cy="24" r="12" fill="#ccaa00"/>
      <circle cx="35" cy="24" r="9" fill="#eedd33"/>
      <!-- jagged ears -->
      <polygon points="22,18 14,4 20,12 16,8 26,16" fill="#ccaa00"/>
      <polygon points="48,18 56,4 50,12 54,8 44,16" fill="#ccaa00"/>
      <!-- big mischievous eyes -->
      <circle cx="30" cy="22" r="4" fill="#fff"/>
      <circle cx="40" cy="22" r="4" fill="#fff"/>
      <circle cx="31" cy="21.5" r="2" fill="#222"/>
      <circle cx="41" cy="21.5" r="2" fill="#222"/>
      <!-- eye shine -->
      <circle cx="29" cy="20.5" r="1" fill="#fff" opacity="0.8"/>
      <circle cx="39" cy="20.5" r="1" fill="#fff" opacity="0.8"/>
      <!-- wide grin -->
      <path d="M28 28 Q35 34 42 28" fill="#aa8800" stroke="#aa8800" stroke-width="1"/>
      <path d="M30 28 L32 30" stroke="#fff" stroke-width="1" opacity="0.6"/>
      <path d="M38 28 L40 30" stroke="#fff" stroke-width="1" opacity="0.6"/>
      <!-- lightning sparks -->
      <polyline points="16,30 12,26 15,28 11,22" fill="none" stroke="#ffee00" stroke-width="1.5" opacity="0.7"/>
      <polyline points="54,30 58,26 55,28 59,22" fill="none" stroke="#ffee00" stroke-width="1.5" opacity="0.7"/>
      <!-- small arms -->
      <rect x="19" y="36" width="4" height="8" rx="2" fill="#ccaa00"/>
      <rect x="47" y="36" width="4" height="8" rx="2" fill="#ccaa00"/>
      <!-- feet -->
      <ellipse cx="28" cy="54" rx="5" ry="3" fill="#bbaa00"/>
      <ellipse cx="42" cy="54" rx="5" ry="3" fill="#bbaa00"/>
      <!-- blush -->
      <circle cx="24" cy="26" r="3" fill="#ffcc00" opacity="0.3"/>
      <circle cx="46" cy="26" r="3" fill="#ffcc00" opacity="0.3"/>
    </g></svg>`,

    'Spectrion': `<svg width="${w}" height="${h}" viewBox="${vb}"><g${flip}>
      <!-- wispy body -->
      <path d="M20 22 Q20 10 35 8 Q50 10 50 22 L52 48 Q49 44 46 50 Q42 44 38 50 Q34 44 30 50 Q26 44 22 50 Q18 44 18 48 Z" fill="#553388"/>
      <path d="M24 22 Q24 14 35 12 Q46 14 46 22 L48 44 Q45 40 42 46 Q38 40 34 46 Q30 40 26 46 Q22 40 22 42 Z" fill="#7755bb"/>
      <!-- single large eye -->
      <circle cx="35" cy="26" r="8" fill="#fff"/>
      <circle cx="35" cy="26" r="5" fill="#660088"/>
      <circle cx="35" cy="26" r="2.5" fill="#ff44ff"/>
      <!-- eye shine -->
      <circle cx="33" cy="23" r="2" fill="#fff" opacity="0.7"/>
      <!-- wispy aura -->
      <ellipse cx="16" cy="28" rx="5" ry="10" fill="#553388" opacity="0.3"/>
      <ellipse cx="54" cy="28" rx="5" ry="10" fill="#553388" opacity="0.3"/>
      <!-- shadow wisps -->
      <path d="M20 35 Q14 30 12 36" fill="none" stroke="#7755bb" stroke-width="1.5" opacity="0.5"/>
      <path d="M50 35 Q56 30 58 36" fill="none" stroke="#7755bb" stroke-width="1.5" opacity="0.5"/>
    </g></svg>`,

    'Celestine': `<svg width="${w}" height="${h}" viewBox="${vb}"><g${flip}>
      <!-- wing protrusions -->
      <path d="M14 30 Q6 18 10 10 L20 25 Z" fill="#ffeecc" opacity="0.5"/>
      <path d="M56 30 Q64 18 60 10 L50 25 Z" fill="#ffeecc" opacity="0.5"/>
      <path d="M16 32 Q10 22 13 14 L22 27 Z" fill="#fff5dd" opacity="0.3"/>
      <path d="M54 32 Q60 22 57 14 L48 27 Z" fill="#fff5dd" opacity="0.3"/>
      <!-- body glow -->
      <circle cx="35" cy="40" r="18" fill="#ffee88" opacity="0.15"/>
      <!-- body -->
      <ellipse cx="35" cy="40" rx="15" ry="14" fill="#eeddaa"/>
      <ellipse cx="35" cy="40" rx="11" ry="10" fill="#fff5dd"/>
      <!-- head -->
      <circle cx="35" cy="24" r="11" fill="#eeddaa"/>
      <circle cx="35" cy="24" r="8" fill="#fff5dd"/>
      <!-- crystal crown -->
      <polygon points="28,16 30,6 33,14" fill="#ffcc44" opacity="0.7"/>
      <polygon points="33,14 35,4 37,14" fill="#ffdd66" opacity="0.8"/>
      <polygon points="37,16 40,6 42,16" fill="#ffcc44" opacity="0.7"/>
      <!-- eyes -->
      <circle cx="31" cy="22" r="3" fill="#fff"/>
      <circle cx="39" cy="22" r="3" fill="#fff"/>
      <circle cx="32" cy="21.5" r="1.5" fill="#886622"/>
      <circle cx="40" cy="21.5" r="1.5" fill="#886622"/>
      <!-- gentle smile -->
      <path d="M31 27 Q35 31 39 27" fill="none" stroke="#aa8844" stroke-width="1.5" stroke-linecap="round"/>
      <!-- feet -->
      <ellipse cx="28" cy="52" rx="5" ry="3" fill="#ddcc88"/>
      <ellipse cx="42" cy="52" rx="5" ry="3" fill="#ddcc88"/>
      <!-- blush -->
      <circle cx="26" cy="26" r="3" fill="#ffcc88" opacity="0.35"/>
      <circle cx="44" cy="26" r="3" fill="#ffcc88" opacity="0.35"/>
    </g></svg>`,

    'Chimera Rex': `<svg width="${w}" height="${h}" viewBox="${vb}"><g${flip}>
      <!-- large body -->
      <ellipse cx="45" cy="50" rx="26" ry="22" fill="#662244"/>
      <ellipse cx="45" cy="50" rx="20" ry="17" fill="#883366"/>
      <!-- head -->
      <circle cx="45" cy="28" r="16" fill="#662244"/>
      <circle cx="45" cy="28" r="12" fill="#883366"/>
      <!-- multiple horns -->
      <polygon points="32,16 28,2 36,14" fill="#551133"/>
      <polygon points="45,12 43,0 47,0" fill="#551133"/>
      <polygon points="58,16 62,2 54,14" fill="#551133"/>
      <!-- fierce but cute eyes -->
      <circle cx="39" cy="26" r="4" fill="#fff"/>
      <circle cx="51" cy="26" r="4" fill="#fff"/>
      <circle cx="40" cy="25.5" r="2" fill="#ff2222"/>
      <circle cx="52" cy="25.5" r="2" fill="#ff2222"/>
      <!-- eye glow -->
      <circle cx="40" cy="25.5" r="3" fill="#ff2222" opacity="0.2"/>
      <circle cx="52" cy="25.5" r="3" fill="#ff2222" opacity="0.2"/>
      <!-- toothy grin -->
      <path d="M36 34 Q45 42 54 34" fill="#441122" stroke="#551133" stroke-width="1"/>
      <path d="M38 34 L40 38 L42 34" fill="#fff" opacity="0.9"/>
      <path d="M46 34 L48 38 L50 34" fill="#fff" opacity="0.9"/>
      <!-- spiky back -->
      <polygon points="20,40 16,30 24,38" fill="#551133" opacity="0.7"/>
      <polygon points="70,40 74,30 66,38" fill="#551133" opacity="0.7"/>
      <!-- thick tail -->
      <path d="M71 52 Q80 48 84 54 Q82 50 78 55" fill="#662244"/>
      <!-- belly plate -->
      <ellipse cx="45" cy="54" rx="12" ry="10" fill="#994477" opacity="0.4"/>
      <!-- feet -->
      <ellipse cx="30" cy="68" rx="8" ry="5" fill="#551133"/>
      <ellipse cx="60" cy="68" rx="8" ry="5" fill="#551133"/>
      <!-- claws -->
      <circle cx="26" cy="68" r="1.5" fill="#fff" opacity="0.5"/>
      <circle cx="30" cy="69" r="1.5" fill="#fff" opacity="0.5"/>
      <circle cx="56" cy="69" r="1.5" fill="#fff" opacity="0.5"/>
      <circle cx="60" cy="68" r="1.5" fill="#fff" opacity="0.5"/>
      <!-- blush (still cute!) -->
      <circle cx="33" cy="30" r="3" fill="#cc4488" opacity="0.3"/>
      <circle cx="57" cy="30" r="3" fill="#cc4488" opacity="0.3"/>
    </g></svg>`,
  };

  return sprites[monsterName] || sprites['Emberon'];
}

function renderBattleScene() {
  const pm = playerTeam[playerActive];
  const em = enemyTeam[enemyActive];

  const enemyEl = document.getElementById('enemy-sprite');
  const playerEl = document.getElementById('player-sprite');

  // Enemy faces right (toward player), player faces left (toward enemy)
  enemyEl.innerHTML = em.hp > 0 ? getMonsterSVG(em.name, 'right') : '';
  playerEl.innerHTML = pm.hp > 0 ? getMonsterSVG(pm.name, 'left') : '';

  // Reset animation classes
  enemyEl.classList.remove('attacking-right', 'attacking-left', 'hit', 'faint');
  playerEl.classList.remove('attacking-right', 'attacking-left', 'hit', 'faint');

  if (em.hp <= 0) enemyEl.classList.add('faint');
  if (pm.hp <= 0) playerEl.classList.add('faint');

  // Trainer sprite
  const trainer = loadTrainer();
  if (trainer) {
    document.getElementById('trainer-battle').innerHTML = getTrainerSVG(trainer);
    document.getElementById('trainer-name-tag').textContent = trainer.name;
  }
}

function animateAttack(isPlayer) {
  const attackerEl = document.getElementById(isPlayer ? 'player-sprite' : 'enemy-sprite');
  const defenderEl = document.getElementById(isPlayer ? 'enemy-sprite' : 'player-sprite');

  // Attacker lunges
  attackerEl.classList.remove('attacking-right', 'attacking-left', 'hit');
  void attackerEl.offsetWidth;
  attackerEl.classList.add(isPlayer ? 'attacking-left' : 'attacking-right');

  // Defender shakes after a short delay
  setTimeout(() => {
    defenderEl.classList.remove('hit');
    void defenderEl.offsetWidth;
    defenderEl.classList.add('hit');
  }, 150);

  // Clean up
  setTimeout(() => {
    attackerEl.classList.remove('attacking-right', 'attacking-left');
    defenderEl.classList.remove('hit');
  }, 400);
}

function animateFaint(isPlayer) {
  const el = document.getElementById(isPlayer ? 'player-sprite' : 'enemy-sprite');
  el.classList.add('faint');
}

function renderBattle() {
  const pm = playerTeam[playerActive];
  const em = enemyTeam[enemyActive];

  // Player HUD
  document.getElementById('pp-name').textContent = pm.name;
  document.getElementById('pp-element').textContent = pm.element;
  document.getElementById('pp-element').style.background = ELEMENT_COLORS[pm.element];
  updateHPBar('pp', pm);
  renderStatuses('pp-statuses', pm);

  // Enemy HUD
  document.getElementById('ep-name').textContent = em.name;
  document.getElementById('ep-element').textContent = em.element;
  document.getElementById('ep-element').style.background = ELEMENT_COLORS[em.element];
  updateHPBar('ep', em);
  renderStatuses('ep-statuses', em);

  // Enemy stats (scanner)
  const gg = ggLoad();
  const hasScanner = !!gg.shopPurchases['bm_stat_scanner'];
  document.getElementById('ep-stats').textContent = hasScanner
    ? `ATK:${em.atk} DEF:${em.def} SPD:${em.spd}` : '';

  // Battle scene sprites
  renderBattleScene();

  // Enemy pips
  const pipsEl = document.getElementById('enemy-pips');
  pipsEl.innerHTML = '';
  for (let i = 0; i < enemyTeam.length; i++) {
    const pip = document.createElement('div');
    pip.className = 'pip';
    const ratio = enemyTeam[i].hp / enemyTeam[i].maxHp;
    pip.style.background = enemyTeam[i].hp <= 0 ? '#333' : ratio > 0.5 ? '#4caf50' : ratio > 0.25 ? '#ffcc00' : '#ff4444';
    pipsEl.appendChild(pip);
  }

  // Team bar
  const teamBar = document.getElementById('team-bar');
  teamBar.innerHTML = '';
  for (let i = 0; i < playerTeam.length; i++) {
    const pip = document.createElement('div');
    pip.className = 'team-pip' + (i === playerActive ? ' active' : '') + (playerTeam[i].hp <= 0 ? ' fainted' : '');
    pip.textContent = playerTeam[i].icon;
    teamBar.appendChild(pip);
  }

  // Move buttons
  renderMoveButtons();
}

function renderMoveButtons() {
  const pm = playerTeam[playerActive];
  const em = enemyTeam[enemyActive];
  const grid = document.getElementById('move-grid');
  grid.innerHTML = '';

  for (let i = 0; i < pm.moves.length; i++) {
    const m = pm.moves[i];
    const eff = m.power > 0 ? getEffectiveness(m.element, em.element) : 1;
    const btn = document.createElement('button');
    btn.className = 'move-btn';
    btn.disabled = battleState !== 'playerTurn';
    let effBadge = '';
    if (m.power > 0 && eff >= 1.5) effBadge = '<span class="eff-badge super">SE!</span>';
    else if (m.power > 0 && eff <= 0.67) effBadge = '<span class="eff-badge nve">NVE</span>';
    btn.innerHTML = `
      <span class="type-dot" style="background:${ELEMENT_COLORS[m.element]}"></span>
      <span class="move-info">
        <span class="move-name">${m.name}</span>
        <span class="move-detail">${m.power > 0 ? 'Pow ' + m.power : 'Status'} / Acc ${m.accuracy}</span>
      </span>
      ${effBadge}
    `;
    btn.onclick = () => playerUseMove(i);
    grid.appendChild(btn);
  }
}

function updateHPBar(prefix, mon) {
  const ratio = mon.hp / mon.maxHp;
  const bar = document.getElementById(prefix + '-hp-bar');
  bar.style.width = (ratio * 100) + '%';
  bar.style.background = ratio > 0.5 ? '#4caf50' : ratio > 0.25 ? '#ffcc00' : '#ff4444';
  document.getElementById(prefix + '-hp-text').textContent = `${Math.max(0, mon.hp)} / ${mon.maxHp}`;
}

function renderStatuses(elId, mon) {
  const el = document.getElementById(elId);
  el.innerHTML = '';
  if (mon.stunned) {
    const span = document.createElement('span');
    span.className = 'status-icon';
    span.textContent = '\u26A1STUN';
    el.appendChild(span);
  }
  for (const stat in mon.buffs) {
    const b = mon.buffs[stat];
    const span = document.createElement('span');
    span.className = 'status-icon';
    span.style.color = b.amount > 0 ? '#4caf50' : '#ff4444';
    span.textContent = (b.amount > 0 ? '\u2191' : '\u2193') + stat.toUpperCase().slice(0, 3) + ' ' + b.turns;
    el.appendChild(span);
  }
}

function enableActions(enabled) {
  const panel = document.getElementById('action-panel');
  panel.style.pointerEvents = enabled ? 'auto' : 'none';
  panel.style.opacity = enabled ? '1' : '0.5';
}

// ═══════════════════════════════════════════
// BATTLE LOG
// ═══════════════════════════════════════════
function clearBattleLog() {
  document.getElementById('battle-log').innerHTML = '';
}

function addBattleLog(text, cls) {
  const el = document.getElementById('battle-log');
  const div = document.createElement('div');
  if (cls) div.className = cls;
  div.textContent = '> ' + text;
  el.appendChild(div);
  el.scrollTop = el.scrollHeight;
}

function addBattleLogEntries(entries) {
  for (const e of entries) addBattleLog(e.text, e.cls);
}

// ═══════════════════════════════════════════
// SWITCH PANEL
// ═══════════════════════════════════════════
let switchPanelOpen = false;

function toggleSwitchPanel() {
  switchPanelOpen = !switchPanelOpen;
  const panel = document.getElementById('switch-panel');
  if (switchPanelOpen) {
    panel.innerHTML = '';
    for (let i = 0; i < playerTeam.length; i++) {
      if (i === playerActive || playerTeam[i].hp <= 0) continue;
      const m = playerTeam[i];
      const opt = document.createElement('div');
      opt.className = 'switch-option';
      opt.innerHTML = `
        <span class="so-icon">${m.icon}</span>
        <span class="so-name">${m.name}</span>
        <span class="so-hp">${m.hp}/${m.maxHp} HP</span>
      `;
      opt.onclick = () => playerSwitch(i);
      panel.appendChild(opt);
    }
    panel.classList.add('visible');
  } else {
    panel.classList.remove('visible');
  }
}

function closeSwitchPanel() {
  switchPanelOpen = false;
  document.getElementById('switch-panel').classList.remove('visible');
}

// ═══════════════════════════════════════════
// PLAYER ACTIONS
// ═══════════════════════════════════════════
function playerUseMove(moveIdx) {
  if (battleState !== 'playerTurn') return;
  closeSwitchPanel();
  battleState = 'animating';
  enableActions(false);

  const pm = playerTeam[playerActive];
  const em = enemyTeam[enemyActive];
  const playerMove = pm.moves[moveIdx];

  // Determine turn order
  const playerPriority = playerMove.effect && playerMove.effect.type === 'priority';
  const aiAction = aiSelectAction(enemyTeam, enemyActive, pm);
  const enemyMove = aiAction && aiAction.type === 'move' ? em.moves[aiAction.index] : null;
  const enemyPriority = enemyMove && enemyMove.effect && enemyMove.effect.type === 'priority';

  let playerFirst;
  if (playerPriority && !enemyPriority) playerFirst = true;
  else if (!playerPriority && enemyPriority) playerFirst = false;
  else playerFirst = getEffSpd(pm) >= getEffSpd(em);

  // Execute turns
  executeTurnSequence(pm, em, playerMove, aiAction, playerFirst);
}

function playerSwitch(newIdx) {
  if (battleState !== 'playerTurn') return;
  closeSwitchPanel();
  battleState = 'animating';
  enableActions(false);

  const oldName = playerTeam[playerActive].name;
  playerActive = newIdx;
  addBattleLog(`${oldName} switched out for ${playerTeam[playerActive].name}!`, '');

  // Enemy still acts
  const em = enemyTeam[enemyActive];
  const aiAction = aiSelectAction(enemyTeam, enemyActive, playerTeam[playerActive]);

  setTimeout(async () => {
    if (aiAction && aiAction.type === 'move') animateAttack(false);
    executeEnemyAction(em, aiAction);
    renderBattle();
    await delay(600);
    if (playerTeam[playerActive].hp <= 0) { animateFaint(true); await delay(500); await handlePlayerFaint(); return; }
    afterBothTurns();
  }, 500);
  renderBattle();
}

async function executeTurnSequence(pm, em, playerMove, aiAction, playerFirst) {
  const first = playerFirst ? 'player' : 'enemy';
  const second = playerFirst ? 'enemy' : 'player';

  // First turn
  if (first === 'player') {
    if (pm.stunned) {
      addBattleLog(`${pm.name} is stunned and can't move!`, 'log-status');
      pm.stunned = false;
    } else {
      animateAttack(true);
      const result = executeMove(pm, em, playerMove);
      addBattleLogEntries(result.log);
      flashPanel('enemy-wrapper', result.damage > 0 ? 'red' : '');
    }
  } else {
    animateAttack(false);
    executeEnemyAction(em, aiAction);
  }

  renderBattle();
  await delay(600);

  // Check faints after first
  if (em.hp <= 0) { animateFaint(false); await delay(500); await handleEnemyFaint(); return; }
  if (pm.hp <= 0) { animateFaint(true); await delay(500); await handlePlayerFaint(); return; }

  // Second turn
  if (second === 'player') {
    if (pm.stunned) {
      addBattleLog(`${pm.name} is stunned and can't move!`, 'log-status');
      pm.stunned = false;
    } else {
      animateAttack(true);
      const result = executeMove(pm, em, playerMove);
      addBattleLogEntries(result.log);
      flashPanel('enemy-wrapper', result.damage > 0 ? 'red' : '');
    }
  } else {
    animateAttack(false);
    executeEnemyAction(em, aiAction);
  }

  renderBattle();
  await delay(600);

  if (em.hp <= 0) { animateFaint(false); await delay(500); await handleEnemyFaint(); return; }
  if (pm.hp <= 0) { animateFaint(true); await delay(500); await handlePlayerFaint(); return; }

  // Boss rage: second action if boss below 50% HP
  if (currentFloor >= TOTAL_FLOORS && em.hp < em.maxHp * 0.5 && em.hp > 0) {
    const rageAction = aiSelectAction(enemyTeam, enemyActive, playerTeam[playerActive]);
    addBattleLog(`${em.name} is enraged and attacks again!`, 'log-status');
    animateAttack(false);
    executeEnemyAction(em, rageAction);
    renderBattle();
    await delay(600);
    if (playerTeam[playerActive].hp <= 0) { animateFaint(true); await delay(500); await handlePlayerFaint(); return; }
  }

  afterBothTurns();
}

function executeEnemyAction(em, aiAction) {
  if (!aiAction) return;
  if (em.hp <= 0) return;

  if (aiAction.type === 'switch') {
    const oldName = em.name;
    enemyActive = aiAction.index;
    addBattleLog(`Enemy ${oldName} switched to ${enemyTeam[enemyActive].name}!`, '');
    return;
  }

  const pm = playerTeam[playerActive];
  if (em.stunned) {
    addBattleLog(`${em.name} is stunned and can't move!`, 'log-status');
    em.stunned = false;
    return;
  }

  const move = em.moves[aiAction.index];
  const result = executeMove(em, pm, move);
  addBattleLogEntries(result.log);
  if (result.damage > 0) flashPanel('player-wrapper', 'red');
}

async function afterBothTurns() {
  const pm = playerTeam[playerActive];
  const em = enemyTeam[enemyActive];

  // End of turn effects
  const pLog = applyEndOfTurnEffects(pm);
  const eLog = applyEndOfTurnEffects(em);
  addBattleLogEntries(pLog);
  addBattleLogEntries(eLog);

  renderBattle();
  await delay(300);

  if (em.hp <= 0) { await handleEnemyFaint(); return; }
  if (pm.hp <= 0) { await handlePlayerFaint(); return; }

  battleState = 'playerTurn';
  enableActions(true);
  renderBattle();
}

async function handleEnemyFaint() {
  const em = enemyTeam[enemyActive];
  addBattleLog(`${em.name} fainted!`, 'log-faint');
  SFX.faint();
  playerTeam[playerActive].kos++;
  enemiesDefeated++;

  // Add to collection
  const monsterKey = em.defKey || Object.keys(MONSTER_DEFS).find(k => MONSTER_DEFS[k].name === em.name) || (em.name === 'Chimera Rex' ? '_boss' : null);
  if (monsterKey) {
    const isNew = addToCollection(monsterKey);
    if (isNew) {
      addBattleLog(`${em.name} added to collection!`, 'log-heal');
      // Check collect all achievement
      const allKeys = [...Object.keys(MONSTER_DEFS), '_boss'];
      const c = loadCollection();
      if (allKeys.every(k => c.includes(k))) ggTry('bm_collect_all');
    }
  }

  renderBattle();
  await delay(800);

  // Next enemy?
  const nextEnemy = enemyTeam.findIndex((m, i) => i !== enemyActive && m.hp > 0);
  if (nextEnemy >= 0) {
    enemyActive = nextEnemy;
    addBattleLog(`Enemy sends out ${enemyTeam[enemyActive].name}!`, '');
    renderBattle();
    battleState = 'playerTurn';
    enableActions(true);
  } else {
    // Battle won!
    await handleBattleWin();
  }
}

async function handlePlayerFaint() {
  const pm = playerTeam[playerActive];
  addBattleLog(`${pm.name} fainted!`, 'log-faint');
  SFX.faint();
  renderBattle();
  await delay(800);

  const nextAlive = playerTeam.findIndex(m => m.hp > 0);
  if (nextAlive >= 0) {
    // Force switch
    battleState = 'playerTurn';
    showForceSwitch();
  } else {
    // All fainted — run over
    handleRunDefeat();
  }
}

function showForceSwitch() {
  enableActions(true);
  // Hide move grid, show only switch panel
  document.getElementById('move-grid').style.display = 'none';
  document.getElementById('switch-btn').style.display = 'none';
  const panel = document.getElementById('switch-panel');
  panel.innerHTML = '<div style="text-align:center;color:#ff4444;font-size:0.8rem;margin-bottom:6px">Choose next monster:</div>';
  for (let i = 0; i < playerTeam.length; i++) {
    if (playerTeam[i].hp <= 0) continue;
    const m = playerTeam[i];
    const opt = document.createElement('div');
    opt.className = 'switch-option';
    opt.innerHTML = `
      <span class="so-icon">${m.icon}</span>
      <span class="so-name">${m.name}</span>
      <span class="so-hp">${m.hp}/${m.maxHp} HP</span>
    `;
    opt.onclick = () => {
      playerActive = i;
      addBattleLog(`Go, ${playerTeam[i].name}!`, '');
      document.getElementById('move-grid').style.display = '';
      document.getElementById('switch-btn').style.display = '';
      closeSwitchPanel();
      battleState = 'playerTurn';
      enableActions(true);
      renderBattle();
    };
    panel.appendChild(opt);
  }
  panel.classList.add('visible');
}

async function handleBattleWin() {
  battlesWon++;
  const noLosses = playerTeam.every(m => m.hp > 0);
  if (noLosses) runSweeps++;

  addBattleLog('Battle won!', 'log-heal');

  // Achievements
  const stats = loadStats();
  if (stats.totalBattlesWon === 0 && battlesWon === 1) ggTry('bm_first_fight');
  if (noLosses) ggTry('bm_sweep');
  if (superEffectiveCount >= 5) ggTry('bm_super_eff_5');

  showBattleMsg('VICTORY!', '#4caf50');
  SFX.victory();
  await delay(1500);
  hideBattleMsg();

  if (currentFloor >= TOTAL_FLOORS) {
    handleRunVictory();
  } else {
    showRewardScreen();
  }
}

function handleRunDefeat() {
  const stats = loadStats();
  stats.totalRuns++;
  stats.bestFloor = Math.max(stats.bestFloor, currentFloor);
  stats.totalBattlesWon += battlesWon;
  stats.totalEnemiesDefeated += enemiesDefeated;
  saveStats(stats);

  SFX.defeat();
  document.getElementById('defeat-floor-text').textContent = `Your team was wiped out on Floor ${currentFloor}`;
  document.getElementById('defeat-stats').innerHTML = [
    ['Floors Cleared', currentFloor - 1],
    ['Enemies Defeated', enemiesDefeated],
    ['Battles Won', battlesWon],
  ].map(([k, v]) => `<div class="rs-row"><span>${k}</span><span>${v}</span></div>`).join('');

  showScreen('defeat-screen');
}

function handleRunVictory() {
  const stats = loadStats();
  stats.totalRuns++;
  stats.wins++;
  stats.bestFloor = TOTAL_FLOORS;
  stats.totalBattlesWon += battlesWon;
  stats.totalEnemiesDefeated += enemiesDefeated;
  saveStats(stats);

  ggTry('bm_floor_8');
  if (playerTeam.every(m => m.hp > 0)) ggTry('bm_full_team_win');
  if (healsTaken === 0) ggTry('bm_no_heal');
  if (stats.wins >= 3) ggTry('bm_3_wins');
  if (stats.wins >= 10) ggTry('bm_10_wins');

  SFX.victory();
  const totalHp = playerTeam.reduce((s, m) => s + m.hp, 0);
  const totalMaxHp = playerTeam.reduce((s, m) => s + m.maxHp, 0);
  document.getElementById('victory-stats').innerHTML = [
    ['Floors Cleared', TOTAL_FLOORS],
    ['Enemies Defeated', enemiesDefeated],
    ['Remaining HP', Math.round(totalHp / totalMaxHp * 100) + '%'],
    ['Total Wins', stats.wins],
  ].map(([k, v]) => `<div class="rs-row"><span>${k}</span><span>${v}</span></div>`).join('');

  showScreen('victory-screen');
}

// ═══════════════════════════════════════════
// BATTLE MSG
// ═══════════════════════════════════════════
function showBattleMsg(text, color) {
  const el = document.getElementById('battle-msg');
  el.textContent = text;
  el.style.color = color;
  el.style.display = 'block';
}

function hideBattleMsg() {
  document.getElementById('battle-msg').style.display = 'none';
}

function flashPanel(id, color) {
  const el = document.getElementById(id);
  if (!el) return;
  el.classList.remove('flash-red', 'flash-green');
  void el.offsetWidth;
  if (color === 'red') el.classList.add('flash-red');
  else if (color === 'green') el.classList.add('flash-green');
  setTimeout(() => el.classList.remove('flash-red', 'flash-green'), 300);
}

function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

// ═══════════════════════════════════════════
// REWARD SCREEN
// ═══════════════════════════════════════════
function showRewardScreen() {
  document.getElementById('reward-title').textContent = `FLOOR ${currentFloor} COMPLETE!`;
  const rewards = generateRewards();
  const container = document.getElementById('reward-cards');
  container.innerHTML = '';
  for (const r of rewards) {
    const card = document.createElement('div');
    card.className = 'reward-card';
    card.innerHTML = `
      <div class="rc-icon">${r.icon}</div>
      <div class="rc-name">${r.label}</div>
      <div class="rc-desc">${r.desc}</div>
    `;
    card.onclick = () => applyReward(r);
    container.appendChild(card);
  }
  showScreen('reward-screen');
  tryTutorialStep('reward');
}

function generateRewards() {
  let available = [...REWARD_TYPES];
  const rewards = [];
  const totalWeight = available.reduce((s, r) => s + r.weight, 0);

  while (rewards.length < 3 && available.length > 0) {
    let roll = Math.random() * totalWeight;
    for (const r of available) {
      roll -= r.weight;
      if (roll <= 0) {
        rewards.push(r);
        available = available.filter(x => x !== r);
        break;
      }
    }
  }
  return rewards;
}

function applyReward(reward) {
  SFX.select();

  switch (reward.type) {
    case 'atkBoost':
      for (const m of playerTeam) { m.atk = Math.floor(m.atk * 1.1); m.baseAtk = m.atk; }
      break;
    case 'defBoost':
      for (const m of playerTeam) { m.def = Math.floor(m.def * 1.1); m.baseDef = m.def; }
      break;
    case 'spdBoost':
      for (const m of playerTeam) { m.spd = Math.floor(m.spd * 1.1); m.baseSpd = m.spd; }
      break;
    case 'hpBoost':
      for (const m of playerTeam) { m.maxHp += 15; m.hp = Math.min(m.maxHp, m.hp + 15); }
      break;
    case 'newMove':
      showMoveTutor();
      return; // Don't proceed to next floor yet
  }

  nextFloor();
}

function nextFloor() {
  currentFloor++;
  // Full heal and clear statuses between floors
  for (const m of playerTeam) {
    m.hp = m.maxHp;
    m.statuses = [];
    m.buffs = {};
    m.stunned = false;
  }
  startBattle();
}

// ═══════════════════════════════════════════
// MOVE TUTOR
// ═══════════════════════════════════════════
let tutorMonIdx = -1;
let tutorMoveIdx = -1;
let tutorNewMove = null;

function showMoveTutor() {
  tutorMonIdx = -1;
  tutorMoveIdx = -1;
  tutorNewMove = LEARNABLE_MOVES[Math.floor(Math.random() * LEARNABLE_MOVES.length)];

  document.getElementById('tutor-sub').textContent = 'Pick a monster:';
  document.getElementById('tutor-replace-label').style.display = 'none';
  document.getElementById('tutor-moves').innerHTML = '';
  document.getElementById('tutor-confirm').style.display = 'none';
  document.getElementById('tutor-new-move').style.display = 'none';

  const container = document.getElementById('tutor-monsters');
  container.innerHTML = '';
  for (let i = 0; i < playerTeam.length; i++) {
    if (playerTeam[i].hp <= 0) continue;
    const m = playerTeam[i];
    const el = document.createElement('div');
    el.className = 'tutor-mon';
    el.innerHTML = `<div class="tm-icon">${m.icon}</div><div class="tm-name">${m.name}</div>`;
    el.onclick = () => selectTutorMon(i);
    container.appendChild(el);
  }

  // Show new move info
  const nmEl = document.getElementById('tutor-new-move');
  nmEl.style.display = '';
  nmEl.innerHTML = `
    <div>New move:</div>
    <div class="tnm-name">${tutorNewMove.name} <span style="color:${ELEMENT_COLORS[tutorNewMove.element]}">(${tutorNewMove.element})</span></div>
    <div class="tnm-detail">Power: ${tutorNewMove.power || 'Status'} / Accuracy: ${tutorNewMove.accuracy}</div>
  `;

  showScreen('tutor-screen');
}

function selectTutorMon(idx) {
  tutorMonIdx = idx;
  SFX.select();
  document.querySelectorAll('.tutor-mon').forEach((el, i) => {
    el.className = 'tutor-mon' + (i === idx ? ' selected' : '');
  });

  document.getElementById('tutor-sub').textContent = `Replace which move on ${playerTeam[idx].name}?`;
  document.getElementById('tutor-replace-label').style.display = '';
  const movesEl = document.getElementById('tutor-moves');
  movesEl.innerHTML = '';
  for (let i = 0; i < playerTeam[idx].moves.length; i++) {
    const m = playerTeam[idx].moves[i];
    const btn = document.createElement('button');
    btn.className = 'tutor-move-btn';
    btn.textContent = `${m.name} (${m.element})`;
    btn.onclick = () => selectTutorMove(i);
    movesEl.appendChild(btn);
  }
  document.getElementById('tutor-confirm').style.display = 'none';
}

function selectTutorMove(idx) {
  tutorMoveIdx = idx;
  SFX.select();
  document.getElementById('tutor-confirm').style.display = '';
}

function confirmTutor() {
  if (tutorMonIdx < 0 || tutorMoveIdx < 0 || !tutorNewMove) return;
  playerTeam[tutorMonIdx].moves[tutorMoveIdx] = {
    ...tutorNewMove,
    effect: tutorNewMove.effect ? { ...tutorNewMove.effect } : null,
  };
  SFX.buff();
  nextFloor();
}

function cancelTutor() {
  // Treat cancel as skipping the reward
  nextFloor();
}

// ═══════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════
showScreen('title-screen');
</script>
</body>
</html>
