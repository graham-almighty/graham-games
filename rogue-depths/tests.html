<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Rogue Depths - Unit Tests</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1a2e; color: #eee; font-family: 'Segoe UI', monospace; padding: 20px; }
  h1 { color: #8b5e3c; margin-bottom: 4px; }
  .summary { color: #aaa; margin-bottom: 20px; font-size: 0.9rem; }
  .pass { color: #4caf50; }
  .fail { color: #ff4444; }
  .group-title { color: #8b5e3c; font-size: 1.1rem; margin: 16px 0 6px; border-bottom: 1px solid #333; padding-bottom: 4px; }
  .test { padding: 4px 12px; font-size: 0.85rem; border-left: 3px solid transparent; margin: 2px 0; }
  .test.pass { border-left-color: #4caf50; }
  .test.fail { border-left-color: #ff4444; background: #ff444411; }
  .test .label { display: inline; }
  .test .detail { color: #888; font-size: 0.75rem; margin-left: 8px; }
  #results { max-width: 800px; }
</style>
</head>
<body>
<h1>Rogue Depths - Unit Tests</h1>
<div class="summary" id="summary"></div>
<div id="results"></div>

<script>
// ============================================================
// MINI TEST FRAMEWORK
// ============================================================
let _passed = 0, _failed = 0;
const _results = document.getElementById('results');

function group(name) {
  const h = document.createElement('div');
  h.className = 'group-title';
  h.textContent = name;
  _results.appendChild(h);
}

function assert(condition, name, detail) {
  const div = document.createElement('div');
  if (condition) {
    _passed++;
    div.className = 'test pass';
    div.innerHTML = '<span class="label">PASS</span> ' + name;
  } else {
    _failed++;
    div.className = 'test fail';
    div.innerHTML = '<span class="label">FAIL</span> ' + name + (detail ? '<span class="detail">(' + detail + ')</span>' : '');
  }
  _results.appendChild(div);
}

function assertEqual(actual, expected, name) {
  const pass = actual === expected;
  assert(pass, name, pass ? '' : 'expected ' + JSON.stringify(expected) + ', got ' + JSON.stringify(actual));
}

function assertApprox(actual, expected, tolerance, name) {
  const pass = Math.abs(actual - expected) <= tolerance;
  assert(pass, name, pass ? '' : 'expected ~' + expected + ' (±' + tolerance + '), got ' + actual);
}

function showSummary() {
  const el = document.getElementById('summary');
  el.innerHTML = '<span class="pass">' + _passed + ' passed</span> · <span class="' + (_failed ? 'fail' : 'pass') + '">' + _failed + ' failed</span>';
}

// ============================================================
// MOCK LOCALSTORAGE
// ============================================================
const localStorage = {
  _data: {},
  getItem(k) { return this._data[k] || null; },
  setItem(k, v) { this._data[k] = String(v); },
  removeItem(k) { delete this._data[k]; },
  clear() { this._data = {}; },
};

// ============================================================
// EXTRACTED SOURCE CODE (Constants & Functions)
// ============================================================
const GG_KEY = 'graham-games-data';
function ggLoad() {
  try { return JSON.parse(localStorage.getItem(GG_KEY)) || { gBux: 0, achievements: {}, shopPurchases: {} }; }
  catch(e) { return { gBux: 0, achievements: {}, shopPurchases: {} }; }
}
function ggSave(data) { localStorage.setItem(GG_KEY, JSON.stringify(data)); }
function ggUnlockAchievement(id, name, reward) {
  const data = ggLoad();
  if (data.achievements[id]) return false;
  data.achievements[id] = true;
  data.gBux += reward;
  ggSave(data);
  return true;
}

const RD_ACH = {
  rd_first_blood:   { name: 'First Blood',     reward: 5 },
  rd_floor_5:       { name: 'Into the Deep',    reward: 10 },
  rd_floor_10:      { name: 'Almost There',     reward: 20 },
  rd_floor_15:      { name: 'Rock Bottom',      reward: 30 },
  rd_boss_slayer:   { name: 'Boss Slayer',       reward: 15 },
  rd_dragon_slayer: { name: 'Dragon Slayer',     reward: 50 },
  rd_rare_find:     { name: 'Rare Find',         reward: 10 },
  rd_hoarder:       { name: 'Gold Hoarder',      reward: 15 },
  rd_speedrun:      { name: 'Speed Runner',      reward: 20 },
  rd_no_hit_boss:   { name: 'Untouchable',       reward: 25 },
};
function ggTry(id) { const a = RD_ACH[id]; if (a) ggUnlockAchievement(id, a.name, a.reward); }

const TILE = 32;
const MAP_W = 30;
const MAP_H = 30;
const MAX_FLOORS = 15;
const BOSS_FLOORS = [5, 10, 15];

const TILE_WALL = 0;
const TILE_FLOOR = 1;
const TILE_CORRIDOR = 2;
const TILE_STAIRS = 3;
const TILE_CHEST = 4;

const CLASS_DEFS = {
  warrior: { name: 'Warrior', hp: 150, speed: 2.5, color: '#4488ff', startWeapon: 'sword', desc: 'High HP, melee specialist', icon: '\u2694\uFE0F' },
  archer:  { name: 'Archer',  hp: 100, speed: 3.0, color: '#44bb44', startWeapon: 'bow',   desc: 'Ranged attacks, moderate HP', icon: '\uD83C\uDFF9' },
  mage:    { name: 'Mage',    hp: 80,  speed: 2.8, color: '#aa44ff', startWeapon: 'staff', desc: 'Magic projectiles, low HP', icon: '\uD83E\uDE84' },
  rogue:   { name: 'Rogue',   hp: 90,  speed: 3.5, color: '#ff8844', startWeapon: 'scythe', desc: 'Fast, backstab bonus', icon: '\uD83D\uDDE1\uFE0F', shopUnlock: 'rd_shadow_class' },
};

const WEAPON_DEFS = {
  sword:  { name: 'Sword',  type: 'melee',  baseDmg: 12, range: 1.5, cooldown: 0.5,  arc: 90,  color: '#cccccc' },
  axe:    { name: 'Axe',    type: 'melee',  baseDmg: 20, range: 1.3, cooldown: 0.9,  arc: 120, color: '#888888' },
  scythe: { name: 'Scythe', type: 'melee',  baseDmg: 9,  range: 2.8, cooldown: 0.4,  arc: 110, color: '#b0b0cc' },
  spear:  { name: 'Spear',  type: 'melee',  baseDmg: 14, range: 2.0, cooldown: 0.65, arc: 45,  color: '#bbaa77' },
  bow:    { name: 'Bow',    type: 'ranged', baseDmg: 10, range: 8,   cooldown: 0.6,  projSpeed: 8, color: '#886633' },
  staff:  { name: 'Staff',  type: 'ranged', baseDmg: 14, range: 7,   cooldown: 0.8,  projSpeed: 6, color: '#9944ff', pierce: true },
};

const RARITIES = [
  { name: 'Common',   color: '#aaaaaa', multiplier: 1.0 },
  { name: 'Uncommon', color: '#44cc44', multiplier: 1.3 },
  { name: 'Rare',     color: '#4488ff', multiplier: 1.6 },
  { name: 'Epic',     color: '#aa44ff', multiplier: 2.0 },
];

const ENEMY_DEFS = {
  rat:          { name: 'Rat',           hp: 15,  speed: 2.5, damage: 5,   gold: 3,  minFloor: 1,  radius: 6,  color: '#8d6e63', ai: 'chase', atkCd: 1.0 },
  skeleton:     { name: 'Skeleton',      hp: 30,  speed: 1.5, damage: 10,  gold: 5,  minFloor: 1,  radius: 8,  color: '#e0e0e0', ai: 'chase', atkCd: 1.2 },
  bat:          { name: 'Bat',           hp: 20,  speed: 3.0, damage: 7,   gold: 4,  minFloor: 2,  radius: 5,  color: '#555577', ai: 'zigzag', atkCd: 0.8 },
  slime:        { name: 'Slime',         hp: 60,  speed: 0.8, damage: 8,   gold: 6,  minFloor: 3,  radius: 10, color: '#44cc44', ai: 'chase', atkCd: 1.5, splits: true },
  goblinArcher: { name: 'Goblin Archer', hp: 25,  speed: 1.2, damage: 12,  gold: 7,  minFloor: 4,  radius: 7,  color: '#669933', ai: 'ranged', atkCd: 1.8, range: 6 },
  darkKnight:   { name: 'Dark Knight',   hp: 100, speed: 0.7, damage: 20,  gold: 12, minFloor: 7,  radius: 10, color: '#333355', ai: 'chase', atkCd: 1.4 },
  wraith:       { name: 'Wraith',        hp: 40,  speed: 1.8, damage: 15,  gold: 10, minFloor: 9,  radius: 8,  color: '#8866aa', ai: 'phase', atkCd: 1.0 },
  fireImp:      { name: 'Fire Imp',      hp: 35,  speed: 1.5, damage: 18,  gold: 9,  minFloor: 11, radius: 7,  color: '#ff4400', ai: 'ranged', atkCd: 2.0, range: 5 },
};

const BOSS_DEFS = {
  spiderQueen: { name: 'Spider Queen',  floor: 5,  hp: 400,  speed: 1.0, damage: 15, gold: 50,  radius: 16, color: '#442244', ability: 'spawn', interval: 4 },
  lich:        { name: 'The Lich',      floor: 10, hp: 600,  speed: 0.8, damage: 20, gold: 80,  radius: 14, color: '#6644aa', ability: 'lich', interval: 5 },
  dragon:      { name: 'Ancient Dragon', floor: 15, hp: 1000, speed: 1.2, damage: 30, gold: 150, radius: 20, color: '#cc2200', ability: 'dragon', interval: 6 },
};

const POTION_DEFS = [
  { name: 'Small Potion',  heal: 25,  color: '#ff4444', icon: '\uD83E\uDDEA', weight: 10 },
  { name: 'Medium Potion', heal: 50,  color: '#ff6644', icon: '\uD83E\uDDEA', weight: 5 },
  { name: 'Large Potion',  heal: 100, color: '#ff8844', icon: '\uD83E\uDDEA', weight: 2 },
];

const SHOP_ITEMS = [
  { id: 'small_potion', name: 'Small Potion', desc: 'Restores 25 HP', price: 25, icon: '\uD83E\uDDEA', type: 'potion', heal: 25 },
  { id: 'large_potion', name: 'Large Potion', desc: 'Restores 100 HP', price: 50, icon: '\uD83E\uDDEA', type: 'potion', heal: 100 },
];

// Extracted functions
function getFloorEnemyTypes(floor) {
  return Object.entries(ENEMY_DEFS).filter(([k, v]) => floor >= v.minFloor).map(([k]) => k);
}
function getFloorEnemyCount(floor) {
  return 8 + Math.floor(floor * 1.5);
}
function getFloorHPScale(floor) {
  return 1 + (floor - 1) * 0.15;
}
function getFloorDmgScale(floor) {
  return 1 + (floor - 1) * 0.1;
}

function makeWeapon(floor, forceRarity) {
  const types = Object.keys(WEAPON_DEFS);
  const base = types[Math.floor(Math.random() * types.length)];
  const def = WEAPON_DEFS[base];
  let rarity;
  if (forceRarity !== undefined) {
    rarity = forceRarity;
  } else {
    const r = Math.random() * 100;
    const rareBonus = floor * 2;
    if (r < 2 + rareBonus * 0.3) rarity = 3;
    else if (r < 10 + rareBonus) rarity = 2;
    else if (r < 35 + rareBonus * 1.5) rarity = 1;
    else rarity = 0;
  }
  const rar = RARITIES[rarity];
  return {
    base, rarity, type: 'weapon',
    damage: Math.round(def.baseDmg * rar.multiplier),
    name: rar.name + ' ' + def.name, color: rar.color,
  };
}

function makePotion() {
  const totalWeight = POTION_DEFS.reduce((s, p) => s + p.weight, 0);
  let r = Math.random() * totalWeight;
  for (const p of POTION_DEFS) {
    r -= p.weight;
    if (r <= 0) return { type: 'potion', name: p.name, heal: p.heal, color: p.color, icon: p.icon };
  }
  return { type: 'potion', ...POTION_DEFS[0] };
}

function makeArmor(floor) {
  const defense = 5 + Math.floor(Math.random() * Math.min(floor, 5)) * 2;
  return { type: 'armor', name: 'Armor +' + defense + '%', defense, color: '#8888aa', icon: '\uD83D\uDEE1\uFE0F' };
}

// Dungeon generation (extracted)
function generateDungeon(floor) {
  const tiles = [];
  for (let y = 0; y < MAP_H; y++) {
    tiles[y] = [];
    for (let x = 0; x < MAP_W; x++) tiles[y][x] = TILE_WALL;
  }
  const rooms = [];
  const numRooms = 4 + Math.min(Math.floor(floor * 0.2), 3);
  let attempts = 0;
  while (rooms.length < numRooms && attempts < 200) {
    attempts++;
    const w = 4 + Math.floor(Math.random() * 5);
    const h = 4 + Math.floor(Math.random() * 4);
    const rx = 1 + Math.floor(Math.random() * (MAP_W - w - 2));
    const ry = 1 + Math.floor(Math.random() * (MAP_H - h - 2));
    let overlap = false;
    for (const r of rooms) {
      if (rx - 1 < r.x + r.w && rx + w + 1 > r.x && ry - 1 < r.y + r.h && ry + h + 1 > r.y) {
        overlap = true; break;
      }
    }
    if (overlap) continue;
    for (let y = ry; y < ry + h; y++)
      for (let x = rx; x < rx + w; x++)
        tiles[y][x] = TILE_FLOOR;
    rooms.push({ x: rx, y: ry, w, h, cx: Math.floor(rx + w / 2), cy: Math.floor(ry + h / 2), revealed: false });
  }
  if (rooms.length < 3) return generateDungeon(floor);

  for (let i = 1; i < rooms.length; i++) {
    const a = rooms[i - 1], b = rooms[i];
    carveCorridor(tiles, a.cx, a.cy, b.cx, b.cy);
  }
  if (rooms.length > 2) {
    const first = rooms[0], last = rooms[rooms.length - 1];
    carveCorridor(tiles, last.cx, last.cy, first.cx, first.cy);
  }

  rooms[0].type = 'start';
  let maxDist = 0, stairsIdx = 1;
  for (let i = 1; i < rooms.length; i++) {
    const d = Math.abs(rooms[i].cx - rooms[0].cx) + Math.abs(rooms[i].cy - rooms[0].cy);
    if (d > maxDist) { maxDist = d; stairsIdx = i; }
  }
  rooms[stairsIdx].type = 'stairs';
  for (let i = 1; i < rooms.length; i++) {
    if (rooms[i].type) continue;
    const r = Math.random();
    rooms[i].type = r < 0.6 ? 'enemy' : (r < 0.8 ? 'treasure' : 'empty');
  }
  const sr = rooms[stairsIdx];
  const isBossFloor = BOSS_FLOORS.includes(floor);
  if (!isBossFloor) tiles[sr.cy][sr.cx] = TILE_STAIRS;
  for (const room of rooms) {
    if (room.type === 'treasure') {
      const cx = room.x + 1 + Math.floor(Math.random() * (room.w - 2));
      const cy = room.y + 1 + Math.floor(Math.random() * (room.h - 2));
      tiles[cy][cx] = TILE_CHEST;
    }
  }
  return { tiles, rooms, stairsRoom: sr, startRoom: rooms[0], isBossFloor, floor };
}

function carveCorridor(tiles, x1, y1, x2, y2) {
  if (Math.random() < 0.5) { carveH(tiles, x1, x2, y1); carveV(tiles, y1, y2, x2); }
  else { carveV(tiles, y1, y2, x1); carveH(tiles, x1, x2, y2); }
}
function carveH(tiles, x1, x2, y) {
  const minX = Math.min(x1, x2), maxX = Math.max(x1, x2);
  for (let x = minX; x <= maxX; x++) {
    if (y >= 0 && y < MAP_H && x >= 0 && x < MAP_W && tiles[y][x] === TILE_WALL) tiles[y][x] = TILE_CORRIDOR;
  }
}
function carveV(tiles, y1, y2, x) {
  const minY = Math.min(y1, y2), maxY = Math.max(y1, y2);
  for (let y = minY; y <= maxY; y++) {
    if (y >= 0 && y < MAP_H && x >= 0 && x < MAP_W && tiles[y][x] === TILE_WALL) tiles[y][x] = TILE_CORRIDOR;
  }
}

// Damage formula
function calcDamage(rawDmg, defense) {
  return Math.max(1, rawDmg - Math.floor(rawDmg * defense / 100));
}

// ============================================================
// TESTS
// ============================================================

// ─── ACHIEVEMENT REGISTRY ───
group('Achievement Registry');

{
  const keys = Object.keys(RD_ACH);
  assertEqual(keys.length, 10, 'RD_ACH has 10 achievements');
}

{
  let total = 0;
  for (const a of Object.values(RD_ACH)) total += a.reward;
  assertEqual(total, 200, 'Total achievement rewards = 200 G Bux');
}

{
  for (const [id, a] of Object.entries(RD_ACH)) {
    assert(a.name && a.name.length > 0, 'Achievement ' + id + ' has a name');
    assert(a.reward > 0, 'Achievement ' + id + ' has positive reward (' + a.reward + ')');
  }
}

{
  // Specific rewards
  assertEqual(RD_ACH.rd_first_blood.reward, 5, 'First Blood = 5G');
  assertEqual(RD_ACH.rd_floor_5.reward, 10, 'Into the Deep = 10G');
  assertEqual(RD_ACH.rd_floor_10.reward, 20, 'Almost There = 20G');
  assertEqual(RD_ACH.rd_floor_15.reward, 30, 'Rock Bottom = 30G');
  assertEqual(RD_ACH.rd_boss_slayer.reward, 15, 'Boss Slayer = 15G');
  assertEqual(RD_ACH.rd_dragon_slayer.reward, 50, 'Dragon Slayer = 50G');
  assertEqual(RD_ACH.rd_rare_find.reward, 10, 'Rare Find = 10G');
  assertEqual(RD_ACH.rd_hoarder.reward, 15, 'Gold Hoarder = 15G');
  assertEqual(RD_ACH.rd_speedrun.reward, 20, 'Speed Runner = 20G');
  assertEqual(RD_ACH.rd_no_hit_boss.reward, 25, 'Untouchable = 25G');
}

localStorage.clear();
{
  // Unlock awards correct G Bux
  ggTry('rd_first_blood');
  const data = ggLoad();
  assertEqual(data.gBux, 5, 'Unlocking First Blood awards 5 G Bux');
  assertEqual(data.achievements.rd_first_blood, true, 'Achievement marked as earned');
}

{
  // Duplicate prevention
  ggTry('rd_first_blood');
  const data = ggLoad();
  assertEqual(data.gBux, 5, 'Duplicate unlock does not award extra G Bux');
}

localStorage.clear();
{
  // Unlock all = 200G
  for (const id of Object.keys(RD_ACH)) ggTry(id);
  const data = ggLoad();
  assertEqual(data.gBux, 200, 'Unlocking all achievements = 200 G Bux');
}

// ─── CLASS DEFINITIONS ───
group('Class Definitions');

{
  const keys = Object.keys(CLASS_DEFS);
  assertEqual(keys.length, 4, '4 classes defined');
  assert(keys.includes('warrior'), 'Warrior class exists');
  assert(keys.includes('archer'), 'Archer class exists');
  assert(keys.includes('mage'), 'Mage class exists');
  assert(keys.includes('rogue'), 'Rogue class exists');
}

{
  for (const [key, def] of Object.entries(CLASS_DEFS)) {
    assert(def.name, key + ' has name');
    assert(def.hp > 0, key + ' has positive HP');
    assert(def.speed > 0, key + ' has positive speed');
    assert(def.color, key + ' has color');
    assert(def.startWeapon, key + ' has startWeapon');
    assert(WEAPON_DEFS[def.startWeapon], key + ' startWeapon "' + def.startWeapon + '" exists in WEAPON_DEFS');
    assert(def.desc, key + ' has description');
  }
}

{
  assertEqual(CLASS_DEFS.warrior.hp, 150, 'Warrior HP = 150');
  assertEqual(CLASS_DEFS.archer.hp, 100, 'Archer HP = 100');
  assertEqual(CLASS_DEFS.mage.hp, 80, 'Mage HP = 80');
  assertEqual(CLASS_DEFS.rogue.hp, 90, 'Rogue HP = 90');
}

{
  assert(CLASS_DEFS.warrior.speed < CLASS_DEFS.archer.speed, 'Warrior slower than Archer');
  assert(CLASS_DEFS.archer.speed < CLASS_DEFS.rogue.speed, 'Archer slower than Rogue');
}

{
  assertEqual(CLASS_DEFS.rogue.shopUnlock, 'rd_shadow_class', 'Rogue requires rd_shadow_class shop unlock');
  assert(!CLASS_DEFS.warrior.shopUnlock, 'Warrior has no shop unlock requirement');
  assert(!CLASS_DEFS.archer.shopUnlock, 'Archer has no shop unlock requirement');
  assert(!CLASS_DEFS.mage.shopUnlock, 'Mage has no shop unlock requirement');
}

// ─── WEAPON DEFINITIONS ───
group('Weapon Definitions');

{
  const keys = Object.keys(WEAPON_DEFS);
  assertEqual(keys.length, 6, '6 weapon types defined');
}

{
  for (const [key, def] of Object.entries(WEAPON_DEFS)) {
    assert(def.name, key + ' has name');
    assert(def.type === 'melee' || def.type === 'ranged', key + ' type is melee or ranged');
    assert(def.baseDmg > 0, key + ' has positive baseDmg');
    assert(def.range > 0, key + ' has positive range');
    assert(def.cooldown > 0, key + ' has positive cooldown');
    assert(def.color, key + ' has color');
    if (def.type === 'melee') assert(def.arc > 0, key + ' (melee) has arc');
    if (def.type === 'ranged') assert(def.projSpeed > 0, key + ' (ranged) has projSpeed');
  }
}

{
  assertEqual(WEAPON_DEFS.sword.baseDmg, 12, 'Sword baseDmg = 12');
  assertEqual(WEAPON_DEFS.axe.baseDmg, 20, 'Axe baseDmg = 20');
  assertEqual(WEAPON_DEFS.scythe.baseDmg, 9, 'Scythe baseDmg = 9');
  assertEqual(WEAPON_DEFS.bow.range, 8, 'Bow range = 8');
  assertEqual(WEAPON_DEFS.staff.pierce, true, 'Staff has pierce');
}

{
  assertEqual(RARITIES.length, 4, '4 rarities defined');
  assertEqual(RARITIES[0].multiplier, 1.0, 'Common multiplier = 1.0');
  assertEqual(RARITIES[1].multiplier, 1.3, 'Uncommon multiplier = 1.3');
  assertEqual(RARITIES[2].multiplier, 1.6, 'Rare multiplier = 1.6');
  assertEqual(RARITIES[3].multiplier, 2.0, 'Epic multiplier = 2.0');
  // Ascending
  for (let i = 1; i < RARITIES.length; i++) {
    assert(RARITIES[i].multiplier > RARITIES[i-1].multiplier, 'Rarity multiplier ascending at index ' + i);
  }
}

{
  // Damage computation
  const swordCommon = Math.round(WEAPON_DEFS.sword.baseDmg * RARITIES[0].multiplier);
  assertEqual(swordCommon, 12, 'Common Sword damage = 12');
  const swordEpic = Math.round(WEAPON_DEFS.sword.baseDmg * RARITIES[3].multiplier);
  assertEqual(swordEpic, 24, 'Epic Sword damage = 24');
  const axeRare = Math.round(WEAPON_DEFS.axe.baseDmg * RARITIES[2].multiplier);
  assertEqual(axeRare, 32, 'Rare Axe damage = 32');
}

// ─── ENEMY DEFINITIONS ───
group('Enemy Definitions');

{
  const keys = Object.keys(ENEMY_DEFS);
  assertEqual(keys.length, 8, '8 enemy types defined');
}

{
  for (const [key, def] of Object.entries(ENEMY_DEFS)) {
    assert(def.name, key + ' has name');
    assert(def.hp > 0, key + ' has positive HP');
    assert(def.speed > 0, key + ' has positive speed');
    assert(def.damage > 0, key + ' has positive damage');
    assert(def.gold > 0, key + ' has positive gold');
    assert(def.minFloor >= 1, key + ' minFloor >= 1');
    assert(def.radius > 0, key + ' has positive radius');
    assert(def.color, key + ' has color');
    assert(def.ai, key + ' has AI type');
    assert(def.atkCd > 0, key + ' has positive attack cooldown');
  }
}

{
  assertEqual(ENEMY_DEFS.slime.splits, true, 'Slime has splits flag');
  assertEqual(ENEMY_DEFS.wraith.ai, 'phase', 'Wraith has phase AI');
  assertEqual(ENEMY_DEFS.goblinArcher.ai, 'ranged', 'Goblin Archer has ranged AI');
  assertEqual(ENEMY_DEFS.fireImp.ai, 'ranged', 'Fire Imp has ranged AI');
  assert(ENEMY_DEFS.goblinArcher.range > 0, 'Goblin Archer has range property');
  assert(ENEMY_DEFS.fireImp.range > 0, 'Fire Imp has range property');
}

{
  const bossKeys = Object.keys(BOSS_DEFS);
  assertEqual(bossKeys.length, 3, '3 boss types defined');
  assertEqual(BOSS_DEFS.spiderQueen.floor, 5, 'Spider Queen on floor 5');
  assertEqual(BOSS_DEFS.lich.floor, 10, 'Lich on floor 10');
  assertEqual(BOSS_DEFS.dragon.floor, 15, 'Dragon on floor 15');
}

{
  for (const [key, def] of Object.entries(BOSS_DEFS)) {
    assert(def.name, key + ' has name');
    assert(def.hp > 0, key + ' has positive HP');
    assert(def.speed > 0, key + ' has positive speed');
    assert(def.damage > 0, key + ' has positive damage');
    assert(def.gold > 0, key + ' has positive gold');
    assert(def.radius > 0, key + ' has positive radius');
    assert(def.ability, key + ' has ability');
    assert(def.interval > 0, key + ' has positive ability interval');
  }
}

{
  assertEqual(BOSS_DEFS.spiderQueen.hp, 400, 'Spider Queen HP = 400');
  assertEqual(BOSS_DEFS.lich.hp, 600, 'Lich HP = 600');
  assertEqual(BOSS_DEFS.dragon.hp, 1000, 'Dragon HP = 1000');
  assertEqual(BOSS_DEFS.spiderQueen.interval, 4, 'Spider Queen spawn interval = 4s');
  assertEqual(BOSS_DEFS.lich.interval, 5, 'Lich teleport interval = 5s');
  assertEqual(BOSS_DEFS.dragon.interval, 6, 'Dragon ability interval = 6s');
}

// ─── FLOOR SCALING ───
group('Floor Scaling');

{
  assertEqual(getFloorHPScale(1), 1.0, 'Floor 1 HP scale = 1.0');
  assertApprox(getFloorHPScale(8), 2.05, 0.01, 'Floor 8 HP scale ~ 2.05');
  assertApprox(getFloorHPScale(15), 3.1, 0.01, 'Floor 15 HP scale ~ 3.1');
}

{
  assertEqual(getFloorDmgScale(1), 1.0, 'Floor 1 damage scale = 1.0');
  assertApprox(getFloorDmgScale(8), 1.7, 0.01, 'Floor 8 damage scale ~ 1.7');
  assertApprox(getFloorDmgScale(15), 2.4, 0.01, 'Floor 15 damage scale ~ 2.4');
}

{
  assertEqual(getFloorEnemyCount(1), 9, 'Floor 1 enemy count = 9');
  assertEqual(getFloorEnemyCount(10), 23, 'Floor 10 enemy count = 23');
  assertEqual(getFloorEnemyCount(15), 30, 'Floor 15 enemy count = 30');
}

{
  const f1Types = getFloorEnemyTypes(1);
  assert(f1Types.includes('rat'), 'Floor 1 has rats');
  assert(f1Types.includes('skeleton'), 'Floor 1 has skeletons');
  assert(!f1Types.includes('bat'), 'Floor 1 does NOT have bats');
  assert(!f1Types.includes('fireImp'), 'Floor 1 does NOT have fire imps');
}

{
  const f4Types = getFloorEnemyTypes(4);
  assert(f4Types.includes('goblinArcher'), 'Floor 4 has goblin archers');
  assert(!f4Types.includes('darkKnight'), 'Floor 4 does NOT have dark knights');
}

{
  const f15Types = getFloorEnemyTypes(15);
  assertEqual(f15Types.length, 8, 'Floor 15 has all 8 enemy types');
}

// ─── DUNGEON GENERATION ───
group('Dungeon Generation');

{
  const d = generateDungeon(1);
  assertEqual(d.tiles.length, MAP_H, 'Map height = 30');
  assertEqual(d.tiles[0].length, MAP_W, 'Map width = 30');
}

{
  const d = generateDungeon(1);
  assert(d.rooms.length >= 3, 'At least 3 rooms generated (got ' + d.rooms.length + ')');
  assert(d.rooms.length <= 10, 'No more than 10 rooms (got ' + d.rooms.length + ')');
}

{
  const d = generateDungeon(1);
  for (const room of d.rooms) {
    assert(room.x >= 1, 'Room x >= 1 (got ' + room.x + ')');
    assert(room.y >= 1, 'Room y >= 1 (got ' + room.y + ')');
    assert(room.x + room.w < MAP_W, 'Room fits in width (x+w=' + (room.x + room.w) + ')');
    assert(room.y + room.h < MAP_H, 'Room fits in height (y+h=' + (room.y + room.h) + ')');
  }
}

{
  const d = generateDungeon(1);
  assertEqual(d.startRoom.type, 'start', 'First room is start type');
  assertEqual(d.stairsRoom.type, 'stairs', 'Stairs room has stairs type');
  assert(d.startRoom !== d.stairsRoom, 'Start and stairs are different rooms');
}

{
  const d = generateDungeon(1);
  // All rooms should have a type
  for (const room of d.rooms) {
    assert(['start', 'stairs', 'enemy', 'treasure', 'empty'].includes(room.type),
      'Room type is valid: ' + room.type);
  }
}

{
  // Non-boss floor has stairs tile
  const d = generateDungeon(1);
  assertEqual(d.tiles[d.stairsRoom.cy][d.stairsRoom.cx], TILE_STAIRS, 'Floor 1 has stairs tile at stairs room center');
}

{
  // Boss floor does NOT have stairs tile initially
  const d = generateDungeon(5);
  assert(d.isBossFloor, 'Floor 5 is a boss floor');
  assert(d.tiles[d.stairsRoom.cy][d.stairsRoom.cx] !== TILE_STAIRS, 'Boss floor stairs room does NOT have stairs initially');
}

{
  // Connectivity: BFS from start room should reach stairs room
  const d = generateDungeon(1);
  const visited = {};
  const queue = [d.startRoom.cx + ',' + d.startRoom.cy];
  visited[queue[0]] = true;
  while (queue.length > 0) {
    const [cx, cy] = queue.shift().split(',').map(Number);
    const dirs = [[0,1],[0,-1],[1,0],[-1,0]];
    for (const [ddx, ddy] of dirs) {
      const nx = cx + ddx, ny = cy + ddy;
      const key = nx + ',' + ny;
      if (nx >= 0 && nx < MAP_W && ny >= 0 && ny < MAP_H && !visited[key] && d.tiles[ny][nx] !== TILE_WALL) {
        visited[key] = true;
        queue.push(key);
      }
    }
  }
  const stairsKey = d.stairsRoom.cx + ',' + d.stairsRoom.cy;
  assert(visited[stairsKey], 'Stairs room is reachable from start room via BFS');
}

{
  // Rooms have revealed=false initially
  const d = generateDungeon(1);
  for (const room of d.rooms) {
    assertEqual(room.revealed, false, 'Room at (' + room.x + ',' + room.y + ') starts unrevealed');
  }
}

{
  // Treasure rooms have at least one chest
  const d = generateDungeon(3);
  const treasureRooms = d.rooms.filter(r => r.type === 'treasure');
  for (const room of treasureRooms) {
    let hasChest = false;
    for (let y = room.y; y < room.y + room.h; y++) {
      for (let x = room.x; x < room.x + room.w; x++) {
        if (d.tiles[y][x] === TILE_CHEST) hasChest = true;
      }
    }
    assert(hasChest, 'Treasure room at (' + room.x + ',' + room.y + ') has a chest');
  }
}

// ─── LOOT SYSTEM ───
group('Loot System');

{
  const w = makeWeapon(1, 0); // Force common
  assertEqual(w.rarity, 0, 'Forced common weapon has rarity 0');
  assertEqual(w.type, 'weapon', 'makeWeapon returns type=weapon');
  assert(w.damage > 0, 'Weapon has positive damage');
  assert(w.name.startsWith('Common'), 'Common weapon name starts with Common');
}

{
  const w = makeWeapon(1, 3); // Force epic
  assertEqual(w.rarity, 3, 'Forced epic weapon has rarity 3');
  assert(w.name.startsWith('Epic'), 'Epic weapon name starts with Epic');
  // Epic should have 2x base damage
  const baseDmg = WEAPON_DEFS[w.base].baseDmg;
  assertEqual(w.damage, Math.round(baseDmg * 2.0), 'Epic weapon damage = baseDmg * 2.0');
}

{
  const p = makePotion();
  assertEqual(p.type, 'potion', 'makePotion returns type=potion');
  assert(p.heal > 0, 'Potion has positive heal');
  assert(p.name, 'Potion has name');
  assert([25, 50, 100].includes(p.heal), 'Potion heal is 25, 50, or 100');
}

{
  const a = makeArmor(1);
  assertEqual(a.type, 'armor', 'makeArmor returns type=armor');
  assert(a.defense >= 5, 'Armor defense >= 5');
}

{
  // Defense cap
  let defense = 0;
  for (let i = 0; i < 20; i++) {
    defense = Math.min(50, defense + 5);
  }
  assertEqual(defense, 50, 'Defense caps at 50%');
}

// ─── COMBAT FORMULAS ───
group('Combat Formulas');

{
  assertEqual(calcDamage(10, 0), 10, '10 dmg with 0 defense = 10');
  assertEqual(calcDamage(10, 50), 5, '10 dmg with 50% defense = 5');
  assertEqual(calcDamage(10, 100), 1, '10 dmg with 100% defense = 1 (minimum)');
  assertEqual(calcDamage(1, 0), 1, '1 dmg with 0 defense = 1');
  assertEqual(calcDamage(20, 25), 15, '20 dmg with 25% defense = 15');
}

{
  // Rogue backstab: 1.5x
  const baseDmg = 10;
  const backstab = Math.round(baseDmg * 1.5);
  assertEqual(backstab, 15, 'Rogue backstab: 10 * 1.5 = 15');
}

{
  // Player invulnerability
  const invulnDuration = 0.3;
  assertEqual(invulnDuration, 0.3, 'Invulnerability duration = 0.3 seconds');
}

// ─── MELEE SWING ANIMATION ───
group('Melee Swing Animation');

{
  // Swing state defaults
  const mockPlayer = { swingTimer: 0, swingDuration: 0, swingDir: 1 };
  assertEqual(mockPlayer.swingTimer, 0, 'Swing timer starts at 0');
  assertEqual(mockPlayer.swingDuration, 0, 'Swing duration starts at 0');
  assertEqual(mockPlayer.swingDir, 1, 'Swing direction starts at 1');
}

{
  // Swing direction alternates on each attack
  let dir = 1;
  dir *= -1; assertEqual(dir, -1, 'First attack: swing dir = -1');
  dir *= -1; assertEqual(dir, 1, 'Second attack: swing dir = 1');
  dir *= -1; assertEqual(dir, -1, 'Third attack: swing dir = -1');
}

{
  // Swing angle at start of swing (t=0): weapon cocked back
  const fa = 0;
  const t = 0;
  const smooth = t * t * (3 - 2 * t);
  const angle = fa + (smooth * 2 - 1) * (Math.PI / 3) * 1;
  assertApprox(angle, -Math.PI / 3, 0.01, 'Swing start: angle = -60° from facing');
}

{
  // Swing angle at midpoint (t=0.5): weapon at center
  const fa = 0;
  const t = 0.5;
  const smooth = t * t * (3 - 2 * t);
  const angle = fa + (smooth * 2 - 1) * (Math.PI / 3) * 1;
  assertApprox(angle, 0, 0.01, 'Swing mid: angle = facing direction');
}

{
  // Swing angle at end (t=1): weapon follow-through
  const fa = 0;
  const t = 1;
  const smooth = t * t * (3 - 2 * t);
  const angle = fa + (smooth * 2 - 1) * (Math.PI / 3) * 1;
  assertApprox(angle, Math.PI / 3, 0.01, 'Swing end: angle = +60° from facing');
}

{
  // Opposite direction swings mirror correctly
  const fa = 0;
  const t = 1;
  const smooth = t * t * (3 - 2 * t);
  const anglePos = fa + (smooth * 2 - 1) * (Math.PI / 3) * 1;
  const angleNeg = fa + (smooth * 2 - 1) * (Math.PI / 3) * -1;
  assertApprox(anglePos, Math.PI / 3, 0.01, 'Positive dir: ends at +60°');
  assertApprox(angleNeg, -Math.PI / 3, 0.01, 'Negative dir: ends at -60°');
}

{
  // Smoothstep easing: accelerates and decelerates
  const smooth25 = 0.25 * 0.25 * (3 - 2 * 0.25);
  const smooth75 = 0.75 * 0.75 * (3 - 2 * 0.75);
  assert(smooth25 < 0.25, 'Smoothstep: slow at start (eased 0.25 = ' + smooth25.toFixed(3) + ')');
  assert(smooth75 > 0.75, 'Smoothstep: fast at middle (eased 0.75 = ' + smooth75.toFixed(3) + ')');
  assertApprox(smooth25 + smooth75, 1.0, 0.001, 'Smoothstep: symmetric (0.25 + 0.75 = 1.0)');
}

{
  // Swing activates for all melee weapons
  const meleeWeapons = Object.entries(WEAPON_DEFS).filter(([k, v]) => v.type === 'melee');
  assert(meleeWeapons.length >= 3, 'At least 3 melee weapon types exist');
  for (const [name, def] of meleeWeapons) {
    assertEqual(def.type, 'melee', name + ' is melee — gets swing animation');
  }
  // Ranged weapons should not swing
  const rangedWeapons = Object.entries(WEAPON_DEFS).filter(([k, v]) => v.type === 'ranged');
  for (const [name, def] of rangedWeapons) {
    assertEqual(def.type, 'ranged', name + ' is ranged — no swing animation');
  }
}

{
  // Swing timer set to weapon cooldown for each melee weapon
  const meleeWeapons = Object.entries(WEAPON_DEFS).filter(([k, v]) => v.type === 'melee');
  for (const [name, def] of meleeWeapons) {
    assert(def.cooldown > 0, name + ' cooldown > 0 (used as swing duration)');
  }
  assertEqual(WEAPON_DEFS.sword.cooldown, 0.5, 'Sword cooldown = 0.5s (swing duration)');
  assertEqual(WEAPON_DEFS.axe.cooldown, 0.9, 'Axe cooldown = 0.9s (swing duration)');
  assertEqual(WEAPON_DEFS.scythe.cooldown, 0.4, 'Scythe cooldown = 0.4s (swing duration)');
  assertEqual(WEAPON_DEFS.spear.cooldown, 0.65, 'Spear cooldown = 0.65s (swing duration)');
}

// ─── SHOP INTEGRATION ───
group('Shop Integration');

localStorage.clear();
{
  // Rogue locked by default
  const ggData = ggLoad();
  const rogueDef = CLASS_DEFS.rogue;
  const locked = rogueDef.shopUnlock && !ggData.shopPurchases[rogueDef.shopUnlock];
  assertEqual(locked, true, 'Rogue is locked by default');
}

{
  // Rogue unlocked with purchase
  const data = ggLoad();
  data.shopPurchases['rd_shadow_class'] = true;
  ggSave(data);
  const ggData = ggLoad();
  const locked = CLASS_DEFS.rogue.shopUnlock && !ggData.shopPurchases[CLASS_DEFS.rogue.shopUnlock];
  assertEqual(locked, false, 'Rogue unlocked after purchasing rd_shadow_class');
}

localStorage.clear();
{
  // Enchanted start: uncommon weapon (rarity 1)
  const ggData = ggLoad();
  const hasEnchanted = !!ggData.shopPurchases['rd_enchanted_start'];
  const startRarity = hasEnchanted ? 1 : 0;
  assertEqual(startRarity, 0, 'Default start = common weapon (rarity 0)');
}

{
  const data = ggLoad();
  data.shopPurchases['rd_enchanted_start'] = true;
  ggSave(data);
  const ggData = ggLoad();
  const hasEnchanted = !!ggData.shopPurchases['rd_enchanted_start'];
  const startRarity = hasEnchanted ? 1 : 0;
  assertEqual(startRarity, 1, 'Enchanted start = uncommon weapon (rarity 1)');
}

// ─── INVENTORY ───
group('Inventory');

{
  const inv = [null, null, null, null, null];
  assertEqual(inv.length, 5, 'Inventory has 5 slots');

  // Add item to first empty slot
  function addToInv(inv, item) {
    for (let i = 0; i < 5; i++) {
      if (!inv[i]) { inv[i] = item; return true; }
    }
    return false;
  }

  const result = addToInv(inv, { type: 'potion', heal: 25 });
  assertEqual(result, true, 'Can add item to empty inventory');
  assert(inv[0] !== null, 'Item placed in slot 0');
}

{
  // Potion use
  const inv = [{ type: 'potion', heal: 25, name: 'Small Potion' }, null, null, null, null];
  let hp = 80, maxHp = 100;
  const item = inv[0];
  if (item && item.type === 'potion') {
    const healed = Math.min(item.heal, maxHp - hp);
    hp += healed;
    inv[0] = null;
  }
  assertEqual(hp, 100, 'Potion heals HP (80 + 25 capped at 100)');
  assertEqual(inv[0], null, 'Potion consumed after use');
}

{
  // Full HP: potion does not heal
  let hp = 100, maxHp = 100;
  const healed = Math.min(25, maxHp - hp);
  assertEqual(healed, 0, 'No healing when at full HP');
}

{
  // Full inventory
  const inv = [{ type: 'potion' }, { type: 'potion' }, { type: 'potion' }, { type: 'potion' }, { type: 'potion' }];
  function addToInv(inv, item) {
    for (let i = 0; i < 5; i++) { if (!inv[i]) { inv[i] = item; return true; } }
    return false;
  }
  const result = addToInv(inv, { type: 'potion' });
  assertEqual(result, false, 'Cannot add to full inventory');
}

// ─── POTION DEFINITIONS ───
group('Potion Definitions');

{
  assertEqual(POTION_DEFS.length, 3, '3 potion types defined');
  assertEqual(POTION_DEFS[0].heal, 25, 'Small Potion heals 25');
  assertEqual(POTION_DEFS[1].heal, 50, 'Medium Potion heals 50');
  assertEqual(POTION_DEFS[2].heal, 100, 'Large Potion heals 100');
}

{
  // Weights: small most common
  assert(POTION_DEFS[0].weight > POTION_DEFS[1].weight, 'Small potion more common than medium');
  assert(POTION_DEFS[1].weight > POTION_DEFS[2].weight, 'Medium potion more common than large');
}

// ─── BOSS FLOOR DETECTION ───
group('Boss Floor Detection');

{
  assert(BOSS_FLOORS.includes(5), 'Floor 5 is a boss floor');
  assert(BOSS_FLOORS.includes(10), 'Floor 10 is a boss floor');
  assert(BOSS_FLOORS.includes(15), 'Floor 15 is a boss floor');
  assert(!BOSS_FLOORS.includes(1), 'Floor 1 is NOT a boss floor');
  assert(!BOSS_FLOORS.includes(7), 'Floor 7 is NOT a boss floor');
}

// ─── TILE CONSTANTS ───
group('Tile Constants');

{
  assertEqual(TILE, 32, 'Tile size = 32px');
  assertEqual(MAP_W, 30, 'Map width = 30 tiles');
  assertEqual(MAP_H, 30, 'Map height = 30 tiles');
  assertEqual(MAX_FLOORS, 15, 'Max floors = 15');
}

{
  assertEqual(TILE_WALL, 0, 'TILE_WALL = 0');
  assertEqual(TILE_FLOOR, 1, 'TILE_FLOOR = 1');
  assertEqual(TILE_CORRIDOR, 2, 'TILE_CORRIDOR = 2');
  assertEqual(TILE_STAIRS, 3, 'TILE_STAIRS = 3');
  assertEqual(TILE_CHEST, 4, 'TILE_CHEST = 4');
}

// ─── WEAPON GENERATION ───
group('Weapon Generation');

{
  // makeWeapon always returns valid weapon
  for (let i = 0; i < 20; i++) {
    const w = makeWeapon(1);
    assert(w.type === 'weapon', 'Generated weapon has type=weapon');
    assert(w.rarity >= 0 && w.rarity <= 3, 'Rarity in range 0-3');
    assert(w.damage > 0, 'Weapon damage > 0');
    assert(WEAPON_DEFS[w.base], 'Weapon base "' + w.base + '" exists in WEAPON_DEFS');
  }
}

{
  // Forced rarity respects parameter
  for (let r = 0; r < 4; r++) {
    const w = makeWeapon(1, r);
    assertEqual(w.rarity, r, 'Forced rarity ' + r + ' respected');
  }
}

// ─── SAVE/LOAD SYSTEM ───
group('Save/Load System');

// Mock save/load functions (extracted from game)
const RD_SAVE_KEY = 'rd-save';
function hasSave() { return localStorage.getItem(RD_SAVE_KEY) !== null; }
function deleteSave() { localStorage.removeItem(RD_SAVE_KEY); }

function buildSaveData(player, dungeon, enemies, groundItems, revealed, projectiles, runStats) {
  const liveEnemies = enemies.filter(e => !e.dead);
  const savedProjectiles = projectiles.map(p => {
    const obj = {};
    for (const k in p) { if (k === 'hitEnemies') continue; obj[k] = p[k]; }
    obj.hitEnemiesIndices = [...p.hitEnemies].map(e => liveEnemies.indexOf(e)).filter(i => i >= 0);
    return obj;
  });
  const stairsRoomIndex = dungeon.rooms.indexOf(dungeon.stairsRoom);
  const startRoomIndex = dungeon.rooms.indexOf(dungeon.startRoom);
  const floorElapsed = 12.5; // mock elapsed
  const savedPlayer = {};
  for (const k in player) { if (k === 'floorStartTime') continue; savedPlayer[k] = player[k]; }
  savedPlayer.weapon = { ...player.weapon };
  savedPlayer.inventory = player.inventory.map(item => item ? { ...item } : null);
  return {
    version: 1, player: savedPlayer, floorElapsed,
    dungeon: {
      tiles: dungeon.tiles.map(row => [...row]),
      rooms: dungeon.rooms.map(r => ({ x: r.x, y: r.y, w: r.w, h: r.h, cx: r.cx, cy: r.cy, type: r.type, revealed: r.revealed })),
      stairsRoomIndex, startRoomIndex, isBossFloor: dungeon.isBossFloor, floor: dungeon.floor,
    },
    revealed: revealed.map(row => [...row]),
    enemies: liveEnemies.map(e => { const obj = {}; for (const k in e) obj[k] = e[k]; if (e.chargeDir) obj.chargeDir = { ...e.chargeDir }; return obj; }),
    groundItems: groundItems.map(gi => ({ x: gi.x, y: gi.y, item: { ...gi.item } })),
    projectiles: savedProjectiles,
    runStats: { ...runStats },
  };
}

function restoreFromSave(save) {
  const p = save.player;
  const d = {
    tiles: save.dungeon.tiles, rooms: save.dungeon.rooms,
    stairsRoom: save.dungeon.rooms[save.dungeon.stairsRoomIndex],
    startRoom: save.dungeon.rooms[save.dungeon.startRoomIndex],
    isBossFloor: save.dungeon.isBossFloor, floor: save.dungeon.floor,
  };
  const projs = (save.projectiles || []).map(pr => {
    pr.hitEnemies = new Set((pr.hitEnemiesIndices || []).map(i => save.enemies[i]).filter(Boolean));
    delete pr.hitEnemiesIndices;
    return pr;
  });
  return { player: p, dungeon: d, enemies: save.enemies, groundItems: save.groundItems, projectiles: projs, revealed: save.revealed, runStats: save.runStats, floorElapsed: save.floorElapsed };
}

localStorage.clear();

{
  assertEqual(hasSave(), false, 'hasSave() = false when no save exists');
}

{
  localStorage.setItem(RD_SAVE_KEY, '{}');
  assertEqual(hasSave(), true, 'hasSave() = true after writing save');
  deleteSave();
  assertEqual(hasSave(), false, 'hasSave() = false after deleteSave()');
}

{
  // Full round-trip test
  const mockPlayer = {
    x: 150.5, y: 200.3, hp: 85, maxHp: 150, defense: 10, speed: 2.5,
    className: 'warrior', color: '#4488ff', radius: 8,
    weapon: { base: 'sword', rarity: 1, type: 'weapon', damage: 16, name: 'Uncommon Sword', color: '#44cc44' },
    inventory: [
      { type: 'potion', name: 'Small Potion', heal: 25, color: '#ff4444', icon: '\uD83E\uDDEA' },
      null,
      { type: 'armor', name: 'Armor +10%', defense: 10, color: '#8888aa', icon: '\uD83D\uDEE1\uFE0F' },
      null, null
    ],
    attackTimer: 0, invulnTimer: 0, gold: 123, floor: 3, kills: 15, bossKills: 0,
    damageTakenThisBoss: 0, floorStartTime: 99999, facingAngle: 1.2,
    swingTimer: 0, swingDuration: 0, swingDir: 1,
  };

  const mockDungeon = generateDungeon(3);
  const mockRevealed = [];
  for (let y = 0; y < MAP_H; y++) { mockRevealed[y] = []; for (let x = 0; x < MAP_W; x++) mockRevealed[y][x] = (x + y) % 3 === 0; }

  const mockEnemies = [
    { type: 'rat', x: 100, y: 100, hp: 10, maxHp: 15, damage: 5, speed: 2.5, radius: 6, color: '#8d6e63', ai: 'chase', atkCd: 1.0, atkTimer: 0.3, splits: false, range: 0, facingX: 1, facingY: 0, zigzagTimer: 0, zigzagDir: 1, isBoss: false },
    { type: 'skeleton', x: 200, y: 200, hp: 25, maxHp: 30, damage: 10, speed: 1.5, radius: 8, color: '#e0e0e0', ai: 'chase', atkCd: 1.2, atkTimer: 0, splits: false, range: 0, facingX: 0, facingY: 1, zigzagTimer: 0, zigzagDir: -1, isBoss: false },
    { type: 'rat', x: 0, y: 0, hp: 0, maxHp: 15, damage: 5, speed: 2.5, radius: 6, color: '#8d6e63', ai: 'chase', atkCd: 1.0, atkTimer: 0, splits: false, range: 0, facingX: 0, facingY: 0, zigzagTimer: 0, zigzagDir: 1, isBoss: false, dead: true },
  ];

  const mockGroundItems = [
    { x: 120, y: 130, item: { type: 'weapon', base: 'axe', rarity: 2, damage: 32, name: 'Rare Axe', color: '#4488ff' } },
    { x: 250, y: 260, item: { type: 'gold', name: '25 Gold', amount: 25, color: '#c9a84c', icon: '\u2B50' } },
  ];

  const mockProjectiles = [
    { x: 50, y: 50, vx: 100, vy: 0, damage: 10, range: 256, traveled: 30, radius: 4, color: '#886633', owner: 'player', pierce: false, hitEnemies: new Set([mockEnemies[0]]) },
  ];

  const mockRunStats = { startTime: Date.now() - 60000 };

  const saveData = buildSaveData(mockPlayer, mockDungeon, mockEnemies, mockGroundItems, mockRevealed, mockProjectiles, mockRunStats);

  // Write and read back
  localStorage.setItem(RD_SAVE_KEY, JSON.stringify(saveData));
  const loaded = JSON.parse(localStorage.getItem(RD_SAVE_KEY));
  const restored = restoreFromSave(loaded);

  // Player round-trip
  assertEqual(restored.player.x, 150.5, 'Player x round-trips');
  assertEqual(restored.player.y, 200.3, 'Player y round-trips');
  assertEqual(restored.player.hp, 85, 'Player hp round-trips');
  assertEqual(restored.player.maxHp, 150, 'Player maxHp round-trips');
  assertEqual(restored.player.defense, 10, 'Player defense round-trips');
  assertEqual(restored.player.className, 'warrior', 'Player className round-trips');
  assertEqual(restored.player.gold, 123, 'Player gold round-trips');
  assertEqual(restored.player.floor, 3, 'Player floor round-trips');
  assertEqual(restored.player.kills, 15, 'Player kills round-trips');
  assertApprox(restored.player.facingAngle, 1.2, 0.001, 'Player facingAngle round-trips');

  // Weapon round-trip
  assertEqual(restored.player.weapon.base, 'sword', 'Weapon base round-trips');
  assertEqual(restored.player.weapon.rarity, 1, 'Weapon rarity round-trips');
  assertEqual(restored.player.weapon.damage, 16, 'Weapon damage round-trips');
  assertEqual(restored.player.weapon.name, 'Uncommon Sword', 'Weapon name round-trips');

  // Inventory round-trip
  assert(restored.player.inventory[0] !== null, 'Inventory slot 0 has item');
  assertEqual(restored.player.inventory[0].type, 'potion', 'Inventory potion type round-trips');
  assertEqual(restored.player.inventory[0].heal, 25, 'Inventory potion heal round-trips');
  assertEqual(restored.player.inventory[1], null, 'Inventory slot 1 is null');
  assertEqual(restored.player.inventory[2].type, 'armor', 'Inventory armor type round-trips');
  assertEqual(restored.player.inventory[3], null, 'Inventory slot 3 is null');

  // Dungeon round-trip
  assertEqual(restored.dungeon.tiles.length, MAP_H, 'Dungeon tiles height round-trips');
  assertEqual(restored.dungeon.tiles[0].length, MAP_W, 'Dungeon tiles width round-trips');
  assertEqual(restored.dungeon.floor, 3, 'Dungeon floor round-trips');
  assertEqual(restored.dungeon.isBossFloor, false, 'Dungeon isBossFloor round-trips');

  // Tiles match exactly
  let tilesMatch = true;
  for (let y = 0; y < MAP_H && tilesMatch; y++)
    for (let x = 0; x < MAP_W && tilesMatch; x++)
      if (restored.dungeon.tiles[y][x] !== mockDungeon.tiles[y][x]) tilesMatch = false;
  assert(tilesMatch, 'Dungeon tiles match exactly');

  // Rooms round-trip
  assertEqual(restored.dungeon.rooms.length, mockDungeon.rooms.length, 'Room count matches');
  for (let i = 0; i < mockDungeon.rooms.length; i++) {
    assertEqual(restored.dungeon.rooms[i].x, mockDungeon.rooms[i].x, 'Room ' + i + ' x matches');
    assertEqual(restored.dungeon.rooms[i].type, mockDungeon.rooms[i].type, 'Room ' + i + ' type matches');
    assertEqual(restored.dungeon.rooms[i].revealed, mockDungeon.rooms[i].revealed, 'Room ' + i + ' revealed matches');
  }

  // stairsRoom/startRoom references
  const stairsIdx = mockDungeon.rooms.indexOf(mockDungeon.stairsRoom);
  assertEqual(restored.dungeon.stairsRoom, restored.dungeon.rooms[stairsIdx], 'stairsRoom is correct room reference');
  const startIdx = mockDungeon.rooms.indexOf(mockDungeon.startRoom);
  assertEqual(restored.dungeon.startRoom, restored.dungeon.rooms[startIdx], 'startRoom is correct room reference');
  assertEqual(restored.dungeon.stairsRoom.type, 'stairs', 'stairsRoom has stairs type');
  assertEqual(restored.dungeon.startRoom.type, 'start', 'startRoom has start type');

  // Fog of war round-trip
  let fogMatch = true;
  for (let y = 0; y < MAP_H && fogMatch; y++)
    for (let x = 0; x < MAP_W && fogMatch; x++)
      if (restored.revealed[y][x] !== mockRevealed[y][x]) fogMatch = false;
  assert(fogMatch, 'Fog of war round-trips exactly');

  // Enemies: dead filtered out
  assertEqual(restored.enemies.length, 2, 'Dead enemies filtered (3 → 2)');
  assertEqual(restored.enemies[0].type, 'rat', 'Enemy 0 type round-trips');
  assertEqual(restored.enemies[0].hp, 10, 'Enemy 0 hp round-trips');
  assertApprox(restored.enemies[0].atkTimer, 0.3, 0.01, 'Enemy 0 atkTimer round-trips');
  assertEqual(restored.enemies[1].type, 'skeleton', 'Enemy 1 type round-trips');
  assertEqual(restored.enemies[1].zigzagDir, -1, 'Enemy 1 zigzagDir round-trips');

  // Ground items round-trip
  assertEqual(restored.groundItems.length, 2, 'Ground items count round-trips');
  assertEqual(restored.groundItems[0].item.base, 'axe', 'Ground item 0 weapon base round-trips');
  assertEqual(restored.groundItems[0].item.damage, 32, 'Ground item 0 damage round-trips');
  assertEqual(restored.groundItems[1].item.type, 'gold', 'Ground item 1 gold type round-trips');
  assertEqual(restored.groundItems[1].item.amount, 25, 'Ground item 1 gold amount round-trips');

  // Projectiles hitEnemies Set round-trip
  assertEqual(restored.projectiles.length, 1, 'Projectile count round-trips');
  assert(restored.projectiles[0].hitEnemies instanceof Set, 'hitEnemies restored as Set');
  assertEqual(restored.projectiles[0].hitEnemies.size, 1, 'hitEnemies has 1 entry');
  assert(restored.projectiles[0].hitEnemies.has(restored.enemies[0]), 'hitEnemies contains correct enemy');
  assertEqual(restored.projectiles[0].damage, 10, 'Projectile damage round-trips');

  // floorElapsed round-trip
  assertEqual(loaded.floorElapsed, 12.5, 'floorElapsed saved correctly');

  // runStats round-trip
  assertEqual(restored.runStats.startTime, mockRunStats.startTime, 'runStats.startTime round-trips');

  // Save version
  assertEqual(loaded.version, 1, 'Save has version: 1');

  localStorage.clear();
}

{
  // Boss enemy round-trip
  const mockDungeon2 = generateDungeon(5);
  const bossEnemy = {
    type: 'spiderQueen', x: 300, y: 300, hp: 350, maxHp: 400,
    damage: 15, speed: 1.0, radius: 16, color: '#442244',
    ai: 'boss', ability: 'spawn', interval: 4, abilityTimer: 2.5,
    atkCd: 1.5, atkTimer: 0.7, isBoss: true, name: 'Spider Queen',
    gold: 50, facingX: 0, facingY: 1, splits: false, range: 0,
    zigzagTimer: 0, zigzagDir: 1, charging: false, chargeTimer: 0,
    chargeDir: { x: 0, y: 0 }, breathActive: false, breathTimer: 0,
    breathAngle: 0, summonCount: 2,
  };
  const mockRev2 = [];
  for (let y = 0; y < MAP_H; y++) { mockRev2[y] = []; for (let x = 0; x < MAP_W; x++) mockRev2[y][x] = false; }

  const mockPlayer2 = {
    x: 100, y: 100, hp: 80, maxHp: 100, defense: 0, speed: 3.0,
    className: 'archer', color: '#44bb44', radius: 8,
    weapon: { base: 'bow', rarity: 0, type: 'weapon', damage: 10, name: 'Common Bow', color: '#886633' },
    inventory: [null, null, null, null, null],
    attackTimer: 0, invulnTimer: 0, gold: 50, floor: 5, kills: 30, bossKills: 0,
    damageTakenThisBoss: 0, floorStartTime: 0, facingAngle: 0,
    swingTimer: 0, swingDuration: 0, swingDir: 1,
  };

  const save2 = buildSaveData(mockPlayer2, mockDungeon2, [bossEnemy], [], mockRev2, [], { startTime: Date.now() });
  localStorage.setItem(RD_SAVE_KEY, JSON.stringify(save2));
  const loaded2 = JSON.parse(localStorage.getItem(RD_SAVE_KEY));
  const restored2 = restoreFromSave(loaded2);

  assertEqual(restored2.enemies.length, 1, 'Boss saved');
  assertEqual(restored2.enemies[0].type, 'spiderQueen', 'Boss type round-trips');
  assertEqual(restored2.enemies[0].hp, 350, 'Boss hp round-trips');
  assertEqual(restored2.enemies[0].isBoss, true, 'Boss isBoss round-trips');
  assertEqual(restored2.enemies[0].ability, 'spawn', 'Boss ability round-trips');
  assertApprox(restored2.enemies[0].abilityTimer, 2.5, 0.01, 'Boss abilityTimer round-trips');
  assertEqual(restored2.enemies[0].summonCount, 2, 'Boss summonCount round-trips');
  assertEqual(restored2.enemies[0].name, 'Spider Queen', 'Boss name round-trips');
  assertEqual(restored2.enemies[0].gold, 50, 'Boss gold round-trips');

  localStorage.clear();
}

{
  // Save deleted on death/victory/new game (simulated)
  localStorage.setItem(RD_SAVE_KEY, '{"test":true}');
  assertEqual(hasSave(), true, 'Save exists before delete');
  deleteSave(); // simulates what showDeathScreen/showVictoryScreen/startGame calls
  assertEqual(hasSave(), false, 'Save deleted (simulating death/victory/new game)');
}

// ─── BETWEEN-FLOOR SHOP ───
group('Between-Floor Shop');

{
  // Shop items defined
  assertEqual(SHOP_ITEMS.length, 2, 'Shop has 2 items');
  assertEqual(SHOP_ITEMS[0].name, 'Small Potion', 'First item is Small Potion');
  assertEqual(SHOP_ITEMS[0].price, 25, 'Small Potion costs 25 gold');
  assertEqual(SHOP_ITEMS[0].heal, 25, 'Small Potion heals 25 HP');
  assertEqual(SHOP_ITEMS[1].name, 'Large Potion', 'Second item is Large Potion');
  assertEqual(SHOP_ITEMS[1].price, 50, 'Large Potion costs 50 gold');
  assertEqual(SHOP_ITEMS[1].heal, 100, 'Large Potion heals 100 HP');
}

{
  // Buy deducts gold and adds to inventory
  const mockPlayer = { gold: 100, inventory: [null, null, null, null, null], hp: 50, maxHp: 100 };
  const si = SHOP_ITEMS[0]; // Small Potion, 25g
  // Simulate buyShopItem logic
  if (mockPlayer.gold >= si.price) {
    const item = { type: 'potion', name: si.name, heal: si.heal };
    for (let i = 0; i < 5; i++) {
      if (!mockPlayer.inventory[i]) { mockPlayer.inventory[i] = item; break; }
    }
    mockPlayer.gold -= si.price;
  }
  assertEqual(mockPlayer.gold, 75, 'Gold deducted after buying Small Potion');
  assertEqual(mockPlayer.inventory[0].name, 'Small Potion', 'Potion added to inventory slot 0');
  assertEqual(mockPlayer.inventory[0].heal, 25, 'Potion has correct heal value');
}

{
  // Cannot buy when inventory is full
  const mockPlayer = { gold: 100, inventory: [{}, {}, {}, {}, {}] };
  const si = SHOP_ITEMS[0];
  let bought = false;
  if (mockPlayer.gold >= si.price) {
    let added = false;
    for (let i = 0; i < 5; i++) {
      if (!mockPlayer.inventory[i]) { added = true; break; }
    }
    if (added) { mockPlayer.gold -= si.price; bought = true; }
  }
  assertEqual(bought, false, 'Cannot buy when inventory is full');
  assertEqual(mockPlayer.gold, 100, 'Gold not deducted when inventory full');
}

{
  // Cannot buy when gold insufficient
  const mockPlayer = { gold: 10, inventory: [null, null, null, null, null] };
  const si = SHOP_ITEMS[1]; // Large Potion, 50g
  let bought = false;
  if (mockPlayer.gold >= si.price) { bought = true; }
  assertEqual(bought, false, 'Cannot buy when gold insufficient');
}

{
  // Can buy multiple potions until gold or inventory runs out
  const mockPlayer = { gold: 200, inventory: [null, null, null, null, null] };
  const si = SHOP_ITEMS[0]; // 25g each
  let buyCount = 0;
  while (mockPlayer.gold >= si.price) {
    let added = false;
    for (let i = 0; i < 5; i++) {
      if (!mockPlayer.inventory[i]) { mockPlayer.inventory[i] = { type: 'potion' }; added = true; break; }
    }
    if (!added) break;
    mockPlayer.gold -= si.price;
    buyCount++;
  }
  assertEqual(buyCount, 5, 'Can buy 5 potions to fill inventory');
  assertEqual(mockPlayer.gold, 75, 'Gold after 5 purchases: 200 - 125 = 75');
}

// ─── WEAPON INVENTORY ───
group('Weapon Inventory');

{
  // Store weapon in inventory
  const inv = [null, null, null, null, null];
  const weapon = { type: 'weapon', base: 'sword', name: 'Common Sword', damage: 12, rarity: 0, color: '#aaa' };
  let stored = false;
  for (let i = 0; i < 5; i++) {
    if (!inv[i]) { inv[i] = weapon; stored = true; break; }
  }
  assertEqual(stored, true, 'Weapon stored in inventory');
  assertEqual(inv[0].type, 'weapon', 'Slot 0 contains weapon');
  assertEqual(inv[0].base, 'sword', 'Stored weapon is a sword');
}

{
  // Equip weapon from inventory swaps with current
  const currentWeapon = { type: 'weapon', base: 'sword', name: 'Common Sword', damage: 12, rarity: 0, color: '#aaa' };
  const storedWeapon = { type: 'weapon', base: 'axe', name: 'Rare Axe', damage: 32, rarity: 2, color: '#4488ff' };
  const inv = [storedWeapon, null, null, null, null];

  // Simulate useInventorySlot for weapon
  const item = inv[0];
  let equipped = currentWeapon;
  if (item && item.type === 'weapon') {
    const old = equipped;
    equipped = item;
    inv[0] = old;
  }
  assertEqual(equipped.base, 'axe', 'Equipped weapon is now the axe');
  assertEqual(equipped.damage, 32, 'Equipped weapon has axe damage');
  assertEqual(inv[0].base, 'sword', 'Old sword now in inventory slot');
  assertEqual(inv[0].damage, 12, 'Inventory weapon has sword damage');
}

{
  // Mixed inventory: potions and weapons
  const inv = [
    { type: 'potion', name: 'Small Potion', heal: 25 },
    { type: 'weapon', base: 'bow', name: 'Uncommon Bow', damage: 13, rarity: 1 },
    null, null, null
  ];
  assertEqual(inv[0].type, 'potion', 'Slot 0 is potion');
  assertEqual(inv[1].type, 'weapon', 'Slot 1 is weapon');

  // Use potion: consumed
  let hp = 80, maxHp = 100;
  const potion = inv[0];
  if (potion.type === 'potion') {
    hp += Math.min(potion.heal, maxHp - hp);
    inv[0] = null;
  }
  assertEqual(hp, 100, 'Potion healed to full');
  assertEqual(inv[0], null, 'Potion consumed');

  // Use weapon: swaps
  const equipped = { type: 'weapon', base: 'staff', name: 'Common Staff', damage: 14, rarity: 0 };
  const wep = inv[1];
  let newEquipped = equipped;
  if (wep.type === 'weapon') {
    newEquipped = wep;
    inv[1] = equipped;
  }
  assertEqual(newEquipped.base, 'bow', 'Now equipped with bow');
  assertEqual(inv[1].base, 'staff', 'Staff moved to inventory');
}

{
  // Cannot store weapon when inventory full
  const inv = [{}, {}, {}, {}, {}];
  let stored = false;
  for (let i = 0; i < 5; i++) {
    if (!inv[i]) { stored = true; break; }
  }
  assertEqual(stored, false, 'Cannot store weapon in full inventory');
}

{
  // Weapon in inventory has correct display info
  const weapon = { type: 'weapon', base: 'scythe', name: 'Epic Scythe', damage: 18, rarity: 3, color: '#aa44ff' };
  assertEqual(weapon.type, 'weapon', 'Weapon type is weapon');
  assert(weapon.color !== undefined, 'Weapon has color for rarity border');
  assert(weapon.damage > 0, 'Weapon has positive damage for tooltip');
  assert(weapon.name.length > 0, 'Weapon has name for tooltip');
}

// ─── DROP FROM INVENTORY ───
group('Drop From Inventory');

{
  // Drop potion from inventory
  const inv = [{ type: 'potion', name: 'Small Potion', heal: 25, icon: '\uD83E\uDDEA' }, null, null, null, null];
  const dropped = [];
  // Simulate dropInventorySlot
  const idx = 0;
  const item = inv[idx];
  assert(item !== null, 'Slot 0 has item before drop');
  inv[idx] = null;
  dropped.push({ x: 100, y: 100, item });
  assertEqual(inv[0], null, 'Slot 0 empty after drop');
  assertEqual(dropped.length, 1, 'Item added to ground items');
  assertEqual(dropped[0].item.name, 'Small Potion', 'Dropped item is the potion');
}

{
  // Drop weapon from inventory
  const weapon = { type: 'weapon', base: 'axe', name: 'Rare Axe', damage: 32, rarity: 2, color: '#4488ff' };
  const inv = [null, weapon, null, null, null];
  const dropped = [];
  const idx = 1;
  const item = inv[idx];
  assert(item !== null, 'Slot 1 has weapon before drop');
  inv[idx] = null;
  dropped.push({ x: 50, y: 50, item });
  assertEqual(inv[1], null, 'Slot 1 empty after weapon drop');
  assertEqual(dropped[0].item.base, 'axe', 'Dropped weapon is the axe');
}

{
  // Drop from empty slot does nothing
  const inv = [null, null, null, null, null];
  const idx = 2;
  const item = inv[idx];
  assertEqual(item, null, 'Empty slot returns null — no drop');
}

{
  // Drop and re-pickup: item available on ground
  const inv = [{ type: 'potion', name: 'Large Potion', heal: 100 }, null, null, null, null];
  const ground = [];
  // Drop
  ground.push({ x: 0, y: 0, item: inv[0] });
  inv[0] = null;
  // Re-pickup
  const gi = ground[0];
  let added = false;
  for (let i = 0; i < 5; i++) {
    if (!inv[i]) { inv[i] = gi.item; added = true; break; }
  }
  ground.splice(0, 1);
  assertEqual(added, true, 'Dropped item can be re-picked up');
  assertEqual(inv[0].name, 'Large Potion', 'Re-picked up item is same potion');
  assertEqual(ground.length, 0, 'Ground item removed after pickup');
}

{
  // Selected slot tracking: pressing 1-5 sets selected slot
  let sel = -1;
  sel = 0; assertEqual(sel, 0, 'Press 1 selects slot 0');
  sel = 4; assertEqual(sel, 4, 'Press 5 selects slot 4');
  // R drops from selected
  const inv = [null, null, null, null, { type: 'potion', name: 'Test', heal: 25 }];
  const item = inv[sel];
  assert(item !== null, 'Selected slot 4 has item');
  inv[sel] = null;
  assertEqual(inv[4], null, 'Item dropped from selected slot');
}

// ─── SHOP STATE TRANSITION ───
group('Shop State Transition');

{
  // checkStairs should go to shop, not directly to next floor (floor < MAX)
  // Simulating the flow: floor < MAX_FLOORS → shop → continue → enterFloor
  const MAX_FLOORS_VAL = 15;
  for (let f = 1; f < MAX_FLOORS_VAL; f++) {
    assert(f < MAX_FLOORS_VAL, 'Floor ' + f + ' < max: should show shop');
  }
  // Floor 15 (MAX_FLOORS) should go to victory, not shop
  assert(MAX_FLOORS_VAL >= MAX_FLOORS_VAL, 'Floor 15 = max: should show victory');
}

{
  // Shop items are all potions (inventory-compatible)
  for (const si of SHOP_ITEMS) {
    assertEqual(si.type, 'potion', si.name + ' is potion type');
    assert(si.price > 0, si.name + ' has positive price');
    assert(si.heal > 0, si.name + ' has positive heal');
    assert(si.icon !== undefined, si.name + ' has icon');
  }
}

// ============================================================
showSummary();
</script>
</body>
</html>
