<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini Life</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #1a1a2e;
    overflow: hidden;
    font-family: 'Segoe UI', Tahoma, sans-serif;
    height: 100vh;
    cursor: default;
  }
  canvas { display: block; }

  /* HUD */
  .hud {
    position: fixed;
    top: 12px;
    left: 12px;
    z-index: 10;
    display: flex;
    flex-direction: column;
    gap: 6px;
    pointer-events: none;
  }
  .need-bar {
    display: flex;
    align-items: center;
    gap: 8px;
    background: #00000088;
    padding: 5px 12px;
    border-radius: 6px;
    backdrop-filter: blur(4px);
  }
  .need-icon { font-size: 1rem; width: 20px; text-align: center; }
  .need-label {
    font-size: 0.7rem;
    color: #aaa;
    width: 55px;
    text-transform: uppercase;
    letter-spacing: 0.05em;
  }
  .need-track {
    width: 120px;
    height: 8px;
    background: #333;
    border-radius: 4px;
    overflow: hidden;
  }
  .need-fill {
    height: 100%;
    border-radius: 4px;
    transition: width 0.3s, background 0.3s;
  }
  .need-val {
    font-size: 0.7rem;
    color: #ccc;
    width: 30px;
    text-align: right;
  }

  /* Back to launcher */
  .back-btn {
    position: fixed;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    background: #00000088;
    color: #ccc;
    text-decoration: none;
    padding: 6px 16px;
    border-radius: 6px;
    backdrop-filter: blur(4px);
    font-size: 0.75rem;
    letter-spacing: 0.05em;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.15s;
  }
  .back-btn:hover {
    background: #000000cc;
    color: #c9a84c;
  }
  .back-btn svg {
    width: 10px;
    height: 10px;
  }

  /* Crosshair */
  .crosshair {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 5;
    pointer-events: none;
  }
  .crosshair::before, .crosshair::after {
    content: '';
    position: absolute;
    background: #ffffffaa;
    border-radius: 1px;
  }
  .crosshair::before {
    width: 16px; height: 2px;
    top: -1px; left: -8px;
  }
  .crosshair::after {
    width: 2px; height: 16px;
    top: -8px; left: -1px;
  }
  .crosshair.active::before, .crosshair.active::after {
    background: #4caf50;
  }

  /* Controls hint */
  .controls-hint {
    position: fixed;
    bottom: 12px;
    right: 12px;
    z-index: 10;
    background: #00000088;
    padding: 8px 14px;
    border-radius: 6px;
    backdrop-filter: blur(4px);
    font-size: 0.65rem;
    color: #888;
    line-height: 1.8;
    pointer-events: none;
  }
  .controls-hint kbd {
    background: #333;
    border: 1px solid #555;
    border-radius: 3px;
    padding: 1px 5px;
    color: #ccc;
    font-size: 0.7rem;
  }

  /* Action overlays */
  .action-overlay {
    position: fixed;
    inset: 0;
    z-index: 4;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.5s;
  }
  .action-overlay.visible { opacity: 1; }

  /* Sleep overlay */
  .sleep-overlay {
    background: #000000ee;
  }
  .sleep-overlay .zzz {
    position: absolute;
    font-size: 2.5rem;
    color: #88aaff;
    opacity: 0;
    animation: zzzFloat 2.5s ease-out infinite;
    text-shadow: 0 0 15px #88aaff66;
  }
  @keyframes zzzFloat {
    0% { opacity: 0; transform: translateY(0) scale(0.5); }
    20% { opacity: 0.8; }
    100% { opacity: 0; transform: translateY(-120px) translateX(30px) scale(1.2); }
  }

  /* Shower overlay */
  .shower-overlay {
    background: linear-gradient(180deg, #4488aa22 0%, #4488aa11 100%);
  }
  .shower-overlay .droplet {
    position: absolute;
    width: 3px;
    background: linear-gradient(180deg, #aaddff00, #aaddffaa);
    border-radius: 0 0 2px 2px;
    animation: dropFall linear infinite;
  }
  @keyframes dropFall {
    0% { transform: translateY(-20px); opacity: 0.7; }
    100% { transform: translateY(100vh); opacity: 0; }
  }

  /* Eat overlay */
  .eat-overlay {
    overflow: hidden;
  }
  .eat-hand {
    position: absolute;
    bottom: -80px;
    right: 20%;
    font-size: 5rem;
    transition: bottom 0.4s ease-out;
    filter: drop-shadow(0 -5px 15px #00000066);
  }
  .eat-hand.up { bottom: 10%; }
  .eat-crumb {
    position: absolute;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    opacity: 0;
    animation: crumbFall 0.8s ease-in forwards;
  }
  @keyframes crumbFall {
    0% { opacity: 1; transform: translateY(0) rotate(0deg); }
    100% { opacity: 0; transform: translateY(150px) translateX(var(--cx)) rotate(360deg); }
  }

  /* TV overlay */
  .tv-overlay {
    background: #000000cc;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .tv-screen-box {
    width: 70%;
    max-width: 600px;
    aspect-ratio: 16/9;
    background: #111;
    border-radius: 8px;
    border: 3px solid #333;
    overflow: hidden;
    position: relative;
    box-shadow: 0 0 40px #335577aa, 0 0 80px #33557744;
  }
  .tv-scanline {
    position: absolute;
    width: 100%;
    height: 3px;
    background: rgba(255,255,255,0.04);
    animation: scanMove 4s linear infinite;
    pointer-events: none;
  }
  @keyframes scanMove {
    0% { top: -3px; }
    100% { top: 100%; }
  }
  .tv-channel {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 3rem;
    transition: opacity 0.3s;
  }
  .tv-static {
    position: absolute;
    inset: 0;
    opacity: 0;
    transition: opacity 0.15s;
    background: repeating-linear-gradient(
      0deg,
      #33333344 0px, transparent 2px, transparent 4px
    );
  }
  .tv-static.flash { opacity: 1; }
  .tv-channel-label {
    position: absolute;
    top: 8px;
    right: 12px;
    font-size: 0.8rem;
    color: #ffffffaa;
    font-family: monospace;
    text-shadow: 1px 1px 2px #000;
  }

  /* Computer gaming overlay */
  .computer-overlay {
    background: #000000dd;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 10px;
  }
  .pc-screen-box {
    width: 75%;
    max-width: 650px;
    aspect-ratio: 16/9;
    background: #0a0a1a;
    border-radius: 4px;
    border: 3px solid #222;
    overflow: hidden;
    position: relative;
    box-shadow: 0 0 50px #2244aaaa, 0 0 100px #22448844;
  }
  .pc-screen-box canvas {
    width: 100%;
    height: 100%;
    display: block;
    image-rendering: pixelated;
  }
  .pc-hint {
    font-family: monospace;
    font-size: 0.85rem;
    color: #88aacc;
    letter-spacing: 0.05em;
  }
  .pc-hint kbd {
    background: #333;
    border: 1px solid #555;
    border-radius: 3px;
    padding: 2px 8px;
    color: #eee;
  }

  /* Job mini-game overlay */
  .job-overlay {
    background: #000000dd;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 10px;
  }
  .job-screen-box {
    width: 75%;
    max-width: 650px;
    aspect-ratio: 16/9;
    background: #0a0a1a;
    border-radius: 4px;
    border: 3px solid #222;
    overflow: hidden;
    position: relative;
    box-shadow: 0 0 50px #44aa8888, 0 0 100px #228844;
  }
  .job-screen-box canvas {
    width: 100%;
    height: 100%;
    display: block;
    image-rendering: pixelated;
  }
  .job-hint {
    font-family: monospace;
    font-size: 0.85rem;
    color: #88ccaa;
    letter-spacing: 0.05em;
  }
  .job-hint kbd {
    background: #333;
    border: 1px solid #555;
    border-radius: 3px;
    padding: 2px 8px;
    color: #eee;
  }

  /* Steam for shower */
  .steam-puff {
    position: absolute;
    width: 40px;
    height: 40px;
    background: radial-gradient(circle, #ffffff22 0%, transparent 70%);
    border-radius: 50%;
    animation: steamRise 3s ease-out infinite;
    pointer-events: none;
  }
  @keyframes steamRise {
    0% { opacity: 0; transform: translateY(0) scale(0.5); }
    30% { opacity: 0.4; }
    100% { opacity: 0; transform: translateY(-200px) scale(2); }
  }

  /* Money + time */
  .hud-top-right {
    position: fixed;
    top: 12px;
    right: 12px;
    z-index: 10;
    display: flex;
    flex-direction: column;
    gap: 6px;
    align-items: flex-end;
    pointer-events: none;
  }
  .hud-pill {
    background: #00000088;
    padding: 6px 14px;
    border-radius: 6px;
    backdrop-filter: blur(4px);
    font-size: 0.85rem;
    color: #eee;
    display: flex;
    align-items: center;
    gap: 6px;
  }

  /* Action tooltip */
  .action-tip {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    background: #000000aa;
    color: #fff;
    padding: 8px 20px;
    border-radius: 8px;
    font-size: 0.9rem;
    backdrop-filter: blur(4px);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
  }
  .action-tip.visible { opacity: 1; }

  /* Game over overlay */
  .game-over {
    position: fixed;
    inset: 0;
    z-index: 100;
    background: #000000dd;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.5s;
  }
  .game-over.visible { opacity: 1; pointer-events: all; }
  .game-over h1 {
    font-size: 3rem;
    color: #ff4444;
    margin-bottom: 0.3em;
  }
  .game-over p {
    color: #aaa;
    font-size: 1.1rem;
    margin-bottom: 1.5em;
  }
  .game-over button {
    font-size: 1.1rem;
    padding: 10px 30px;
    background: #4caf50;
    color: #fff;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    transition: transform 0.15s;
  }
  .game-over button:hover { transform: scale(1.05); }

  /* Character Creator */
  .creator-screen {
    position: fixed;
    inset: 0;
    z-index: 200;
    background: #000000ee;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: opacity 0.5s;
  }
  .creator-screen.hidden { opacity: 0; pointer-events: none; }
  .creator-panel {
    background: #1a1a28;
    border: 1px solid #333;
    border-radius: 12px;
    padding: 28px 36px;
    display: flex;
    gap: 36px;
    align-items: stretch;
    max-width: 700px;
    width: 90vw;
    box-shadow: 0 0 60px #00000088;
  }
  .creator-left {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 16px;
  }
  .creator-left h2 {
    color: #eee;
    font-size: 1.3rem;
    margin-bottom: 4px;
    letter-spacing: 0.03em;
  }
  .creator-right {
    width: 200px;
    min-height: 300px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }
  .creator-right canvas {
    border-radius: 8px;
    border: 1px solid #333;
  }
  .creator-row {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }
  .creator-row label {
    color: #999;
    font-size: 0.75rem;
    text-transform: uppercase;
    letter-spacing: 0.08em;
  }
  .creator-options {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  .swatch {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    border: 2px solid transparent;
    cursor: pointer;
    transition: all 0.15s;
    position: relative;
  }
  .swatch:hover { transform: scale(1.15); }
  .swatch.selected { border-color: #fff; box-shadow: 0 0 8px #ffffff66; }
  .toggle-btn {
    padding: 6px 16px;
    border-radius: 6px;
    border: 1px solid #444;
    background: #222;
    color: #999;
    cursor: pointer;
    font-size: 0.8rem;
    transition: all 0.15s;
  }
  .toggle-btn:hover { border-color: #888; color: #ccc; }
  .toggle-btn.selected { background: #335; border-color: #668; color: #fff; }
  .start-btn {
    margin-top: 12px;
    padding: 12px 0;
    width: 100%;
    border-radius: 8px;
    border: none;
    background: linear-gradient(135deg, #4caf50, #388e3c);
    color: #fff;
    font-size: 1.1rem;
    font-weight: 600;
    cursor: pointer;
    letter-spacing: 0.05em;
    transition: transform 0.15s;
  }
  .start-btn:hover { transform: scale(1.03); }

  /* Save slots UI */
  .save-slots { margin-top: 14px; }
  .save-slots-title {
    font-size: 0.75rem;
    color: #c9a84c88;
    text-transform: uppercase;
    letter-spacing: 0.1em;
    margin-bottom: 6px;
    border-top: 1px solid #333;
    padding-top: 10px;
  }
  .save-slot-row {
    background: #ffffff08;
    border: 1px solid #333;
    border-radius: 6px;
    padding: 8px 10px;
    margin-bottom: 5px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    transition: border-color 0.15s;
  }
  .save-slot-row.occupied { border-color: #c9a84c44; }
  .save-slot-info { flex: 1; min-width: 0; }
  .save-slot-name {
    font-size: 0.85rem;
    font-weight: 600;
    color: #eee;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .save-slot-detail {
    font-size: 0.7rem;
    color: #888;
    margin-top: 2px;
  }
  .save-slot-empty {
    font-size: 0.8rem;
    color: #555;
    font-style: italic;
    padding: 4px 0;
  }
  .save-slot-btns { display: flex; gap: 4px; flex-shrink: 0; }
  .save-slot-btns button {
    padding: 4px 10px;
    border-radius: 4px;
    border: none;
    font-size: 0.7rem;
    font-weight: 600;
    cursor: pointer;
    letter-spacing: 0.03em;
  }
  .slot-load-btn {
    background: linear-gradient(135deg, #4caf50, #388e3c);
    color: #fff;
  }
  .slot-load-btn:hover { filter: brightness(1.15); }
  .slot-delete-btn {
    background: transparent;
    border: 1px solid #cc444466 !important;
    color: #cc4444;
  }
  .slot-delete-btn:hover { background: #cc444422; }

  /* Name prompt overlay */
  .name-prompt-overlay {
    position: fixed;
    inset: 0;
    z-index: 300;
    background: #000000cc;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
  }
  .name-prompt-overlay.visible { opacity: 1; pointer-events: all; }
  .name-prompt-panel {
    background: #1a1a2e;
    border: 1px solid #c9a84c66;
    border-radius: 10px;
    padding: 24px;
    text-align: center;
    max-width: 320px;
    width: 85vw;
  }
  .name-prompt-panel h3 {
    color: #c9a84c;
    font-size: 1rem;
    margin-bottom: 12px;
  }
  .name-prompt-panel input {
    width: 100%;
    padding: 8px 12px;
    border-radius: 6px;
    border: 1px solid #444;
    background: #0a0a1a;
    color: #eee;
    font-size: 1rem;
    outline: none;
    margin-bottom: 12px;
  }
  .name-prompt-panel input:focus { border-color: #c9a84c; }
  .name-prompt-panel button {
    padding: 8px 24px;
    border-radius: 6px;
    border: none;
    background: linear-gradient(135deg, #4caf50, #388e3c);
    color: #fff;
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
  }

  .save-toast {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%) translateY(20px);
    z-index: 100;
    background: #1a1a28ee;
    border: 1px solid #4caf50;
    color: #4caf50;
    padding: 8px 20px;
    border-radius: 8px;
    font-size: 0.85rem;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s, transform 0.3s;
  }
  .save-toast.visible { opacity: 1; transform: translateX(-50%) translateY(0); }

  /* Action progress bar */
  .action-bar-wrap {
    position: fixed;
    bottom: 70px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10;
    width: 200px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
  }
  .action-bar-wrap.visible { opacity: 1; }
  .action-bar-label {
    text-align: center;
    color: #fff;
    font-size: 0.8rem;
    margin-bottom: 4px;
  }
  .action-bar-track {
    width: 100%;
    height: 6px;
    background: #333;
    border-radius: 3px;
    overflow: hidden;
  }
  .action-bar-fill {
    height: 100%;
    background: #4caf50;
    border-radius: 3px;
    width: 0%;
    transition: width 0.1s linear;
  }

  /* Mirror overlay */
  .mirror-overlay {
    background: #000000dd;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 12px;
  }
  .mirror-frame {
    border: 4px solid #c9a84c;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0 0 40px #c9a84c44, 0 0 80px #00000088;
    background: #1a1a28;
  }
  .mirror-frame canvas {
    display: block;
  }
  .mirror-label {
    font-family: 'Segoe UI', Tahoma, sans-serif;
    font-size: 1rem;
    color: #c9a84c;
    letter-spacing: 0.05em;
  }
  .mirror-hint {
    font-size: 0.75rem;
    color: #666;
  }

  /* Shop */
  .shop-btn {
    pointer-events: all;
    cursor: pointer;
    border: 1px solid #c9a84c44;
    transition: all 0.15s;
  }
  .shop-btn:hover {
    background: #000000cc;
    border-color: #c9a84c;
    color: #c9a84c;
  }
  .shop-overlay {
    position: fixed;
    inset: 0;
    z-index: 50;
    background: #000000cc;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
  }
  .shop-overlay.visible { opacity: 1; pointer-events: all; }
  .shop-panel {
    background: #1a1a28;
    border: 1px solid #333;
    border-radius: 12px;
    padding: 24px 32px;
    max-width: 420px;
    width: 85vw;
    max-height: 80vh;
    overflow-y: auto;
    box-shadow: 0 0 60px #00000088;
  }
  .shop-panel h2 {
    color: #eee;
    font-size: 1.2rem;
    margin-bottom: 16px;
    text-align: center;
  }
  .shop-item {
    background: #22223a;
    border: 1px solid #444;
    border-radius: 8px;
    padding: 14px 18px;
    margin-bottom: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 14px;
  }
  .shop-item-info { flex: 1; }
  .shop-item-name {
    color: #eee;
    font-size: 0.95rem;
    font-weight: 600;
  }
  .shop-item-desc {
    color: #888;
    font-size: 0.72rem;
    margin-top: 4px;
    line-height: 1.4;
  }
  .shop-item-btn {
    padding: 8px 16px;
    border-radius: 6px;
    border: none;
    font-size: 0.85rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
    white-space: nowrap;
  }
  .shop-item-btn.buy {
    background: linear-gradient(135deg, #4caf50, #388e3c);
    color: #fff;
  }
  .shop-item-btn.buy:hover { transform: scale(1.05); }
  .shop-item-btn.bought {
    background: #333;
    color: #666;
    cursor: default;
  }
  .shop-close {
    display: block;
    margin: 16px auto 0;
    padding: 8px 24px;
    border-radius: 6px;
    border: 1px solid #555;
    background: #333;
    color: #ccc;
    cursor: pointer;
    font-size: 0.85rem;
  }
  .shop-close:hover { background: #444; color: #fff; }

  /* Pet Menu */
  .pet-menu-overlay {
    position: fixed;
    inset: 0;
    z-index: 50;
    background: #00000088;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
  }
  .pet-menu-overlay.visible { opacity: 1; pointer-events: all; }
  .pet-menu-panel {
    background: #1a1a28;
    border: 1px solid #333;
    border-radius: 12px;
    padding: 24px 28px;
    max-width: 380px;
    width: 85vw;
    box-shadow: 0 0 60px #00000088;
  }
  .pet-menu-panel h2 {
    color: #eee;
    font-size: 1.2rem;
    margin-bottom: 16px;
    text-align: center;
  }
  .pet-option {
    background: #22223a;
    border: 2px solid #444;
    border-radius: 8px;
    padding: 12px 16px;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 14px;
    cursor: pointer;
    transition: all 0.15s;
  }
  .pet-option:hover { border-color: #888; background: #2a2a44; }
  .pet-option.active { border-color: #4caf50; background: #1e3a24; }
  .pet-option-icon { font-size: 1.6rem; width: 40px; text-align: center; }
  .pet-option-info { flex: 1; }
  .pet-option-name { color: #eee; font-size: 0.95rem; font-weight: 600; }
  .pet-option-desc { color: #888; font-size: 0.72rem; margin-top: 3px; }
  .pet-option-badge {
    font-size: 0.65rem;
    color: #4caf50;
    text-transform: uppercase;
    letter-spacing: 0.06em;
    font-weight: 600;
  }

  /* G Bux Achievement Toast */
  .gg-toast {
    position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%) translateY(80px);
    z-index: 200; background: linear-gradient(135deg, #1a1a22 0%, #2a2220 100%);
    border: 2px solid #c9a84c; border-radius: 8px; padding: 12px 24px;
    display: flex; align-items: center; gap: 12px;
    box-shadow: 0 0 30px #c9a84c44, 0 4px 20px #00000088;
    opacity: 0; transition: all 0.4s cubic-bezier(0.22, 1, 0.36, 1);
    pointer-events: none; font-family: 'Segoe UI', Tahoma, sans-serif;
  }
  .gg-toast.visible { opacity: 1; transform: translateX(-50%) translateY(0); }
  .gg-toast-icon { font-size: 1.8rem; }
  .gg-toast-title { font-size: 0.65rem; color: #c9a84c; text-transform: uppercase; letter-spacing: 0.1em; }
  .gg-toast-name { font-size: 0.95rem; color: #eee; font-weight: bold; }
  .gg-toast-reward { font-size: 0.85rem; color: #c9a84c; font-weight: bold; }

  /* Drive overlay */
  .drive-overlay {
    position: fixed;
    inset: 0;
    z-index: 60;
    background: #333;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    gap: 16px;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.4s;
  }
  .drive-overlay.visible { opacity: 1; pointer-events: all; }
  .drive-overlay .road {
    width: 120px;
    height: 100%;
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    background: #444;
    border-left: 4px solid #888;
    border-right: 4px solid #888;
    overflow: hidden;
  }
  .drive-overlay .road-lines {
    position: absolute;
    left: 50%;
    transform: translateX(-50%);
    width: 4px;
    height: 200%;
    background: repeating-linear-gradient(to bottom, #ffcc00 0px, #ffcc00 30px, transparent 30px, transparent 60px);
    animation: roadScroll 0.6s linear infinite;
  }
  @keyframes roadScroll {
    0% { top: -60px; }
    100% { top: 0px; }
  }
  .drive-overlay .drive-text {
    z-index: 1;
    color: #fff;
    font-size: 1.3rem;
    letter-spacing: 0.08em;
    text-shadow: 0 2px 8px #000;
  }

  /* NPC dialogue */
  .npc-dialogue-overlay {
    position: fixed;
    inset: 0;
    z-index: 50;
    background: #00000088;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
  }
  .npc-dialogue-overlay.visible { opacity: 1; pointer-events: all; }
  .npc-dialogue-panel {
    background: #1a1a28;
    border: 1px solid #333;
    border-radius: 12px;
    padding: 24px 28px;
    max-width: 420px;
    width: 85vw;
    box-shadow: 0 0 60px #00000088;
  }
  .npc-dialogue-panel h3 {
    color: #c9a84c;
    font-size: 1.1rem;
    margin-bottom: 12px;
  }
  .npc-dialogue-panel p {
    color: #ccc;
    font-size: 0.9rem;
    line-height: 1.5;
    margin-bottom: 16px;
  }
  .npc-dialogue-btns {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
  }
  .npc-dialogue-btns button {
    padding: 8px 18px;
    border-radius: 6px;
    border: none;
    font-size: 0.85rem;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s;
  }
  .npc-dialogue-btns .npc-btn-accept {
    background: linear-gradient(135deg, #4caf50, #388e3c);
    color: #fff;
  }
  .npc-dialogue-btns .npc-btn-accept:hover { transform: scale(1.05); }
  .npc-dialogue-btns .npc-btn-close {
    background: #333;
    color: #ccc;
    border: 1px solid #555;
  }
  .npc-dialogue-btns .npc-btn-close:hover { background: #444; color: #fff; }

  /* Drive destination chooser */
  .drive-dest-overlay {
    position: fixed;
    inset: 0;
    z-index: 50;
    background: #00000088;
    display: flex;
    align-items: center;
    justify-content: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
  }
  .drive-dest-overlay.visible { opacity: 1; pointer-events: all; }
  .drive-dest-panel {
    background: #1a1a28;
    border: 1px solid #333;
    border-radius: 12px;
    padding: 24px 28px;
    max-width: 320px;
    width: 85vw;
    box-shadow: 0 0 60px #00000088;
    text-align: center;
  }
  .drive-dest-title {
    color: #c9a84c;
    font-size: 1.1rem;
    font-weight: 700;
    margin-bottom: 16px;
  }
  .drive-dest-btn {
    display: block;
    width: 100%;
    padding: 10px 18px;
    border-radius: 6px;
    border: none;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    margin-bottom: 8px;
    transition: all 0.15s;
    background: linear-gradient(135deg, #4caf50, #388e3c);
    color: #fff;
  }
  .drive-dest-btn:hover { transform: scale(1.03); }
  .drive-dest-btn.cancel {
    background: #333;
    color: #ccc;
    border: 1px solid #555;
  }
  .drive-dest-btn.cancel:hover { background: #444; color: #fff; }
</style>
</head>
<body>

<div class="gg-toast" id="gg-toast">
  <div class="gg-toast-icon">&#127942;</div>
  <div style="display:flex;flex-direction:column">
    <div class="gg-toast-title">Achievement Unlocked!</div>
    <div class="gg-toast-name" id="gg-toast-name"></div>
  </div>
  <div class="gg-toast-reward" id="gg-toast-reward"></div>
</div>

<!-- Character Creator -->
<div class="creator-screen" id="creator-screen">
  <div class="creator-panel">
    <div class="creator-left">
      <h2>Create Your Character</h2>

      <div class="creator-row">
        <label>Skin Tone</label>
        <div class="creator-options" id="skin-options"></div>
      </div>

      <div class="creator-row">
        <label>Gender</label>
        <div class="creator-options" id="gender-options">
          <button class="toggle-btn selected" data-val="male" onclick="setGender('male',this)">Male</button>
          <button class="toggle-btn" data-val="female" onclick="setGender('female',this)">Female</button>
        </div>
      </div>

      <div class="creator-row">
        <label>Hair Style</label>
        <div class="creator-options" id="hair-style-options">
          <button class="toggle-btn selected" data-val="short" onclick="setHairStyle('short',this)">Short</button>
          <button class="toggle-btn" data-val="long" onclick="setHairStyle('long',this)">Long</button>
          <button class="toggle-btn" data-val="curly" onclick="setHairStyle('curly',this)">Curly</button>
          <button class="toggle-btn" data-val="buzz" onclick="setHairStyle('buzz',this)">Buzz Cut</button>
        </div>
      </div>

      <div class="creator-row">
        <label>Hair Color</label>
        <div class="creator-options" id="hair-color-options"></div>
      </div>

      <button class="start-btn" onclick="startGame()">START GAME</button>
      <div class="save-slots">
        <div class="save-slots-title">Saved Games</div>
        <div id="save-slot-list"></div>
      </div>
    </div>
    <div class="creator-right">
      <canvas id="preview-canvas" width="200" height="300"></canvas>
    </div>
  </div>
</div>

<!-- Crosshair -->
<div class="crosshair" id="crosshair"></div>

<!-- Controls hint -->
<div class="controls-hint">
  <kbd>W</kbd><kbd>A</kbd><kbd>S</kbd><kbd>D</kbd> Move &nbsp; Mouse: Look<br>
  <kbd>Click</kbd> Interact &nbsp; <kbd>ESC</kbd> Release cursor<br>
  <kbd>P</kbd> Shop &nbsp; <kbd>T</kbd> Pet
</div>

<!-- Back to launcher -->
<a href="../graham-games/index.html" class="back-btn">
  <svg viewBox="0 0 12 12"><path d="M9,1 L3,6 L9,11" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>
  EXIT TO LAUNCHER
</a>

<!-- HUD: Needs -->
<div class="hud">
  <div class="need-bar">
    <div class="need-icon">&#127829;</div>
    <div class="need-label">Hunger</div>
    <div class="need-track"><div class="need-fill" id="bar-hunger" style="width:100%; background:#4caf50;"></div></div>
    <div class="need-val" id="val-hunger">100</div>
  </div>
  <div class="need-bar">
    <div class="need-icon">&#9889;</div>
    <div class="need-label">Energy</div>
    <div class="need-track"><div class="need-fill" id="bar-energy" style="width:100%; background:#2196f3;"></div></div>
    <div class="need-val" id="val-energy">100</div>
  </div>
  <div class="need-bar">
    <div class="need-icon">&#127918;</div>
    <div class="need-label">Fun</div>
    <div class="need-track"><div class="need-fill" id="bar-fun" style="width:100%; background:#ff9800;"></div></div>
    <div class="need-val" id="val-fun">100</div>
  </div>
  <div class="need-bar">
    <div class="need-icon">&#128703;</div>
    <div class="need-label">Hygiene</div>
    <div class="need-track"><div class="need-fill" id="bar-hygiene" style="width:100%; background:#00bcd4;"></div></div>
    <div class="need-val" id="val-hygiene">100</div>
  </div>
</div>

<!-- HUD: Money + Time -->
<div class="hud-top-right">
  <div class="hud-pill"><span>&#128176;</span> <span id="money-val">50</span></div>
  <div class="hud-pill"><span id="time-icon">&#9728;&#65039;</span> <span id="time-val">6:00 AM</span></div>
  <div class="hud-pill"><span>Day</span> <span id="day-val">1</span></div>
  <div class="hud-pill shop-btn" onclick="toggleShop()">&#128241; SHOP</div>
  <div class="hud-pill shop-btn" id="pet-menu-btn" style="display:none;" onclick="togglePetMenu()">&#128062; PET</div>
  <div class="hud-pill shop-btn" onclick="saveGame()">&#128190; SAVE</div>
</div>

<div class="save-toast" id="save-toast">Game saved!</div>

<div class="name-prompt-overlay" id="name-prompt-overlay">
  <div class="name-prompt-panel">
    <h3>Name Your Save</h3>
    <input type="text" id="name-prompt-input" maxlength="20" placeholder="Enter a name...">
    <button id="name-prompt-ok">OK</button>
  </div>
</div>

<!-- Action tooltip -->
<div class="action-tip" id="action-tip"></div>

<!-- Action progress -->
<div class="action-bar-wrap" id="action-bar-wrap">
  <div class="action-bar-label" id="action-bar-label">Eating...</div>
  <div class="action-bar-track"><div class="action-bar-fill" id="action-bar-fill"></div></div>
</div>

<!-- Action animation overlays -->
<div class="action-overlay sleep-overlay" id="sleep-overlay"></div>
<div class="action-overlay shower-overlay" id="shower-overlay"></div>
<div class="action-overlay eat-overlay" id="eat-overlay"></div>
<div class="action-overlay tv-overlay" id="tv-overlay"></div>
<div class="action-overlay computer-overlay" id="computer-overlay"></div>
<div class="action-overlay mirror-overlay" id="mirror-overlay"></div>
<div class="action-overlay job-overlay" id="job-overlay"></div>

<!-- Game Over -->
<div class="game-over" id="game-over">
  <h1>GAME OVER</h1>
  <p id="game-over-reason">You passed out from exhaustion!</p>
  <button onclick="restartGame()">Try Again</button>
</div>

<!-- Shop -->
<div class="shop-overlay" id="shop-overlay">
  <div class="shop-panel">
    <h2>&#128241; Phone Shop</h2>
    <div id="shop-items"></div>
    <button class="shop-close" onclick="toggleShop()">Close</button>
  </div>
</div>

<!-- Pet Menu -->
<div class="pet-menu-overlay" id="pet-menu-overlay">
  <div class="pet-menu-panel">
    <h2>&#128062; Choose Pet</h2>
    <div id="pet-options"></div>
    <button class="shop-close" onclick="togglePetMenu()">Close</button>
  </div>
</div>

<!-- Drive Destination Chooser -->
<div class="drive-dest-overlay" id="drive-dest-overlay">
  <div class="drive-dest-panel">
    <div class="drive-dest-title">Where to?</div>
    <button class="drive-dest-btn" onclick="chooseDriveDest('town')">Drive to Town</button>
    <button class="drive-dest-btn" id="drive-mansion-btn" onclick="chooseDriveDest('mansion')" style="display:none">Drive to Mansion</button>
    <button class="drive-dest-btn cancel" onclick="closeDriveDestMenu()">Cancel</button>
  </div>
</div>

<!-- Drive Overlay -->
<div class="drive-overlay" id="drive-overlay">
  <div class="road"><div class="road-lines"></div></div>
  <div class="drive-text" id="drive-text">Driving to town...</div>
</div>

<!-- NPC Dialogue -->
<div class="npc-dialogue-overlay" id="npc-dialogue-overlay">
  <div class="npc-dialogue-panel">
    <h3 id="npc-dialogue-name">NPC Name</h3>
    <p id="npc-dialogue-text">Dialogue text...</p>
    <div class="npc-dialogue-btns" id="npc-dialogue-btns"></div>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ═══ G BUX SYSTEM ═══
const GG_KEY = 'graham-games-data';
function ggLoad() {
  try { return JSON.parse(localStorage.getItem(GG_KEY)) || { gBux: 0, achievements: {}, shopPurchases: {} }; }
  catch(e) { return { gBux: 0, achievements: {}, shopPurchases: {} }; }
}
function ggSave(data) { localStorage.setItem(GG_KEY, JSON.stringify(data)); }
function ggUnlockAchievement(id, name, reward) {
  const data = ggLoad();
  if (data.achievements[id]) return false;
  data.achievements[id] = true;
  data.gBux += reward;
  ggSave(data);
  showAchievementToast(name, reward);
  return true;
}
let ggToastQueue = [], ggToastShowing = false;
function showAchievementToast(name, reward) {
  ggToastQueue.push({ name, reward });
  if (!ggToastShowing) processToastQueue();
}
function processToastQueue() {
  if (!ggToastQueue.length) { ggToastShowing = false; return; }
  ggToastShowing = true;
  const { name, reward } = ggToastQueue.shift();
  document.getElementById('gg-toast-name').textContent = name;
  document.getElementById('gg-toast-reward').textContent = '+' + reward + ' G Bux';
  document.getElementById('gg-toast').classList.add('visible');
  setTimeout(() => {
    document.getElementById('gg-toast').classList.remove('visible');
    setTimeout(processToastQueue, 400);
  }, 3000);
}

const ML_ACH = {
  ml_new_home:          { name: 'New Home',          reward: 5 },
  ml_survivor:          { name: 'Survivor',          reward: 10 },
  ml_week_warrior:      { name: 'Week Warrior',      reward: 20 },
  ml_shopaholic:        { name: 'Shopaholic',        reward: 10 },
  ml_interior_designer: { name: 'Interior Designer', reward: 25 },
  ml_fashion_icon:      { name: 'Fashion Icon',      reward: 10 },
  ml_moving_up:         { name: 'Moving Up',         reward: 20 },
  ml_arcade_pro:        { name: 'Arcade Pro',        reward: 15 },
  ml_high_roller:       { name: 'High Roller',       reward: 20 },
  ml_living_large:      { name: 'Living Large',      reward: 50 },
  ml_bookworm:          { name: 'Knowledge is Power', reward: 50 },
  ml_gym_rat:           { name: 'Gym Rat',            reward: 50 },
  ml_helpful_neighbor:  { name: 'Helpful Neighbor',   reward: 25 },
  ml_town_hero:         { name: 'Town Hero',          reward: 50 },
  ml_mansion_mogul:     { name: 'Mansion Mogul',      reward: 75 },
  ml_first_shift:       { name: 'First Shift',         reward: 10 },
  ml_hard_worker:       { name: 'Hard Worker',         reward: 25 },
  ml_employee_month:    { name: 'Employee of the Month', reward: 50 },
};
function mlTry(id) { const a = ML_ACH[id]; if (a) ggUnlockAchievement(id, a.name, a.reward); }
function mlCheckLivingLarge() {
  if (hasSecondFloor && ownedFurniture.size >= 4 && ownedOutfits.size >= OUTFITS.length) {
    mlTry('ml_living_large');
  }
}

// ═══ SCENE SETUP ═══
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);
scene.fog = new THREE.Fog(0x87ceeb, 30, 60);
const HOME_FOG_FAR = 60;
const TOWN_FOG_FAR = 120;
const MANSION_FOG_FAR = 150;

const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.05, 100);
camera.position.set(0, 1.5, 0);
camera.lookAt(0, 1.5, -1);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// ═══ LIGHTING ═══
const ambientLight = new THREE.AmbientLight(0x666688, 0.5);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xffeedd, 1.0);
sunLight.position.set(8, 15, 5);
sunLight.castShadow = true;
sunLight.shadow.mapSize.set(1024, 1024);
sunLight.shadow.camera.near = 0.5;
sunLight.shadow.camera.far = 50;
sunLight.shadow.camera.left = -15;
sunLight.shadow.camera.right = 15;
sunLight.shadow.camera.top = 20;
sunLight.shadow.camera.bottom = -15;
scene.add(sunLight);

const hemiLight = new THREE.HemisphereLight(0x88aacc, 0x445522, 0.3);
scene.add(hemiLight);

// ═══ SOUND EFFECTS ═══
const SFX = (() => {
  let ctx = null;
  let master = null;
  let noiseBuffer = null;
  let activeNodes = [];
  let musicInterval = null;
  let musicGain = null;

  function init() {
    if (ctx) return;
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    master = ctx.createGain();
    master.gain.value = 0.7;
    master.connect(ctx.destination);
    const len = ctx.sampleRate * 2;
    noiseBuffer = ctx.createBuffer(1, len, ctx.sampleRate);
    const data = noiseBuffer.getChannelData(0);
    for (let i = 0; i < len; i++) data[i] = Math.random() * 2 - 1;
  }

  function osc(type, freq, duration, gain = 0.3, freqEnd) {
    if (!ctx) return;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, ctx.currentTime);
    if (freqEnd) o.frequency.linearRampToValueAtTime(freqEnd, ctx.currentTime + duration);
    g.gain.setValueAtTime(gain, ctx.currentTime);
    g.gain.linearRampToValueAtTime(0, ctx.currentTime + duration);
    o.connect(g); g.connect(master);
    o.start(ctx.currentTime);
    o.stop(ctx.currentTime + duration);
  }

  function noiseBurst(filterFreq, filterType, duration, gain = 0.2) {
    if (!ctx) return;
    const src = ctx.createBufferSource();
    src.buffer = noiseBuffer;
    const filter = ctx.createBiquadFilter();
    filter.type = filterType;
    filter.frequency.value = filterFreq;
    const g = ctx.createGain();
    g.gain.setValueAtTime(gain, ctx.currentTime);
    g.gain.linearRampToValueAtTime(0, ctx.currentTime + duration);
    src.connect(filter); filter.connect(g); g.connect(master);
    src.start(ctx.currentTime);
    src.stop(ctx.currentTime + duration);
  }

  // Play a note through the music gain bus
  function musicNote(type, freq, duration, gain) {
    if (!ctx || !musicGain) return;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, ctx.currentTime);
    g.gain.setValueAtTime(gain, ctx.currentTime);
    g.gain.setValueAtTime(gain * 0.8, ctx.currentTime + duration * 0.6);
    g.gain.linearRampToValueAtTime(0, ctx.currentTime + duration);
    o.connect(g); g.connect(musicGain);
    o.start(ctx.currentTime);
    o.stop(ctx.currentTime + duration);
  }

  function stopLoops() {
    activeNodes.forEach(n => {
      try { n.gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.3); } catch(e) {}
      try { setTimeout(() => n.source.stop(), 400); } catch(e) {}
    });
    activeNodes = [];
  }

  // ── Background music tracks ──
  const N = {
    C3:130.81, D3:146.83, E3:164.81, F3:174.61, G3:196.00, A3:220.00, B3:246.94,
    C4:261.63, D4:293.66, E4:329.63, F4:349.23, G4:392.00, A4:440.00, B4:493.88,
    C5:523.25, D5:587.33, E5:659.25, F5:698.46, G5:783.99, A5:880.00,
    Eb3:155.56, Bb3:233.08, Eb4:311.13, Gb4:369.99, Bb4:466.16, Db5:554.37, Eb5:622.25, Gb5:739.99, Ab5:830.61,
    Fs3:185.00, Fs4:369.99, Gs4:415.30, Cs5:554.37,
  };

  const TRACKS = {
    happyDays: {
      name: 'Happy Days',
      bpm: 138,
      melodyWave: 'square', melodyGain: 0.10,
      bassWave: 'triangle', bassGain: 0.14,
      chordWave: 'triangle', chordGain: 0.05,
      kickFreq: 55, kickGain: 0.18,
      hihatFreq: 8000, hihatGain: 0.04,
      melody: [
        N.C5, 0, N.E5, 0, N.G5, 0, N.E5, 0, N.C5, 0, N.D5, 0, N.E5, N.D5, N.C5, 0,
        N.F5, 0, N.A5, 0, N.G5, 0, N.F5, 0, N.E5, 0, N.D5, 0, N.E5, 0, N.C5, 0,
        N.G4, 0, N.B4, N.C5, N.D5, 0, N.E5, 0, N.D5, 0, N.C5, N.B4, N.A4, 0, N.B4, 0,
        N.C5, 0, N.E5, 0, N.G5, N.A5, N.G5, 0, N.E5, 0, N.D5, 0, N.C5, 0, 0, 0,
      ],
      bass: [
        N.C3, N.C3, N.E3, N.G3,
        N.F3, N.F3, N.A3, N.C4,
        N.G3, N.G3, N.B3, N.G3,
        N.C3, N.E3, N.G3, N.C4,
      ],
      chords: [
        [N.C4, N.E4, N.G4],
        [N.F4, N.A4, N.C5],
        [N.G4, N.B4, N.D5],
        [N.C4, N.E4, N.G4],
      ],
    },
    popStar: {
      name: 'Pop Star',
      bpm: 120,
      melodyWave: 'sine', melodyGain: 0.13,
      bassWave: 'triangle', bassGain: 0.12,
      chordWave: 'sine', chordGain: 0.06,
      kickFreq: 50, kickGain: 0.20,
      hihatFreq: 9000, hihatGain: 0.05,
      melody: [
        // Bar 1: catchy hook
        N.E5, N.E5, 0, N.D5, N.C5, 0, N.D5, 0, N.E5, 0, N.G5, 0, N.E5, 0, 0, 0,
        // Bar 2: answer phrase
        N.D5, N.D5, 0, N.C5, N.B4, 0, N.C5, 0, N.D5, 0, N.E5, 0, N.C5, 0, 0, 0,
        // Bar 3: build up
        N.G5, 0, N.A5, 0, N.G5, 0, N.E5, 0, N.D5, 0, N.E5, N.G5, N.A5, 0, N.G5, 0,
        // Bar 4: resolve with flair
        N.E5, 0, N.D5, 0, N.C5, 0, N.D5, N.E5, N.C5, 0, 0, 0, 0, 0, 0, 0,
      ],
      bass: [
        N.C3, N.C3, N.G3, N.G3,
        N.A3, N.A3, N.E3, N.E3,
        N.F3, N.F3, N.C4, N.C4,
        N.G3, N.G3, N.C3, N.C3,
      ],
      chords: [
        [N.C4, N.E4, N.G4],
        [N.A3, N.C4, N.E4],
        [N.F4, N.A4, N.C5],
        [N.G4, N.B4, N.D5],
      ],
    },
    heavyMetal: {
      name: 'Heavy Metal',
      bpm: 170,
      melodyWave: 'sawtooth', melodyGain: 0.09,
      bassWave: 'sawtooth', bassGain: 0.16,
      chordWave: 'sawtooth', chordGain: 0.07,
      kickFreq: 45, kickGain: 0.22,
      hihatFreq: 6000, hihatGain: 0.06,
      melody: [
        // Bar 1: aggressive riff
        N.E4, N.E4, N.E4, 0, N.G4, 0, N.A4, N.G4, N.E4, 0, N.D4, 0, N.E4, 0, 0, N.E4,
        // Bar 2: chromatic climb
        N.E4, 0, N.F4, 0, N.Fs4, 0, N.G4, 0, N.Gs4, 0, N.A4, 0, N.B4, N.A4, N.G4, 0,
        // Bar 3: power drive
        N.B4, N.B4, 0, N.A4, N.G4, N.G4, 0, N.E4, N.D4, N.E4, N.G4, 0, N.A4, 0, N.B4, 0,
        // Bar 4: brutal finish
        N.E5, 0, N.D5, 0, N.B4, 0, N.A4, N.G4, N.E4, 0, 0, N.E4, N.E4, N.E4, 0, 0,
      ],
      bass: [
        N.E3, N.E3, N.E3, N.G3,
        N.E3, N.F3, N.Fs3, N.G3,
        N.B3, N.A3, N.G3, N.E3,
        N.E3, N.D3, N.B3, N.E3,
      ],
      chords: [
        [N.E4, N.B4, N.E5],
        [N.G4, N.B4, N.D5],
        [N.A4, N.C5, N.E5],
        [N.E4, N.B4, N.E5],
      ],
    },
  };

  const TRACK_ORDER = ['happyDays', 'popStar', 'heavyMetal'];
  let currentTrackId = 'happyDays';
  let musicStep = 0;

  function playMusicStep() {
    if (!ctx || !musicGain) return;
    const track = TRACKS[currentTrackId];
    const STEP_MS = Math.round(60000 / track.bpm / 4);
    const stepDur = STEP_MS / 1000;

    // Melody
    const note = track.melody[musicStep % track.melody.length];
    if (note) musicNote(track.melodyWave, note, stepDur * 1.8, track.melodyGain);

    // Bass: every 4 steps
    if (musicStep % 4 === 0) {
      const bassNote = track.bass[Math.floor(musicStep / 4) % track.bass.length];
      if (bassNote) musicNote(track.bassWave, bassNote, stepDur * 3.5, track.bassGain);
    }

    // Chords: every 16 steps
    if (musicStep % 16 === 0) {
      const chord = track.chords[Math.floor(musicStep / 16) % track.chords.length];
      chord.forEach(f => musicNote(track.chordWave, f, stepDur * 6, track.chordGain));
    }

    // Percussion: kick every 4 steps, hihat every 2
    if (musicStep % 4 === 0) {
      musicNote('sine', track.kickFreq, 0.1, track.kickGain);
    }
    if (musicStep % 2 === 0) {
      if (noiseBuffer) {
        const src = ctx.createBufferSource();
        src.buffer = noiseBuffer;
        const filter = ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = track.hihatFreq;
        const g = ctx.createGain();
        g.gain.setValueAtTime(track.hihatGain, ctx.currentTime);
        g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.04);
        src.connect(filter); filter.connect(g); g.connect(musicGain);
        src.start(ctx.currentTime);
        src.stop(ctx.currentTime + 0.05);
      }
    }

    musicStep++;
  }

  return {
    init, stopLoops,
    get currentTrackId() { return currentTrackId; },
    set currentTrackId(id) { currentTrackId = id; },
    get trackName() { return TRACKS[currentTrackId].name; },
    TRACK_ORDER,

    startMusic() {
      if (!ctx) return;
      if (musicInterval) return;
      musicGain = ctx.createGain();
      musicGain.gain.value = 0.5;
      musicGain.connect(master);
      musicStep = 0;
      const stepMs = Math.round(60000 / TRACKS[currentTrackId].bpm / 4);
      playMusicStep();
      musicInterval = setInterval(playMusicStep, stepMs);
    },

    stopMusic() {
      if (musicInterval) { clearInterval(musicInterval); musicInterval = null; }
      if (musicGain) {
        try { musicGain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5); } catch(e) {}
        setTimeout(() => { if (musicGain) { musicGain.disconnect(); musicGain = null; } }, 600);
      }
    },

    switchTrack(trackId) {
      if (trackId) {
        currentTrackId = trackId;
      } else {
        const idx = TRACK_ORDER.indexOf(currentTrackId);
        currentTrackId = TRACK_ORDER[(idx + 1) % TRACK_ORDER.length];
      }
      this.stopMusic();
      setTimeout(() => this.startMusic(), 650);
      return TRACKS[currentTrackId].name;
    },

    getNextTrackName() {
      const idx = TRACK_ORDER.indexOf(currentTrackId);
      return TRACKS[TRACK_ORDER[(idx + 1) % TRACK_ORDER.length]].name;
    },

    doorCreak() {
      if (!ctx) return;
      osc('sawtooth', 80, 0.3, 0.1, 120);
      osc('sine', 180, 0.2, 0.08, 140);
      noiseBurst(600, 'bandpass', 0.15, 0.05);
    },

    footstep() {
      if (!ctx) return;
      osc('sine', 60 + Math.random() * 30, 0.08, 0.15);
      noiseBurst(800, 'lowpass', 0.06, 0.06);
    },

    actionComplete() {
      if (!ctx) return;
      osc('sine', 523, 0.12, 0.25);
      setTimeout(() => osc('sine', 659, 0.18, 0.25), 100);
    },

    eat() {
      if (!ctx) return;
      noiseBurst(2000 + Math.random() * 1000, 'highpass', 0.08, 0.12);
      setTimeout(() => noiseBurst(2500, 'highpass', 0.06, 0.10), 80);
    },

    startShower() {
      if (!ctx) return;
      const src = ctx.createBufferSource();
      src.buffer = noiseBuffer;
      src.loop = true;
      const filter = ctx.createBiquadFilter();
      filter.type = 'bandpass';
      filter.frequency.value = 3000;
      filter.Q.value = 0.5;
      const g = ctx.createGain();
      g.gain.value = 0.15;
      src.connect(filter); filter.connect(g); g.connect(master);
      src.start();
      activeNodes.push({ source: src, gain: g });
    },

    startSleep() {
      if (!ctx) return;
      const o1 = ctx.createOscillator();
      const o2 = ctx.createOscillator();
      o1.type = 'sine'; o1.frequency.value = 80;
      o2.type = 'sine'; o2.frequency.value = 82;
      const g = ctx.createGain();
      g.gain.value = 0.08;
      o1.connect(g); o2.connect(g); g.connect(master);
      o1.start(); o2.start();
      activeNodes.push({ source: o1, gain: g });
      activeNodes.push({ source: o2, gain: g });
    },

    tvStatic() {
      if (!ctx) return;
      noiseBurst(8000, 'lowpass', 0.15, 0.12);
    },

    gameOver() {
      if (!ctx) return;
      osc('square', 440, 0.2, 0.15);
      setTimeout(() => osc('square', 330, 0.2, 0.15), 180);
      setTimeout(() => osc('sawtooth', 220, 0.5, 0.12), 360);
    },

    mgJump() {
      if (!ctx) return;
      osc('square', 250, 0.1, 0.12, 600);
    },

    mgCoin() {
      if (!ctx) return;
      osc('sine', 988, 0.06, 0.2);
      setTimeout(() => osc('sine', 1319, 0.1, 0.2), 50);
    },

    mgHit() {
      if (!ctx) return;
      osc('sawtooth', 80, 0.15, 0.15);
      noiseBurst(400, 'lowpass', 0.1, 0.1);
    },

    mgStart() {
      if (!ctx) return;
      osc('square', 660, 0.1, 0.15);
    },

    dayChime() {
      if (!ctx) return;
      osc('sine', 440, 0.1, 0.15);
      setTimeout(() => osc('sine', 554, 0.1, 0.15), 100);
      setTimeout(() => osc('sine', 659, 0.15, 0.15), 200);
    },

    kaChing() {
      if (!ctx) return;
      osc('sine', 1200, 0.08, 0.15);
      setTimeout(() => osc('triangle', 2400, 0.12, 0.12), 60);
      setTimeout(() => noiseBurst(6000, 'highpass', 0.05, 0.08), 40);
    },
    jobCorrect() {
      if (!ctx) return;
      osc('sine', 880, 0.08, 0.2);
      setTimeout(() => osc('sine', 1100, 0.1, 0.15), 60);
    },
    jobWrong() {
      if (!ctx) return;
      osc('sawtooth', 200, 0.12, 0.15);
      noiseBurst(300, 'lowpass', 0.08, 0.08);
    },
    jobComplete() {
      if (!ctx) return;
      osc('sine', 523, 0.1, 0.2);
      setTimeout(() => osc('sine', 659, 0.1, 0.2), 80);
      setTimeout(() => osc('sine', 784, 0.15, 0.2), 160);
    },
  };
})();

// ═══ MATERIALS ═══
const mat = {
  floor: new THREE.MeshLambertMaterial({ color: 0xdeb887 }),
  wall: new THREE.MeshLambertMaterial({ color: 0xf5e6ca }),
  wallInner: new THREE.MeshLambertMaterial({ color: 0xfff8ee }),
  grass: new THREE.MeshLambertMaterial({ color: 0x4a8c3f }),
  skin: new THREE.MeshLambertMaterial({ color: 0xf4c794 }),
  shirt: new THREE.MeshLambertMaterial({ color: 0x4488cc }),
  pants: new THREE.MeshLambertMaterial({ color: 0x334466 }),
  hair: new THREE.MeshLambertMaterial({ color: 0x4a3222 }),
  fridge: new THREE.MeshLambertMaterial({ color: 0xdddddd }),
  bed: new THREE.MeshLambertMaterial({ color: 0x6a4e3a }),
  bedsheet: new THREE.MeshLambertMaterial({ color: 0x4488aa }),
  pillow: new THREE.MeshLambertMaterial({ color: 0xeeeedd }),
  tv: new THREE.MeshLambertMaterial({ color: 0x222222 }),
  tvScreen: new THREE.MeshLambertMaterial({ color: 0x335577, emissive: 0x112233, emissiveIntensity: 0.5 }),
  couch: new THREE.MeshLambertMaterial({ color: 0x8b5e3c }),
  couchCushion: new THREE.MeshLambertMaterial({ color: 0xa0714f }),
  shower: new THREE.MeshLambertMaterial({ color: 0xaaccdd }),
  showerMetal: new THREE.MeshLambertMaterial({ color: 0xcccccc }),
  table: new THREE.MeshLambertMaterial({ color: 0x8b6e4e }),
  chrome: new THREE.MeshLambertMaterial({ color: 0xbbbbbb }),
  rubber: new THREE.MeshLambertMaterial({ color: 0x333333 }),
  water: new THREE.MeshLambertMaterial({ color: 0x3399cc, transparent: true, opacity: 0.55 }),
  sand: new THREE.MeshLambertMaterial({ color: 0xddcc88 }),
  rug: new THREE.MeshLambertMaterial({ color: 0xcc8855 }),
  door: new THREE.MeshLambertMaterial({ color: 0x6a4e3a }),
  window: new THREE.MeshLambertMaterial({ color: 0xaaddff, transparent: true, opacity: 0.4 }),
  monitor: new THREE.MeshLambertMaterial({ color: 0x1a1a1a }),
  monitorScreen: new THREE.MeshLambertMaterial({ color: 0x224466, emissive: 0x112244, emissiveIntensity: 0.6 }),
  keyboard: new THREE.MeshLambertMaterial({ color: 0x2a2a2a }),
};

// ═══ WORLD ═══
// Ground
const groundGeo = new THREE.PlaneGeometry(40, 40);
const ground = new THREE.Mesh(groundGeo, mat.grass);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.01;
ground.receiveShadow = true;
scene.add(ground);

// Floor
const floorGeo = new THREE.BoxGeometry(10, 0.15, 10);
const floor = new THREE.Mesh(floorGeo, mat.floor);
floor.position.set(0, 0.075, 0);
floor.receiveShadow = true;
scene.add(floor);

// Rug
const rugGeo = new THREE.BoxGeometry(3, 0.02, 2);
const rug = new THREE.Mesh(rugGeo, mat.rug);
rug.position.set(0, 0.16, 0);
scene.add(rug);

// Walls
function makeWall(w, h, d, x, y, z) {
  const geo = new THREE.BoxGeometry(w, h, d);
  const wall = new THREE.Mesh(geo, mat.wall);
  wall.position.set(x, y, z);
  wall.castShadow = true;
  wall.receiveShadow = true;
  scene.add(wall);
  return wall;
}
// Back wall
makeWall(10.3, 3.5, 0.15, 0, 1.75, -5);
// Left wall
makeWall(0.15, 3.5, 10, -5, 1.75, 0);
// Right wall (partial - with gap for door)
makeWall(0.15, 3.5, 4, 5, 1.75, -3);
makeWall(0.15, 3.5, 3.5, 5, 1.75, 3.25);
makeWall(0.15, 1.2, 2.5, 5, 2.9, 0.75); // above door

// Front wall
makeWall(10.3, 3.5, 0.15, 0, 1.75, 5);

// Door (pivot group for swing animation, hinge at south edge of gap)
const doorPivot = new THREE.Group();
doorPivot.position.set(5.05, 0, -0.5);
const doorGeo = new THREE.BoxGeometry(0.1, 2.3, 2.5);
const doorMesh = new THREE.Mesh(doorGeo, mat.door);
doorMesh.position.set(0, 1.15, 1.25); // offset so edge aligns with pivot
doorPivot.add(doorMesh);
scene.add(doorPivot);

// Door state
let doorOpen = false;
let doorAnimating = false;
let doorAngle = 0;
const DOOR_OPEN_ANGLE = -Math.PI / 2;
const DOOR_ANIM_SPEED = Math.PI; // ~0.5s for 90 degrees

// Window (back wall)
const winGeo = new THREE.BoxGeometry(2, 1.5, 0.1);
const win = new THREE.Mesh(winGeo, mat.window);
win.position.set(-1.5, 2.2, -4.9);
scene.add(win);

// ═══ FURNITURE ═══
const interactables = [];

// Door interactable
interactables.push({ mesh: doorMesh, group: doorPivot, type: 'door', label: 'Open Door', need: null, usePos: new THREE.Vector3(4.0, 0.15, 0.75), floor: 0 });

// --- Fridge ---
function makeFridge() {
  const group = new THREE.Group();
  const body = new THREE.Mesh(new THREE.BoxGeometry(1, 2, 0.9), mat.fridge);
  body.position.set(0, 1, 0);
  body.castShadow = true;
  group.add(body);
  // Handle
  const handle = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.4, 0.05), mat.showerMetal);
  handle.position.set(0.45, 1.3, 0.4);
  group.add(handle);
  // Line between doors
  const line = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.02, 0.02), mat.showerMetal);
  line.position.set(0, 0.7, 0.46);
  group.add(line);
  group.position.set(-4, 0.15, -4);
  scene.add(group);
  interactables.push({ mesh: body, group, type: 'fridge', label: 'Eat (Fridge)', need: 'hunger', usePos: new THREE.Vector3(-3, 0.15, -3.5), floor: 0 });
  return group;
}

// --- Bed ---
function makeBed() {
  const group = new THREE.Group();
  // Frame
  const frame = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.5, 3.2), mat.bed);
  frame.position.set(0, 0.25, 0);
  frame.castShadow = true;
  group.add(frame);
  // Mattress
  const mattress = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 3), mat.bedsheet);
  mattress.position.set(0, 0.55, 0);
  group.add(mattress);
  // Pillow
  const pillow = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.15, 0.5), mat.pillow);
  pillow.position.set(0, 0.7, -1.1);
  group.add(pillow);
  // Headboard
  const headboard = new THREE.Mesh(new THREE.BoxGeometry(2.2, 1, 0.15), mat.bed);
  headboard.position.set(0, 0.8, -1.55);
  headboard.castShadow = true;
  group.add(headboard);
  group.position.set(-3.2, 0.15, 3);
  scene.add(group);
  interactables.push({ mesh: frame, group, type: 'bed', label: 'Sleep (Bed)', need: 'energy', usePos: new THREE.Vector3(-2, 0.15, 2), floor: 0 });
  return group;
}

// --- TV + Couch ---
function makeTVArea() {
  const group = new THREE.Group();
  // TV Stand
  const stand = new THREE.Mesh(new THREE.BoxGeometry(2, 0.6, 0.6), mat.table);
  stand.position.set(0, 0.3, -4.4);
  stand.castShadow = true;
  group.add(stand);
  // TV
  const tv = new THREE.Mesh(new THREE.BoxGeometry(2.2, 1.4, 0.1), mat.tv);
  tv.position.set(0, 1.4, -4.5);
  tv.castShadow = true;
  group.add(tv);
  // Screen
  const screen = new THREE.Mesh(new THREE.BoxGeometry(2, 1.2, 0.05), mat.tvScreen);
  screen.position.set(0, 1.4, -4.42);
  group.add(screen);
  // Couch
  const couchBase = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.5, 1), mat.couch);
  couchBase.position.set(0, 0.25, -2.2);
  couchBase.castShadow = true;
  group.add(couchBase);
  // Cushions
  const cush1 = new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.15, 0.9), mat.couchCushion);
  cush1.position.set(-0.6, 0.55, -2.2);
  group.add(cush1);
  const cush2 = new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.15, 0.9), mat.couchCushion);
  cush2.position.set(0.6, 0.55, -2.2);
  group.add(cush2);
  // Back rest
  const back = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.8, 0.2), mat.couch);
  back.position.set(0, 0.7, -1.65);
  back.castShadow = true;
  group.add(back);

  group.position.set(2.5, 0.15, 2);
  scene.add(group);
  interactables.push({ mesh: couchBase, group, type: 'tv', label: 'Watch TV (Couch)', need: 'fun', usePos: new THREE.Vector3(2.5, 0.15, 0.3), floor: 0 });
  return group;
}

// --- Shower ---
function makeShower() {
  const group = new THREE.Group();
  // Base
  const base = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.1, 1.5), mat.shower);
  base.position.set(0, 0.05, 0);
  group.add(base);
  // Glass walls (transparent)
  const glassMat = new THREE.MeshLambertMaterial({ color: 0xaaddff, transparent: true, opacity: 0.25 });
  const glass1 = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.2, 0.05), glassMat);
  glass1.position.set(0, 1.1, -0.725);
  group.add(glass1);
  const glass2 = new THREE.Mesh(new THREE.BoxGeometry(0.05, 2.2, 1.5), glassMat);
  glass2.position.set(0.725, 1.1, 0);
  group.add(glass2);
  // Shower head
  const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 2.2, 8), mat.showerMetal);
  pole.position.set(-0.5, 1.1, -0.5);
  group.add(pole);
  const head = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.1, 0.08, 12), mat.showerMetal);
  head.position.set(-0.5, 2.2, -0.5);
  group.add(head);

  group.position.set(3.5, 0.15, -3.5);
  scene.add(group);
  interactables.push({ mesh: base, group, type: 'shower', label: 'Shower', need: 'hygiene', usePos: new THREE.Vector3(2.5, 0.15, -3), floor: 0 });
  return group;
}

// --- Table ---
function makeTable() {
  const group = new THREE.Group();
  const top = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.08, 1.2), mat.table);
  top.position.set(0, 0.8, 0);
  top.castShadow = true;
  group.add(top);
  for (let dx of [-0.45, 0.45]) {
    for (let dz of [-0.45, 0.45]) {
      const leg = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.8, 0.08), mat.table);
      leg.position.set(dx, 0.4, dz);
      group.add(leg);
    }
  }
  group.position.set(-1.5, 0.15, -1);
  scene.add(group);
  return group;
}

// --- Computer Desk ---
function makeComputer() {
  const group = new THREE.Group();
  // Desk
  const deskTop = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.08, 0.8), mat.table);
  deskTop.position.set(0, 0.8, 0);
  deskTop.castShadow = true;
  group.add(deskTop);
  // Desk legs
  for (let dx of [-0.65, 0.65]) {
    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.8, 0.7), mat.table);
    leg.position.set(dx, 0.4, 0);
    group.add(leg);
  }
  // Monitor
  const monitorBody = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.7, 0.06), mat.monitor);
  monitorBody.position.set(0, 1.5, -0.2);
  monitorBody.castShadow = true;
  group.add(monitorBody);
  // Screen
  const screen = new THREE.Mesh(new THREE.BoxGeometry(0.88, 0.56, 0.02), mat.monitorScreen);
  screen.position.set(0, 1.5, -0.16);
  group.add(screen);
  // Monitor stand
  const monStand = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.3, 0.06), mat.monitor);
  monStand.position.set(0, 1.0, -0.2);
  group.add(monStand);
  const monBase = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.04, 0.2), mat.monitor);
  monBase.position.set(0, 0.86, -0.2);
  group.add(monBase);
  // Keyboard
  const kb = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.03, 0.2), mat.keyboard);
  kb.position.set(0, 0.86, 0.15);
  group.add(kb);
  // Chair
  const seat = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.08, 0.6), mat.monitor);
  seat.position.set(0, 0.5, 0.9);
  seat.castShadow = true;
  group.add(seat);
  const chairBack = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.6, 0.06), mat.monitor);
  chairBack.position.set(0, 0.84, 1.15);
  chairBack.castShadow = true;
  group.add(chairBack);

  group.position.set(-4, 0.15, 0);
  group.rotation.y = Math.PI / 2; // face right
  scene.add(group);
  interactables.push({ mesh: deskTop, group, type: 'computer', label: 'Play Games (Computer)', need: 'money', usePos: new THREE.Vector3(-3.2, 0.15, 0), floor: 0 });
  return group;
}

makeFridge();
makeBed();
makeTVArea();
makeShower();
makeTable();
makeComputer();

// --- Mirror ---
function makeMirror() {
  const group = new THREE.Group();
  // Frame
  const frameMat = new THREE.MeshLambertMaterial({ color: 0xc9a84c });
  const frame = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.6, 0.08), frameMat);
  frame.position.set(0, 1.6, 0);
  frame.castShadow = true;
  group.add(frame);
  // Glass
  const glassMat = new THREE.MeshLambertMaterial({ color: 0xaaccee, emissive: 0x334455, emissiveIntensity: 0.3 });
  const glass = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1.4, 0.04), glassMat);
  glass.position.set(0, 1.6, 0.03);
  group.add(glass);
  // Shine highlight
  const shineMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.15 });
  const shine = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1.0, 0.01), shineMat);
  shine.position.set(-0.2, 1.7, 0.06);
  shine.rotation.z = 0.1;
  group.add(shine);

  group.position.set(-2, 0.15, 4.85);
  scene.add(group);
  interactables.push({ mesh: glass, group, type: 'mirror', label: 'Look in Mirror', need: null, usePos: new THREE.Vector3(-2, 0.15, 3.5), floor: 0 });
  return group;
}
makeMirror();

// ═══ PURCHASABLE FURNITURE ═══
const SHOP_FURNITURE = [
  { id: 'lavaLamp',  name: 'Lava Lamp',  desc: 'Groovy lamp for the table. Restores a bit of fun.', cost: 30 },
  { id: 'fishTank',  name: 'Fish Tank',   desc: 'Relaxing aquarium with tropical fish.',             cost: 45 },
  { id: 'treadmill', name: 'Treadmill',   desc: 'Work out! Restores energy but makes you hungry.',   cost: 50 },
  { id: 'jukebox',   name: 'Jukebox',     desc: 'Blast some tunes. Big fun boost!',                  cost: 75 },
];
let ownedFurniture = new Set();
let furnitureGroups = {}; // id -> THREE.Group

function buildLavaLamp() {
  const g = new THREE.Group();
  // Base
  const baseMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
  const base = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 0.08, 8), baseMat);
  base.position.set(0, 0.04, 0);
  g.add(base);
  // Glass body
  const glassMat = new THREE.MeshLambertMaterial({ color: 0xcc2266, transparent: true, opacity: 0.5 });
  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.07, 0.35, 8), glassMat);
  body.position.set(0, 0.255, 0);
  g.add(body);
  // Lava blobs
  const lavaMat = new THREE.MeshLambertMaterial({ color: 0xff3366, emissive: 0xff1144, emissiveIntensity: 0.4 });
  const blob1 = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 6), lavaMat);
  blob1.position.set(0, 0.2, 0);
  g.add(blob1);
  const blob2 = new THREE.Mesh(new THREE.SphereGeometry(0.03, 8, 6), lavaMat);
  blob2.position.set(0.01, 0.32, 0);
  g.add(blob2);
  // Cap
  const cap = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.06, 0.04, 8), baseMat);
  cap.position.set(0, 0.44, 0);
  g.add(cap);
  // Glow light
  const glow = new THREE.PointLight(0xff3366, 0.3, 2);
  glow.position.set(0, 0.3, 0);
  g.add(glow);
  // Place on the table
  g.position.set(-1.5, 0.15 + 0.88, -1);
  scene.add(g);
  furnitureGroups.lavaLamp = g;
  interactables.push({ mesh: body, group: g, type: 'lavaLamp', label: 'Vibe with Lava Lamp', need: 'fun', usePos: new THREE.Vector3(-1, 0.15, -0.5), floor: 0 });
  actionConfig.lavaLamp = { label: 'Vibing...', duration: 3, restore: 25, cost: 0 };
}

function buildFishTank() {
  const g = new THREE.Group();
  // Tank frame
  const frameMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
  const stand = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.8, 0.5), mat.table);
  stand.position.set(0, 0.4, 0);
  stand.castShadow = true;
  g.add(stand);
  // Glass tank
  const tank = new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.7, 0.45), mat.water);
  tank.position.set(0, 1.15, 0);
  g.add(tank);
  // Tank top rim
  const rim = new THREE.Mesh(new THREE.BoxGeometry(1.35, 0.04, 0.48), frameMat);
  rim.position.set(0, 1.52, 0);
  g.add(rim);
  // Sand bottom
  const sand = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.06, 0.38), mat.sand);
  sand.position.set(0, 0.83, 0);
  g.add(sand);
  // Little fish (colored boxes)
  const fishColors = [0xff6633, 0x33aaff, 0xffcc00, 0xff33aa];
  fishColors.forEach((c, i) => {
    const fishMat = new THREE.MeshLambertMaterial({ color: c });
    const fish = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.06, 0.04), fishMat);
    fish.position.set(-0.3 + i * 0.2, 1.0 + (i % 2) * 0.2, (i % 2 === 0 ? 0.05 : -0.05));
    g.add(fish);
  });
  // Seaweed
  const seaweedMat = new THREE.MeshLambertMaterial({ color: 0x22aa44 });
  for (let x of [-0.4, 0.1, 0.35]) {
    const sw = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.25 + Math.random() * 0.15, 0.04), seaweedMat);
    sw.position.set(x, 0.95, 0);
    g.add(sw);
  }
  g.position.set(4.3, 0.15, 4.3);
  scene.add(g);
  furnitureGroups.fishTank = g;
  interactables.push({ mesh: tank, group: g, type: 'fishTank', label: 'Watch Fish', need: 'fun', usePos: new THREE.Vector3(3.2, 0.15, 4.0), floor: 0 });
  actionConfig.fishTank = { label: 'Watching fish...', duration: 4, restore: 35, cost: 0 };
}

function buildTreadmill() {
  const g = new THREE.Group();
  // Belt/deck
  const belt = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.15, 1.8), mat.rubber);
  belt.position.set(0, 0.2, 0);
  belt.castShadow = true;
  g.add(belt);
  // Front frame uprights
  for (let dx of [-0.25, 0.25]) {
    const upright = new THREE.Mesh(new THREE.BoxGeometry(0.06, 1.2, 0.06), mat.chrome);
    upright.position.set(dx, 0.85, -0.8);
    g.add(upright);
  }
  // Handlebar
  const handlebar = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.05, 0.05), mat.chrome);
  handlebar.position.set(0, 1.45, -0.8);
  g.add(handlebar);
  // Display panel
  const panelMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
  const panel = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.2, 0.04), panelMat);
  panel.position.set(0, 1.3, -0.82);
  g.add(panel);
  const screenMat = new THREE.MeshLambertMaterial({ color: 0x33ff66, emissive: 0x22cc44, emissiveIntensity: 0.5 });
  const screen = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.12, 0.02), screenMat);
  screen.position.set(0, 1.3, -0.84);
  g.add(screen);
  // Side rails
  for (let dx of [-0.3, 0.3]) {
    const rail = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 1.0), mat.chrome);
    rail.position.set(dx, 0.3, 0);
    g.add(rail);
  }
  g.position.set(0, 0.15, -4.2);
  scene.add(g);
  furnitureGroups.treadmill = g;
  interactables.push({ mesh: belt, group: g, type: 'treadmill', label: 'Run on Treadmill', need: 'energy', usePos: new THREE.Vector3(0, 0.15, -3), floor: 0 });
  actionConfig.treadmill = { label: 'Running...', duration: 5, restore: 10, cost: 0, hungerDrain: 15 };
}

function buildJukebox() {
  const g = new THREE.Group();
  // Main body
  const bodyMat = new THREE.MeshLambertMaterial({ color: 0x882244 });
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.9, 1.6, 0.6), bodyMat);
  body.position.set(0, 0.8, 0);
  body.castShadow = true;
  g.add(body);
  // Top arch
  const topMat = new THREE.MeshLambertMaterial({ color: 0xcc3366 });
  const top = new THREE.Mesh(new THREE.BoxGeometry(0.85, 0.3, 0.55), topMat);
  top.position.set(0, 1.75, 0);
  g.add(top);
  // Window/display
  const dispMat = new THREE.MeshLambertMaterial({ color: 0xffcc44, emissive: 0xffaa22, emissiveIntensity: 0.4 });
  const display = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.05), dispMat);
  display.position.set(0, 1.1, 0.28);
  g.add(display);
  // Buttons
  const btnMat = new THREE.MeshLambertMaterial({ color: 0x44ff88, emissive: 0x22cc55, emissiveIntensity: 0.3 });
  for (let i = 0; i < 3; i++) {
    const btn = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.08, 0.04), btnMat);
    btn.position.set(-0.15 + i * 0.15, 0.6, 0.29);
    g.add(btn);
  }
  // Chrome trim
  const trimTop = new THREE.Mesh(new THREE.BoxGeometry(0.92, 0.04, 0.62), mat.chrome);
  trimTop.position.set(0, 1.62, 0);
  g.add(trimTop);
  const trimBot = new THREE.Mesh(new THREE.BoxGeometry(0.92, 0.04, 0.62), mat.chrome);
  trimBot.position.set(0, 0.02, 0);
  g.add(trimBot);
  // Glow
  const glow = new THREE.PointLight(0xffcc44, 0.4, 3);
  glow.position.set(0, 1.2, 0.5);
  g.add(glow);
  g.position.set(0.5, 0.15, 4.5);
  scene.add(g);
  furnitureGroups.jukebox = g;
  interactables.push({ mesh: body, group: g, type: 'jukebox', label: 'Switch to ' + SFX.getNextTrackName(), need: 'fun', usePos: new THREE.Vector3(0.5, 0.15, 3.2), floor: 0 });
}

function updateJukeboxLabel() {
  const jukeInteract = interactables.find(i => i.type === 'jukebox');
  if (jukeInteract) jukeInteract.label = 'Switch to ' + SFX.getNextTrackName();
}

// ═══ OUTDOOR YARD ═══
// ═══ G BUX UNLOCKABLE CONTENT ═══
let petDogLoaded = false, poolLoaded = false, basementLoaded = false;
let petDog = null;
let petCat = null;
let activePet = 'dog'; // 'dog', 'cat', or 'none'
let petBonusTimer = 0;
let petBodyMeshes = [];

function mlLoadGBuxContent() {
  const ggData = ggLoad();
  if (ggData.shopPurchases.ml_pet_dog && !petDogLoaded) {
    buildPetDog(); buildPetCat(); petDogLoaded = true;
    petDog.visible = activePet === 'dog';
    petCat.visible = activePet === 'cat';
    document.getElementById('pet-menu-btn').style.display = '';
  }
  if (ggData.shopPurchases.ml_pool && !poolLoaded) { buildSwimmingPool(); poolLoaded = true; }
  if (ggData.shopPurchases.ml_basement && !basementLoaded) { buildBasement(); basementLoaded = true; }
}

function buildPetDog() {
  const dogGroup = new THREE.Group();
  const bodyMat = new THREE.MeshLambertMaterial({ color: 0xc8a060 });
  const darkMat = new THREE.MeshLambertMaterial({ color: 0x6a4e3a });
  const noseMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
  // Body
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.35, 0.8), bodyMat);
  body.position.set(0, 0.45, 0);
  dogGroup.add(body);
  // Head
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.35, 0.4), bodyMat);
  head.position.set(0, 0.65, 0.5);
  dogGroup.add(head);
  // Snout
  const snout = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.15), bodyMat);
  snout.position.set(0, 0.58, 0.72);
  dogGroup.add(snout);
  // Nose
  const nose = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.06, 0.04), noseMat);
  nose.position.set(0, 0.6, 0.8);
  dogGroup.add(nose);
  // Eyes
  const eyeMat = new THREE.MeshLambertMaterial({ color: 0x111111 });
  [-0.1, 0.1].forEach(x => {
    const eye = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.04), eyeMat);
    eye.position.set(x, 0.72, 0.7);
    dogGroup.add(eye);
  });
  // Ears
  [-0.18, 0.18].forEach(x => {
    const ear = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.2, 0.08), darkMat);
    ear.position.set(x, 0.82, 0.45);
    ear.rotation.z = x > 0 ? -0.3 : 0.3;
    dogGroup.add(ear);
  });
  // Legs
  [[-0.15, -0.3], [0.15, -0.3], [-0.15, 0.3], [0.15, 0.3]].forEach(([x, z]) => {
    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.28, 0.1), darkMat);
    leg.position.set(x, 0.14, z);
    dogGroup.add(leg);
  });
  // Tail
  const tail = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.06, 0.3), bodyMat);
  tail.position.set(0, 0.65, -0.5);
  tail.rotation.x = -0.5;
  tail.name = 'dogTail';
  dogGroup.add(tail);

  dogGroup.position.set(2, 0.15, 2);
  scene.add(dogGroup);
  petDog = dogGroup;
  petBodyMeshes.push(body);
}

function buildPetCat() {
  const catGroup = new THREE.Group();
  const furMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
  const whiteMat = new THREE.MeshLambertMaterial({ color: 0xdddddd });
  const noseMat = new THREE.MeshLambertMaterial({ color: 0xffaaaa });
  // Body (smaller than dog)
  const body = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.25, 0.6), furMat);
  body.position.set(0, 0.35, 0);
  catGroup.add(body);
  // Chest patch
  const chest = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.2), whiteMat);
  chest.position.set(0, 0.32, 0.25);
  catGroup.add(chest);
  // Head
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.28, 0.3), furMat);
  head.position.set(0, 0.55, 0.4);
  catGroup.add(head);
  // Nose
  const nose = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.04, 0.03), noseMat);
  nose.position.set(0, 0.5, 0.56);
  catGroup.add(nose);
  // Eyes
  const eyeMat = new THREE.MeshLambertMaterial({ color: 0x44cc44 });
  [-0.08, 0.08].forEach(x => {
    const eye = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.04, 0.03), eyeMat);
    eye.position.set(x, 0.58, 0.55);
    catGroup.add(eye);
    const pupil = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.04, 0.02), new THREE.MeshLambertMaterial({ color: 0x111111 }));
    pupil.position.set(x, 0.58, 0.565);
    catGroup.add(pupil);
  });
  // Pointy ears
  [-0.1, 0.1].forEach(x => {
    const ear = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.12, 0.06), furMat);
    ear.position.set(x, 0.73, 0.4);
    ear.rotation.z = x > 0 ? -0.2 : 0.2;
    catGroup.add(ear);
    const inner = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.08, 0.03), noseMat);
    inner.position.set(x, 0.73, 0.42);
    inner.rotation.z = x > 0 ? -0.2 : 0.2;
    catGroup.add(inner);
  });
  // Legs (thin)
  [[-0.1, -0.2], [0.1, -0.2], [-0.1, 0.2], [0.1, 0.2]].forEach(([x, z]) => {
    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.22, 0.07), furMat);
    leg.position.set(x, 0.11, z);
    catGroup.add(leg);
    const paw = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.04, 0.06), whiteMat);
    paw.position.set(x, 0.02, z);
    catGroup.add(paw);
  });
  // Tail (long, curved up)
  const tail = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.04, 0.4), furMat);
  tail.position.set(0, 0.5, -0.45);
  tail.rotation.x = -0.6;
  tail.name = 'catTail';
  catGroup.add(tail);

  catGroup.position.set(-2, 0.15, 2);
  scene.add(catGroup);
  petCat = catGroup;
  petCat.visible = false; // dog is active by default
  petBodyMeshes.push(body);
}

function buildSwimmingPool() {
  const poolGroup = new THREE.Group();
  // Pool rim
  const rimMat = new THREE.MeshLambertMaterial({ color: 0xcccccc });
  const rim = new THREE.Mesh(new THREE.BoxGeometry(5, 0.3, 3.5), rimMat);
  rim.position.set(14.5, 0.15, 5.5);
  poolGroup.add(rim);
  // Water (inset)
  const waterMat = new THREE.MeshLambertMaterial({ color: 0x4499dd, transparent: true, opacity: 0.6 });
  const water = new THREE.Mesh(new THREE.BoxGeometry(4.4, 0.2, 2.9), waterMat);
  water.position.set(14.5, 0.12, 5.5);
  poolGroup.add(water);
  // Inner walls (dark blue)
  const innerMat = new THREE.MeshLambertMaterial({ color: 0x1155aa });
  const inner = new THREE.Mesh(new THREE.BoxGeometry(4.6, 1.2, 3.1), innerMat);
  inner.position.set(14.5, -0.5, 5.5);
  poolGroup.add(inner);
  // Ladder
  const ladderMat = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
  [-0.5, 0.5].forEach(z => {
    const rail = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1.2, 6), ladderMat);
    rail.position.set(12.4, 0.5, 5.5 + z);
    poolGroup.add(rail);
  });
  for (let y = 0.1; y <= 0.9; y += 0.3) {
    const rung = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 1, 6), ladderMat);
    rung.position.set(12.4, y, 5.5);
    rung.rotation.x = Math.PI / 2;
    poolGroup.add(rung);
  }
  scene.add(poolGroup);

  // Add interactable
  interactables.push({ mesh: water, group: poolGroup, type: 'pool', label: 'Swim in Pool', need: 'fun', usePos: new THREE.Vector3(12.5, 0.15, 5.5), floor: 0 });
  actionConfig.pool = { label: 'Swimming...', duration: 6, restore: 35, cost: 0, hygieneBonus: 20 };
  rebuildInteractMeshes();
}

function buildBasement() {
  const basementGroup = new THREE.Group();
  const BASEMENT_Y = -3.35;
  // Floor
  const floorGeo = new THREE.BoxGeometry(10, 0.15, 10);
  const bFloor = new THREE.Mesh(floorGeo, new THREE.MeshLambertMaterial({ color: 0x555555 }));
  bFloor.position.set(0, BASEMENT_Y + 0.075, 0);
  basementGroup.add(bFloor);
  // Ceiling (same as ground floor)
  const ceiling = new THREE.Mesh(new THREE.BoxGeometry(10, 0.15, 10), mat.floor);
  ceiling.position.set(0, BASEMENT_Y + 3.5, 0);
  basementGroup.add(ceiling);
  // Walls
  const wallMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
  // Front wall, back wall, left wall (solid)
  [[10, 3.5, 0.15, 0, BASEMENT_Y+1.75, -5], [10, 3.5, 0.15, 0, BASEMENT_Y+1.75, 5],
   [0.15, 3.5, 10, -5, BASEMENT_Y+1.75, 0]].forEach(([w,h,d,x,y,z]) => {
    const wall = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), wallMat);
    wall.position.set(x,y,z);
    basementGroup.add(wall);
  });
  // Right wall — split for stair opening at z=-4.5 to z=-2.5
  const rwTop = new THREE.Mesh(new THREE.BoxGeometry(0.15, 3.5, 5), wallMat);
  rwTop.position.set(5, BASEMENT_Y+1.75, 2.5); // z=0 to z=5
  basementGroup.add(rwTop);
  const rwMid = new THREE.Mesh(new THREE.BoxGeometry(0.15, 3.5, 2.5), wallMat);
  rwMid.position.set(5, BASEMENT_Y+1.75, -1.25); // z=-2.5 to z=0
  basementGroup.add(rwMid);
  const rwBot = new THREE.Mesh(new THREE.BoxGeometry(0.15, 3.5, 0.5), wallMat);
  rwBot.position.set(5, BASEMENT_Y+1.75, -4.75); // z=-5 to z=-4.5
  basementGroup.add(rwBot);
  // Outdoor basement stairs (yard side entrance)
  const stairMat = new THREE.MeshLambertMaterial({ color: 0x777777 });
  // Stair steps — descend from x=8 (ground) to x=5.3 (basement) along z=-3.5
  for (let i = 0; i < 8; i++) {
    const step = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.15, 2), stairMat);
    const t = i / 7;
    step.position.set(8 - i * 0.39, 0.15 - t * 3.5, -3.5);
    basementGroup.add(step);
  }
  // Stairwell side walls
  const stairWallMat = new THREE.MeshLambertMaterial({ color: 0x666666 });
  for (let i = 0; i < 8; i++) {
    const t = i / 7;
    const wx = 8 - i * 0.39;
    const wy = 0.15 - t * 3.5;
    const wh = 0.15 + t * 3.5;
    const w1 = new THREE.Mesh(new THREE.BoxGeometry(0.39, wh, 0.1), stairWallMat);
    w1.position.set(wx, wy + wh/2 - 0.15, -4.5);
    basementGroup.add(w1);
    const w2 = new THREE.Mesh(new THREE.BoxGeometry(0.39, wh, 0.1), stairWallMat);
    w2.position.set(wx, wy + wh/2 - 0.15, -2.5);
    basementGroup.add(w2);
  }
  // Railing at top of stairs
  const railMat = new THREE.MeshLambertMaterial({ color: 0x8B6914 });
  const rail1 = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.06, 0.06), railMat);
  rail1.position.set(6.6, 1.1, -4.5);
  basementGroup.add(rail1);
  const rail2 = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.06, 0.06), railMat);
  rail2.position.set(6.6, 1.1, -2.5);
  basementGroup.add(rail2);
  // Rail posts
  [8, 6.6, 5.2].forEach(px => {
    [-4.5, -2.5].forEach(pz => {
      const post = new THREE.Mesh(new THREE.BoxGeometry(0.06, 1, 0.06), railMat);
      post.position.set(px, 0.6, pz);
      basementGroup.add(post);
    });
  });
  // Light
  const light = new THREE.PointLight(0xffcc88, 0.6, 12);
  light.position.set(0, BASEMENT_Y + 3.2, 0);
  basementGroup.add(light);
  // Workbench
  const benchMat = new THREE.MeshLambertMaterial({ color: 0x8B6914 });
  const bench = new THREE.Mesh(new THREE.BoxGeometry(2, 0.15, 1), benchMat);
  bench.position.set(-3, BASEMENT_Y + 1, -3);
  basementGroup.add(bench);
  const benchLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1, 0.15), benchMat);
  benchLeg1.position.set(-4, BASEMENT_Y + 0.5, -3.4);
  basementGroup.add(benchLeg1);
  const benchLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1, 0.15), benchMat);
  benchLeg2.position.set(-2, BASEMENT_Y + 0.5, -3.4);
  basementGroup.add(benchLeg2);
  const benchLeg3 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1, 0.15), benchMat);
  benchLeg3.position.set(-4, BASEMENT_Y + 0.5, -2.6);
  basementGroup.add(benchLeg3);
  const benchLeg4 = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1, 0.15), benchMat);
  benchLeg4.position.set(-2, BASEMENT_Y + 0.5, -2.6);
  basementGroup.add(benchLeg4);
  // Tools on bench
  const toolMat = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
  const hammer = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.4), toolMat);
  hammer.position.set(-3.3, BASEMENT_Y + 1.12, -3);
  basementGroup.add(hammer);
  // Punching bag
  const bagMat = new THREE.MeshLambertMaterial({ color: 0xcc3333 });
  const bag = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1, 8), bagMat);
  bag.position.set(3, BASEMENT_Y + 2.5, -3);
  basementGroup.add(bag);
  const chain = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.5, 4), toolMat);
  chain.position.set(3, BASEMENT_Y + 3.1, -3);
  basementGroup.add(chain);

  scene.add(basementGroup);

  // Add interactables
  interactables.push({ mesh: bench, group: basementGroup, type: 'workbench', label: 'Craft (Workbench)', need: 'money', usePos: new THREE.Vector3(-3, BASEMENT_Y + 0.15, -2), floor: -1 });
  actionConfig.workbench = { label: 'Crafting...', duration: 8, restore: 0, cost: 0, earn: 25 };
  interactables.push({ mesh: bag, group: basementGroup, type: 'punchingBag', label: 'Box (Punching Bag)', need: 'fun', usePos: new THREE.Vector3(3, BASEMENT_Y + 0.15, -2), floor: -1 });
  actionConfig.punchingBag = { label: 'Boxing...', duration: 4, restore: 30, cost: 0, hungerDrain: 10 };
  rebuildInteractMeshes();
}

function buildYard() {
  const yardGroup = new THREE.Group();
  const fenceMat = new THREE.MeshLambertMaterial({ color: 0x8B6914 });

  // --- Fence posts + rails ---
  // Right fence (far edge X=18)
  for (let z = -8; z <= 8; z += 2) {
    const post = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1.2, 0.15), fenceMat);
    post.position.set(18, 0.6, z);
    post.castShadow = true;
    yardGroup.add(post);
  }
  const railR1 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 16), fenceMat);
  railR1.position.set(18, 1.0, 0);
  yardGroup.add(railR1);
  const railR2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 16), fenceMat);
  railR2.position.set(18, 0.5, 0);
  yardGroup.add(railR2);

  // Front fence (Z=-8)
  for (let x = 5; x <= 18; x += 2) {
    const post = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1.2, 0.15), fenceMat);
    post.position.set(x, 0.6, -8);
    post.castShadow = true;
    yardGroup.add(post);
  }
  const railF1 = new THREE.Mesh(new THREE.BoxGeometry(13, 0.1, 0.1), fenceMat);
  railF1.position.set(11.5, 1.0, -8);
  yardGroup.add(railF1);
  const railF2 = new THREE.Mesh(new THREE.BoxGeometry(13, 0.1, 0.1), fenceMat);
  railF2.position.set(11.5, 0.5, -8);
  yardGroup.add(railF2);

  // Back fence (Z=8)
  for (let x = 5; x <= 18; x += 2) {
    const post = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1.2, 0.15), fenceMat);
    post.position.set(x, 0.6, 8);
    post.castShadow = true;
    yardGroup.add(post);
  }
  const railB1 = new THREE.Mesh(new THREE.BoxGeometry(13, 0.1, 0.1), fenceMat);
  railB1.position.set(11.5, 1.0, 8);
  yardGroup.add(railB1);
  const railB2 = new THREE.Mesh(new THREE.BoxGeometry(13, 0.1, 0.1), fenceMat);
  railB2.position.set(11.5, 0.5, 8);
  yardGroup.add(railB2);

  // --- Tree ---
  const trunkMat = new THREE.MeshLambertMaterial({ color: 0x5C3A1E });
  const leafMat = new THREE.MeshLambertMaterial({ color: 0x2D7A2D });
  const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.4, 3, 8), trunkMat);
  trunk.position.set(14, 1.5, -4);
  trunk.castShadow = true;
  yardGroup.add(trunk);
  [[14, 3.5, -4, 1.5], [13.5, 3.8, -3.6, 1.2], [14.5, 3.6, -4.3, 1.1]].forEach(([x, y, z, r]) => {
    const leaves = new THREE.Mesh(new THREE.SphereGeometry(r, 8, 6), leafMat);
    leaves.position.set(x, y, z);
    leaves.castShadow = true;
    yardGroup.add(leaves);
  });

  // --- Garden bed ---
  const dirtMat = new THREE.MeshLambertMaterial({ color: 0x6B4226 });
  const dirt = new THREE.Mesh(new THREE.BoxGeometry(3, 0.15, 1.5), dirtMat);
  dirt.position.set(10, 0.08, 5);
  dirt.receiveShadow = true;
  yardGroup.add(dirt);
  // Border
  [[10, 0.15, 4.2, 3.2, 0.3, 0.1], [10, 0.15, 5.8, 3.2, 0.3, 0.1],
   [8.4, 0.15, 5, 0.1, 0.3, 1.8], [11.6, 0.15, 5, 0.1, 0.3, 1.8]].forEach(([x, y, z, w, h, d]) => {
    const b = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), fenceMat);
    b.position.set(x, y, z);
    yardGroup.add(b);
  });
  // Flowers
  const flowerColors = [0xFF6B6B, 0xFFD93D, 0xC084FC, 0xFF8FAB];
  const stemMat = new THREE.MeshLambertMaterial({ color: 0x228B22 });
  for (let i = 0; i < 6; i++) {
    const fx = 8.8 + i * 0.5;
    const stemH = 0.3 + Math.random() * 0.2;
    const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, stemH, 4), stemMat);
    stem.position.set(fx, 0.15 + stemH / 2, 5);
    yardGroup.add(stem);
    const flower = new THREE.Mesh(new THREE.SphereGeometry(0.08, 6, 4),
      new THREE.MeshLambertMaterial({ color: flowerColors[i % flowerColors.length] }));
    flower.position.set(fx, 0.15 + stemH + 0.06, 5);
    yardGroup.add(flower);
  }

  // --- Mailbox ---
  const mailPost = new THREE.Mesh(new THREE.BoxGeometry(0.15, 1.2, 0.15), fenceMat);
  mailPost.position.set(7, 0.6, -6);
  mailPost.castShadow = true;
  yardGroup.add(mailPost);
  const mailBox = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.4, 0.35),
    new THREE.MeshLambertMaterial({ color: 0x3366AA }));
  mailBox.position.set(7, 1.35, -6);
  mailBox.castShadow = true;
  yardGroup.add(mailBox);
  const flag = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.2, 0.05),
    new THREE.MeshLambertMaterial({ color: 0xCC2222 }));
  flag.position.set(7.3, 1.45, -6);
  yardGroup.add(flag);

  // --- Stepping stones from door ---
  const stoneMat = new THREE.MeshLambertMaterial({ color: 0x999999 });
  [6, 7.5, 9].forEach(x => {
    const stone = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.45, 0.06, 8), stoneMat);
    stone.position.set(x, 0.01, 0.75);
    stone.receiveShadow = true;
    yardGroup.add(stone);
  });

  scene.add(yardGroup);
  return yardGroup;
}
buildYard();

// ═══ TOWN SYSTEM ═══
let hasCar = false;
let carGroup = null;
let townCarGroup = null;
let inTown = false;
let townGroup = null;
let townNPCs = [];
let npcBodyMeshes = [];
let questLog = {};
let questsCompleted = 0;
let npcDialogueOpen = false;
let currentNPCId = null;
let jobMiniGameRunning = false;
let currentSlot = -1;
let currentSlotName = '';
let jobLastDay = {};
let totalShiftsWorked = 0;

const TOWN_JOBS = {
  barista:  { name: 'Order Rush',   basePay: 15, desc: 'Fill drink orders!' },
  merchant: { name: 'Shelf Stocker', basePay: 15, desc: 'Catch falling items!' },
  mayor:    { name: 'Stamp Sorter', basePay: 15, desc: 'Sort documents!' },
};

const TOWN_ORIGIN = { x: 122.5, z: 0 }; // center of town
const TOWN_BOUNDS = { xMin: 100, xMax: 145, zMin: -15, zMax: 15 };
const TOWN_PLAYER_SPAWN = { x: 135, y: 0.15, z: -8 }; // near parking lot
const HOME_PLAYER_SPAWN = { x: 10, y: 0.15, z: 0.75 }; // near car in yard

// ═══ MANSION SYSTEM ═══
let hasMansion = false;
let inMansion = false;
let mansionGroup = null;
let mansionCarGroup = null;
let driveDestOpen = false;
const MANSION_ORIGIN = { x: 280, z: 0 };
const MANSION_BOUNDS = { xMin: 250, xMax: 310, zMin: -25, zMax: 25 };
const MANSION_PLAYER_SPAWN = { x: 258, y: 0.15, z: -12 };
const MANSION_UPPER_Y = 3.65;
const MANSION_STAIR = { xMin: 285, xMax: 288, zMin: 3, zMax: 10 };

// Quest definitions
const QUESTS = {
  coffee_run: {
    npc: 'barista',
    name: 'Coffee Run',
    offer: "I'm swamped! Could you grab a bite at home and come back? I'll pay you for the errand.",
    active: "Eat something at home and come back to me!",
    complete: "You're a lifesaver! Here's your pay.",
    condition: () => questLog.coffee_run && questLog.coffee_run.fridgeUsed,
    reward: { money: 75 },
  },
  supply_run: {
    npc: 'merchant',
    name: 'Supply Run',
    offer: "I need someone handy. Use a workbench to craft me some supplies, then report back.",
    active: "Craft something at the workbench and come back!",
    complete: "Perfect craftsmanship! Here's your payment.",
    condition: () => questLog.supply_run && questLog.supply_run.workbenchUsed,
    reward: { money: 100 },
  },
  town_spirit: {
    npc: 'mayor',
    name: 'Town Spirit',
    offer: "A good citizen takes care of themselves! Get all your needs above 70% and show me.",
    active: "Get all needs above 70% and talk to me!",
    complete: "Now THAT's a model citizen! The town thanks you.",
    condition: () => needs.hunger > 70 && needs.energy > 70 && needs.fun > 70 && needs.hygiene > 70,
    reward: { money: 150 },
  },
  tall_tales: {
    npc: 'old_pete',
    name: 'Tall Tales',
    offer: "I love a well-read person. Read 3 books from a bookshelf and come tell me about them!",
    active: "Read 3 books and come back to chat!",
    complete: "Wonderful stories! Let me reward your wisdom.",
    condition: () => booksRead >= 3,
    reward: { money: 50, fun: 30 },
  },
};

// NPC definitions
const TOWN_NPC_DEFS = [
  { id: 'barista', name: 'Barista Bean', x: 108, z: 4, skinTone: 3, hairColor: 2, hairStyle: 'curly', gender: 'female', outfit: 3 },
  { id: 'merchant', name: 'Merchant Mike', x: 108, z: -8, skinTone: 4, hairColor: 0, hairStyle: 'buzz', gender: 'male', outfit: 5 },
  { id: 'mayor', name: 'Mayor Maple', x: 132, z: 4, skinTone: 1, hairColor: 4, hairStyle: 'short', gender: 'female', outfit: 7 },
  { id: 'old_pete', name: 'Old Pete', x: 124, z: 12, skinTone: 0, hairColor: 4, hairStyle: 'long', gender: 'male', outfit: 0 },
];

function buildCar() {
  const g = new THREE.Group();
  const bodyMat = new THREE.MeshLambertMaterial({ color: 0xcc2222 });
  const cabinMat = new THREE.MeshLambertMaterial({ color: 0x222222 });
  const glassMat = new THREE.MeshLambertMaterial({ color: 0x88bbdd, transparent: true, opacity: 0.5 });
  const wheelMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
  const lightMat = new THREE.MeshLambertMaterial({ color: 0xffee88, emissive: 0xffcc44, emissiveIntensity: 0.4 });
  // Body
  const body = new THREE.Mesh(new THREE.BoxGeometry(2.4, 0.7, 1.4), bodyMat);
  body.position.set(0, 0.55, 0);
  body.castShadow = true;
  g.add(body);
  // Cabin
  const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.6, 1.3), cabinMat);
  cabin.position.set(-0.1, 1.2, 0);
  cabin.castShadow = true;
  g.add(cabin);
  // Windows
  const winF = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.4, 1.1), glassMat);
  winF.position.set(0.6, 1.2, 0);
  g.add(winF);
  const winB = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.4, 1.1), glassMat);
  winB.position.set(-0.8, 1.2, 0);
  g.add(winB);
  // Wheels
  [[-0.7, -0.6], [-0.7, 0.6], [0.7, -0.6], [0.7, 0.6]].forEach(([x, z]) => {
    const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.15, 8), wheelMat);
    wheel.position.set(x, 0.25, z);
    wheel.rotation.x = Math.PI / 2;
    g.add(wheel);
  });
  // Headlights
  [0.5, -0.5].forEach(z => {
    const light = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.15, 0.2), lightMat);
    light.position.set(1.2, 0.6, z);
    g.add(light);
  });
  return g;
}

function purchaseCar() {
  if (hasCar || money < 200) return;
  money -= 200;
  hasCar = true;
  SFX.kaChing();
  // Place car in yard
  carGroup = buildCar();
  carGroup.position.set(12, 0.15, -6);
  carGroup.rotation.y = Math.PI / 2;
  scene.add(carGroup);
  // Make car interactable
  const carBody = carGroup.children[0]; // the body mesh
  interactables.push({ mesh: carBody, group: carGroup, type: 'car', label: 'Drive to Town', need: null, usePos: new THREE.Vector3(11, 0.15, -5), floor: 0 });
  rebuildInteractMeshes();
  showTip('Car purchased! Click it to drive to town.');
  mlTry('ml_shopaholic');
}

function purchaseMansion() {
  if (hasMansion || money < 1000) return;
  money -= 1000;
  hasMansion = true;
  SFX.kaChing();
  showTip('Mansion purchased! Drive there in your car.');
  document.getElementById('drive-mansion-btn').style.display = '';
  mlTry('ml_mansion_mogul');
}

function startDrivingTransition(destination) {
  if (npcDialogueOpen || currentAction || driveDestOpen || jobMiniGameRunning) return;
  const overlay = document.getElementById('drive-overlay');
  const driveText = document.getElementById('drive-text');
  if (destination === 'town') driveText.textContent = 'Driving to town...';
  else if (destination === 'mansion') driveText.textContent = 'Driving to the mansion...';
  else driveText.textContent = 'Driving home...';
  overlay.classList.add('visible');
  if (document.pointerLockElement) document.exitPointerLock();

  setTimeout(() => {
    if (destination === 'town') {
      if (!townGroup) { townGroup = buildTown(); buildTownNPCs(); }
      townGroup.visible = true;
      if (mansionGroup) mansionGroup.visible = false;
      inTown = true;
      inMansion = false;
      currentFloor = 0;
      character.position.set(TOWN_PLAYER_SPAWN.x, TOWN_PLAYER_SPAWN.y, TOWN_PLAYER_SPAWN.z);
      yaw = Math.PI / 2;
      scene.fog.far = TOWN_FOG_FAR;
      sunLight.shadow.camera.left = -60;
      sunLight.shadow.camera.right = 60;
      sunLight.shadow.camera.top = 40;
      sunLight.shadow.camera.bottom = -40;
      sunLight.shadow.camera.updateProjectionMatrix();
      if (petDog) petDog.visible = false;
      if (petCat) petCat.visible = false;
    } else if (destination === 'mansion') {
      if (!mansionGroup) { mansionGroup = buildMansion(); }
      mansionGroup.visible = true;
      if (townGroup) townGroup.visible = false;
      inTown = false;
      inMansion = true;
      currentFloor = 0;
      character.position.set(MANSION_PLAYER_SPAWN.x, MANSION_PLAYER_SPAWN.y, MANSION_PLAYER_SPAWN.z);
      yaw = Math.PI / 2;
      scene.fog.far = MANSION_FOG_FAR;
      sunLight.shadow.camera.left = -80;
      sunLight.shadow.camera.right = 80;
      sunLight.shadow.camera.top = 50;
      sunLight.shadow.camera.bottom = -50;
      sunLight.shadow.camera.updateProjectionMatrix();
      if (petDog) petDog.visible = false;
      if (petCat) petCat.visible = false;
    } else {
      inTown = false;
      inMansion = false;
      currentFloor = 0;
      character.position.set(HOME_PLAYER_SPAWN.x, HOME_PLAYER_SPAWN.y, HOME_PLAYER_SPAWN.z);
      yaw = Math.PI;
      scene.fog.far = HOME_FOG_FAR;
      sunLight.shadow.camera.left = -15;
      sunLight.shadow.camera.right = 15;
      sunLight.shadow.camera.top = 20;
      sunLight.shadow.camera.bottom = -15;
      sunLight.shadow.camera.updateProjectionMatrix();
      if (townGroup) townGroup.visible = false;
      if (mansionGroup) mansionGroup.visible = false;
      if (petDog) petDog.visible = activePet === 'dog';
      if (petCat) petCat.visible = activePet === 'cat';
    }
    updatePlayerY();
    overlay.classList.remove('visible');
  }, 2000);
}

function buildTown() {
  const g = new THREE.Group();
  const roadMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
  const sidewalkMat = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });
  const buildingMat1 = new THREE.MeshLambertMaterial({ color: 0xaa6644 }); // cafe
  const buildingMat2 = new THREE.MeshLambertMaterial({ color: 0x5577aa }); // shop
  const buildingMat3 = new THREE.MeshLambertMaterial({ color: 0xccccbb }); // town hall
  const roofMat = new THREE.MeshLambertMaterial({ color: 0x884422 });
  const roofMat2 = new THREE.MeshLambertMaterial({ color: 0x334466 });
  const roofMat3 = new THREE.MeshLambertMaterial({ color: 0x666655 });
  const parkMat = new THREE.MeshLambertMaterial({ color: 0x3a7a30 });
  const fenceMat = new THREE.MeshLambertMaterial({ color: 0x8B6914 });
  const lotMat = new THREE.MeshLambertMaterial({ color: 0x555555 });
  const lampMat = new THREE.MeshLambertMaterial({ color: 0x333333 });

  // Town ground
  const townGround = new THREE.Mesh(new THREE.PlaneGeometry(50, 35), mat.grass);
  townGround.rotation.x = -Math.PI / 2;
  townGround.position.set(TOWN_ORIGIN.x, -0.01, TOWN_ORIGIN.z);
  townGround.receiveShadow = true;
  g.add(townGround);

  // Main road (runs north-south through center, X=118)
  const road = new THREE.Mesh(new THREE.BoxGeometry(6, 0.05, 30), roadMat);
  road.position.set(118, 0.02, TOWN_ORIGIN.z);
  road.receiveShadow = true;
  g.add(road);
  // Lane markings
  for (let z = -14; z <= 14; z += 4) {
    const marking = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.01, 1.5), new THREE.MeshLambertMaterial({ color: 0xffcc00 }));
    marking.position.set(118, 0.06, z);
    g.add(marking);
  }
  // Sidewalks
  const swL = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 30), sidewalkMat);
  swL.position.set(114, 0.04, TOWN_ORIGIN.z);
  g.add(swL);
  const swR = new THREE.Mesh(new THREE.BoxGeometry(2, 0.08, 30), sidewalkMat);
  swR.position.set(122, 0.04, TOWN_ORIGIN.z);
  g.add(swR);

  // === CAFE (left side, Z=1 to 7) ===
  const cafe = new THREE.Mesh(new THREE.BoxGeometry(8, 3.5, 6), buildingMat1);
  cafe.position.set(108, 1.75, 4);
  cafe.castShadow = true; cafe.receiveShadow = true;
  g.add(cafe);
  const cafeRoof = new THREE.Mesh(new THREE.BoxGeometry(9, 0.3, 7), roofMat);
  cafeRoof.position.set(108, 3.65, 4);
  g.add(cafeRoof);
  // Cafe sign
  const signMat = new THREE.MeshLambertMaterial({ color: 0xffcc44, emissive: 0xffaa22, emissiveIntensity: 0.3 });
  const cafeSign = new THREE.Mesh(new THREE.BoxGeometry(3, 0.6, 0.1), signMat);
  cafeSign.position.set(108, 3.2, 7.06);
  g.add(cafeSign);
  // Cafe door gap (just visual - an opening)
  const cafeDoor = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.3, 0.15), new THREE.MeshLambertMaterial({ color: 0x553322 }));
  cafeDoor.position.set(110, 1.15, 7);
  g.add(cafeDoor);

  // === SHOP (left side, Z=-12 to -5) ===
  const shop = new THREE.Mesh(new THREE.BoxGeometry(8, 3, 7), buildingMat2);
  shop.position.set(108, 1.5, -8);
  shop.castShadow = true; shop.receiveShadow = true;
  g.add(shop);
  const shopRoof = new THREE.Mesh(new THREE.BoxGeometry(9, 0.3, 8), roofMat2);
  shopRoof.position.set(108, 3.15, -8);
  g.add(shopRoof);
  // Shop awning
  const awningMat = new THREE.MeshLambertMaterial({ color: 0x3366aa });
  const awning = new THREE.Mesh(new THREE.BoxGeometry(4, 0.1, 1.5), awningMat);
  awning.position.set(108, 2.8, -4.2);
  g.add(awning);

  // === TOWN HALL (right side, Z=1 to 7) ===
  const hall = new THREE.Mesh(new THREE.BoxGeometry(10, 4, 6), buildingMat3);
  hall.position.set(132, 2, 4);
  hall.castShadow = true; hall.receiveShadow = true;
  g.add(hall);
  const hallRoof = new THREE.Mesh(new THREE.BoxGeometry(11, 0.4, 7), roofMat3);
  hallRoof.position.set(132, 4.2, 4);
  g.add(hallRoof);
  // Columns
  const colMat = new THREE.MeshLambertMaterial({ color: 0xddddcc });
  [-2, 0, 2].forEach(dx => {
    const col = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 3.5, 8), colMat);
    col.position.set(132 + dx, 1.75, 7.2);
    g.add(col);
  });
  // Hall door
  const hallDoor = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.5, 0.15), new THREE.MeshLambertMaterial({ color: 0x553322 }));
  hallDoor.position.set(132, 1.25, 7);
  g.add(hallDoor);

  // === PARKING LOT (right side, Z=-12 to -5) ===
  const lot = new THREE.Mesh(new THREE.BoxGeometry(12, 0.05, 8), lotMat);
  lot.position.set(135, 0.02, -8);
  lot.receiveShadow = true;
  g.add(lot);
  // Parking lines
  for (let x = 130; x <= 140; x += 2.5) {
    const line = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.01, 5), new THREE.MeshLambertMaterial({ color: 0xeeeeee }));
    line.position.set(x, 0.06, -8);
    g.add(line);
  }

  // === PARK (top, Z=9 to 14) ===
  // Park grass (slightly different shade)
  const parkGrass = new THREE.Mesh(new THREE.BoxGeometry(40, 0.05, 6), parkMat);
  parkGrass.position.set(TOWN_ORIGIN.x, 0.01, 12);
  g.add(parkGrass);

  // Park trees
  const trunkMat = new THREE.MeshLambertMaterial({ color: 0x5C3A1E });
  const leafMat = new THREE.MeshLambertMaterial({ color: 0x2D7A2D });
  [105, 115, 125, 138].forEach(tx => {
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.3, 2.5, 6), trunkMat);
    trunk.position.set(tx, 1.25, 12 + (Math.random() - 0.5) * 2);
    trunk.castShadow = true;
    g.add(trunk);
    const leaves = new THREE.Mesh(new THREE.SphereGeometry(1.2, 8, 6), leafMat);
    leaves.position.set(tx, 3, 12 + (Math.random() - 0.5) * 2);
    leaves.castShadow = true;
    g.add(leaves);
  });

  // Park bench
  const benchWoodMat = new THREE.MeshLambertMaterial({ color: 0x8B6914 });
  const benchSeat = new THREE.Mesh(new THREE.BoxGeometry(2, 0.1, 0.5), benchWoodMat);
  benchSeat.position.set(125, 0.5, 11);
  g.add(benchSeat);
  const benchBack = new THREE.Mesh(new THREE.BoxGeometry(2, 0.6, 0.08), benchWoodMat);
  benchBack.position.set(125, 0.8, 10.75);
  g.add(benchBack);
  [-0.8, 0.8].forEach(dx => {
    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.5, 0.5), lampMat);
    leg.position.set(125 + dx, 0.25, 11);
    g.add(leg);
  });

  // Fountain (center of park)
  const fountainMat = new THREE.MeshLambertMaterial({ color: 0x999999 });
  const fBase = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.8, 0.4, 12), fountainMat);
  fBase.position.set(130, 0.2, 12);
  g.add(fBase);
  const fWater = new THREE.Mesh(new THREE.CylinderGeometry(1.3, 1.3, 0.3, 12), mat.water);
  fWater.position.set(130, 0.35, 12);
  g.add(fWater);
  const fPillar = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 1.2, 8), fountainMat);
  fPillar.position.set(130, 0.9, 12);
  g.add(fPillar);

  // Street lamps
  [110, 115, 126, 134].forEach(lx => {
    const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 3.5, 6), lampMat);
    pole.position.set(lx, 1.75, -14);
    g.add(pole);
    const lamp = new THREE.Mesh(new THREE.SphereGeometry(0.2, 8, 6), new THREE.MeshLambertMaterial({ color: 0xffeecc, emissive: 0xffcc88, emissiveIntensity: 0.3 }));
    lamp.position.set(lx, 3.6, -14);
    g.add(lamp);
    const pl = new THREE.PointLight(0xffcc88, 0.3, 8);
    pl.position.set(lx, 3.5, -14);
    g.add(pl);
  });

  // Town car (in parking lot for return trip)
  townCarGroup = buildCar();
  townCarGroup.position.set(135, 0.15, -8);
  townCarGroup.rotation.y = -Math.PI / 2;
  g.add(townCarGroup);
  const townCarBody = townCarGroup.children[0];
  interactables.push({ mesh: townCarBody, group: townCarGroup, type: 'townCar', label: 'Drive Home', need: null, usePos: new THREE.Vector3(134, 0.15, -7), floor: 0 });
  rebuildInteractMeshes();

  // Town light
  const townLight = new THREE.PointLight(0xffeedd, 0.4, 50);
  townLight.position.set(TOWN_ORIGIN.x, 10, TOWN_ORIGIN.z);
  g.add(townLight);

  scene.add(g);
  g.visible = false;
  return g;
}

// Building collision AABBs for town
const TOWN_BUILDINGS = [
  { xMin: 104, xMax: 112, zMin: 1, zMax: 7 },   // Cafe
  { xMin: 104, xMax: 112, zMin: -12, zMax: -4.5 }, // Shop
  { xMin: 127, xMax: 137, zMin: 1, zMax: 7 },    // Town Hall
  // Fountain
  { xMin: 128.5, xMax: 131.5, zMin: 10.5, zMax: 13.5 },
];

function buildTownNPCs() {
  TOWN_NPC_DEFS.forEach(def => {
    const npcChar = buildCharacter({
      skinTone: def.skinTone, gender: def.gender,
      hairStyle: def.hairStyle, hairColor: def.hairColor,
      outfit: def.outfit,
    });
    npcChar.position.set(def.x, 0.15, def.z);
    // Face towards the road
    if (def.x < 118) npcChar.rotation.y = -Math.PI / 2;
    else npcChar.rotation.y = Math.PI / 2;
    if (def.id === 'old_pete') npcChar.rotation.y = Math.PI; // faces south
    townGroup.add(npcChar);
    // Tag ALL meshes in the NPC group for raycast detection
    npcChar.traverse(child => {
      if (child.isMesh) {
        child.userData = { type: 'npc', npcId: def.id };
        npcBodyMeshes.push(child);
      }
    });
    townNPCs.push({ id: def.id, group: npcChar });
  });
  rebuildInteractMeshes();
}

// ═══ MANSION ═══
const MANSION_COLLISIONS = [
  // Mansion exterior walls
  { xMin: 264.5, xMax: 305.5, zMin: -10.5, zMax: -10 },   // South wall
  { xMin: 264.5, xMax: 305.5, zMin: 10, zMax: 10.5 },      // North wall
  { xMin: 264.5, xMax: 265, zMin: -10.5, zMax: -3 },        // West wall south
  { xMin: 264.5, xMax: 265, zMin: 3, zMax: 10.5 },          // West wall north
  { xMin: 305, xMax: 305.5, zMin: -10.5, zMax: 10.5 },     // East wall
  // Outdoor fountain
  { xMin: 258, xMax: 262, zMin: -2, zMax: 2 },
];

function buildMansion() {
  const g = new THREE.Group();

  // --- Materials ---
  const marbleMat = new THREE.MeshLambertMaterial({ color: 0xf0ece0 });
  const mansionWallMat = new THREE.MeshLambertMaterial({ color: 0xfaf5e8 });
  const darkWoodMat = new THREE.MeshLambertMaterial({ color: 0x4a3222 });
  const roofMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
  const goldMat = new THREE.MeshLambertMaterial({ color: 0xc9a84c, emissive: 0x665520, emissiveIntensity: 0.2 });
  const stoneMat = new THREE.MeshLambertMaterial({ color: 0x888888 });
  const tennisMat = new THREE.MeshLambertMaterial({ color: 0x2e7d32 });
  const sandMat = new THREE.MeshLambertMaterial({ color: 0xddcc88 });
  const redCarpetMat = new THREE.MeshLambertMaterial({ color: 0x882222 });
  const steelMat = new THREE.MeshLambertMaterial({ color: 0xcccccc });
  const leatherMat = new THREE.MeshLambertMaterial({ color: 0x2a1a10 });
  const fabricMat = new THREE.MeshLambertMaterial({ color: 0x556688 });
  const wineCellarMat = new THREE.MeshLambertMaterial({ color: 0x3a2a1a });
  const theaterWallMat = new THREE.MeshLambertMaterial({ color: 0x1a1a2a });
  const hotTubWaterMat = new THREE.MeshLambertMaterial({ color: 0x44aacc, transparent: true, opacity: 0.6 });
  const canvasMat = new THREE.MeshLambertMaterial({ color: 0xf5f0e0 });
  const arcadeMat = new THREE.MeshLambertMaterial({ color: 0x2222aa });

  // --- Mansion Ground ---
  const mansionGround = new THREE.Mesh(new THREE.PlaneGeometry(65, 55), mat.grass);
  mansionGround.rotation.x = -Math.PI / 2;
  mansionGround.position.set(MANSION_ORIGIN.x, -0.01, MANSION_ORIGIN.z);
  mansionGround.receiveShadow = true;
  g.add(mansionGround);

  // --- Driveway ---
  const driveway = new THREE.Mesh(new THREE.BoxGeometry(14, 0.05, 10), new THREE.MeshLambertMaterial({ color: 0x555555 }));
  driveway.position.set(258, 0.02, -10);
  driveway.receiveShadow = true;
  g.add(driveway);
  // Path to front door
  const path = new THREE.Mesh(new THREE.BoxGeometry(4, 0.04, 6), stoneMat);
  path.position.set(265, 0.02, -5);
  g.add(path);

  // --- Mansion Car ---
  mansionCarGroup = buildCar();
  mansionCarGroup.position.set(256, 0.15, -12);
  mansionCarGroup.rotation.y = Math.PI;
  g.add(mansionCarGroup);
  const mansionCarBody = mansionCarGroup.children[0];
  interactables.push({ mesh: mansionCarBody, group: mansionCarGroup, type: 'mansionCar', label: 'Drive Home', need: null, usePos: new THREE.Vector3(257, 0.15, -11), floor: 0 });

  // --- Decorative Fountain (outdoor) ---
  const ftnBase = new THREE.Mesh(new THREE.CylinderGeometry(2, 2.3, 0.5, 12), stoneMat);
  ftnBase.position.set(260, 0.25, 0);
  g.add(ftnBase);
  const ftnWater = new THREE.Mesh(new THREE.CylinderGeometry(1.7, 1.7, 0.35, 12), mat.water);
  ftnWater.position.set(260, 0.45, 0);
  g.add(ftnWater);
  const ftnPillar = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.25, 1.8, 8), stoneMat);
  ftnPillar.position.set(260, 1.2, 0);
  g.add(ftnPillar);
  const ftnTop = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.15, 0.3, 8), stoneMat);
  ftnTop.position.set(260, 2.15, 0);
  g.add(ftnTop);

  // ═══ MANSION BUILDING — GROUND FLOOR ═══
  // Main floor (marble)
  const mainFloor = new THREE.Mesh(new THREE.BoxGeometry(40, 0.1, 20), marbleMat);
  mainFloor.position.set(285, 0.05, 0);
  mainFloor.receiveShadow = true;
  g.add(mainFloor);

  // Exterior walls
  const wh = 3.5;
  const wy = wh / 2 + 0.1;
  // South wall (Z=-10)
  const sWall = new THREE.Mesh(new THREE.BoxGeometry(41, wh, 0.3), mansionWallMat);
  sWall.position.set(285, wy, -10.15);
  sWall.castShadow = true;
  g.add(sWall);
  // North wall (Z=10)
  const nWall = new THREE.Mesh(new THREE.BoxGeometry(41, wh, 0.3), mansionWallMat);
  nWall.position.set(285, wy, 10.15);
  nWall.castShadow = true;
  g.add(nWall);
  // West wall (X=265) — with entrance gap
  const wWallTop = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.2, 20.3), mansionWallMat);
  wWallTop.position.set(265, wh - 0.5, 0);
  g.add(wWallTop);
  const wWallL = new THREE.Mesh(new THREE.BoxGeometry(0.3, wh, 7), mansionWallMat);
  wWallL.position.set(265, wy, -6.5);
  g.add(wWallL);
  const wWallR = new THREE.Mesh(new THREE.BoxGeometry(0.3, wh, 7), mansionWallMat);
  wWallR.position.set(265, wy, 6.5);
  g.add(wWallR);
  // East wall (X=305)
  const eWall = new THREE.Mesh(new THREE.BoxGeometry(0.3, wh, 20.3), mansionWallMat);
  eWall.position.set(305, wy, 0);
  eWall.castShadow = true;
  g.add(eWall);

  // Door frames (thin posts flanking entrance, no blocking mesh)
  const doorFrameL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2.8, 0.15), darkWoodMat);
  doorFrameL.position.set(265, 1.5, -2.9);
  g.add(doorFrameL);
  const doorFrameR = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2.8, 0.15), darkWoodMat);
  doorFrameR.position.set(265, 1.5, 2.9);
  g.add(doorFrameR);

  // Columns flanking entrance
  [-2.5, 2.5].forEach(dz => {
    const col = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.3, wh, 8), marbleMat);
    col.position.set(264.5, wy, dz);
    col.castShadow = true;
    g.add(col);
  });

  // Roof
  const roof = new THREE.Mesh(new THREE.BoxGeometry(42, 0.4, 22), roofMat);
  roof.position.set(285, wh + 0.3, 0);
  g.add(roof);

  // Windows (exterior)
  [270, 275, 280, 290, 295, 300].forEach(wx => {
    const win = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.5, 0.1), mat.window);
    win.position.set(wx, 2.2, -10.05);
    g.add(win);
    const win2 = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.5, 0.1), mat.window);
    win2.position.set(wx, 2.2, 10.05);
    g.add(win2);
  });

  // === GRAND FOYER (X=265-275, Z=-3 to 3) ===
  // Red carpet
  const carpet = new THREE.Mesh(new THREE.BoxGeometry(8, 0.02, 3), redCarpetMat);
  carpet.position.set(270, 0.12, 0);
  g.add(carpet);
  // Chandelier
  const chandChain = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 1.5, 6), goldMat);
  chandChain.position.set(270, 2.8, 0);
  g.add(chandChain);
  const chandBase = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.4, 0.3, 8), goldMat);
  chandBase.position.set(270, 2.1, 0);
  g.add(chandBase);
  [-0.5, 0, 0.5].forEach(dz => {
    [-0.3, 0.3].forEach(dx => {
      const candle = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 0.2, 6),
        new THREE.MeshLambertMaterial({ color: 0xffeeaa, emissive: 0xffcc44, emissiveIntensity: 0.5 }));
      candle.position.set(270 + dx, 2.35, dz);
      g.add(candle);
    });
  });
  const chandLight = new THREE.PointLight(0xffeecc, 0.6, 15);
  chandLight.position.set(270, 2.5, 0);
  g.add(chandLight);

  // Interior dividing walls
  // Foyer/Kitchen divider (X=275, Z=-10 to -3)
  const divK = new THREE.Mesh(new THREE.BoxGeometry(0.15, wh, 7), mansionWallMat);
  divK.position.set(275, wy, -6.5);
  g.add(divK);
  // Foyer/Living divider (X=275, Z=3 to 10)
  const divL = new THREE.Mesh(new THREE.BoxGeometry(0.15, wh, 7), mansionWallMat);
  divL.position.set(275, wy, 6.5);
  g.add(divL);
  // Kitchen/Theater divider (X=285, Z=-10 to -3)
  const divT = new THREE.Mesh(new THREE.BoxGeometry(0.15, wh, 7), mansionWallMat);
  divT.position.set(285, wy, -6.5);
  g.add(divT);
  // Theater/Spa divider (X=295, Z=-10 to -3)
  const divS = new THREE.Mesh(new THREE.BoxGeometry(0.15, wh, 7), mansionWallMat);
  divS.position.set(295, wy, -6.5);
  g.add(divS);
  // Horizontal divider N/S (Z=-3, X=275 to 285)
  const divH = new THREE.Mesh(new THREE.BoxGeometry(10, wh, 0.15), mansionWallMat);
  divH.position.set(280, wy, -3);
  g.add(divH);
  // Horizontal divider for stair area (Z=3, X=285 to 305)
  const divH2 = new THREE.Mesh(new THREE.BoxGeometry(20, wh, 0.15), mansionWallMat);
  divH2.position.set(295, wy, 3);
  g.add(divH2);

  // === GOURMET KITCHEN (X=275-285, Z=-10 to -3) ===
  // Kitchen island
  const island = new THREE.Mesh(new THREE.BoxGeometry(4, 1, 1.5), steelMat);
  island.position.set(280, 0.6, -6.5);
  island.castShadow = true;
  g.add(island);
  const islandTop = new THREE.Mesh(new THREE.BoxGeometry(4.2, 0.05, 1.7), marbleMat);
  islandTop.position.set(280, 1.12, -6.5);
  g.add(islandTop);
  // Counters along south wall
  const counter = new THREE.Mesh(new THREE.BoxGeometry(8, 1, 0.8), darkWoodMat);
  counter.position.set(280, 0.6, -9.5);
  g.add(counter);
  const counterTop = new THREE.Mesh(new THREE.BoxGeometry(8.2, 0.05, 1), marbleMat);
  counterTop.position.set(280, 1.12, -9.5);
  g.add(counterTop);
  // Stove
  const stove = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.1, 0.7), new THREE.MeshLambertMaterial({ color: 0x222222 }));
  stove.position.set(278, 1.15, -9.5);
  g.add(stove);
  // Fridge (stainless)
  const mFridge = new THREE.Mesh(new THREE.BoxGeometry(1.2, 2.5, 0.8), steelMat);
  mFridge.position.set(276, 1.35, -9.5);
  mFridge.castShadow = true;
  g.add(mFridge);

  interactables.push({ mesh: island, group: g, type: 'mansionKitchen', label: 'Gourmet Meal (Free)', need: 'hunger', usePos: new THREE.Vector3(280, 0.15, -5), floor: 0 });

  // === LIVING ROOM (X=275-285, Z=3 to 10) ===
  // Fireplace
  const fpBase = new THREE.Mesh(new THREE.BoxGeometry(3, 2.5, 0.6), stoneMat);
  fpBase.position.set(280, 1.35, 9.6);
  g.add(fpBase);
  const fpOpening = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.2, 0.3), new THREE.MeshLambertMaterial({ color: 0x111111 }));
  fpOpening.position.set(280, 0.7, 9.7);
  g.add(fpOpening);
  const fireLight = new THREE.PointLight(0xff6622, 0.4, 8);
  fireLight.position.set(280, 0.8, 9);
  g.add(fireLight);
  // Luxury sofa
  const luxSofa = new THREE.Mesh(new THREE.BoxGeometry(3, 0.5, 1.2), leatherMat);
  luxSofa.position.set(280, 0.35, 6.5);
  luxSofa.castShadow = true;
  g.add(luxSofa);
  const sofaBack = new THREE.Mesh(new THREE.BoxGeometry(3, 0.7, 0.2), leatherMat);
  sofaBack.position.set(280, 0.7, 5.9);
  g.add(sofaBack);
  // Grand Piano
  const pianoBody = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.8, 2), new THREE.MeshLambertMaterial({ color: 0x111111 }));
  pianoBody.position.set(277, 0.5, 8);
  pianoBody.castShadow = true;
  g.add(pianoBody);
  const pianoTop = new THREE.Mesh(new THREE.BoxGeometry(2.7, 0.05, 2.2), new THREE.MeshLambertMaterial({ color: 0x1a1a1a }));
  pianoTop.position.set(277, 0.95, 8);
  g.add(pianoTop);
  const pianoKeys = new THREE.Mesh(new THREE.BoxGeometry(2.3, 0.05, 0.3), new THREE.MeshLambertMaterial({ color: 0xfffff0 }));
  pianoKeys.position.set(277, 0.9, 6.9);
  g.add(pianoKeys);
  const pianoBench = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.45, 0.5), darkWoodMat);
  pianoBench.position.set(277, 0.25, 6.2);
  g.add(pianoBench);

  interactables.push({ mesh: pianoBody, group: g, type: 'grandPiano', label: 'Play Grand Piano', need: 'fun', usePos: new THREE.Vector3(277, 0.15, 6), floor: 0 });

  // === HOME THEATER (X=285-295, Z=-10 to -3) ===
  // Dark walls
  const thWallW = new THREE.Mesh(new THREE.BoxGeometry(0.05, wh, 7), theaterWallMat);
  thWallW.position.set(285.1, wy, -6.5);
  g.add(thWallW);
  const thWallE = new THREE.Mesh(new THREE.BoxGeometry(0.05, wh, 7), theaterWallMat);
  thWallE.position.set(294.9, wy, -6.5);
  g.add(thWallE);
  // Big screen
  const bigScreen = new THREE.Mesh(new THREE.BoxGeometry(6, 3, 0.15),
    new THREE.MeshLambertMaterial({ color: 0x223344, emissive: 0x112233, emissiveIntensity: 0.6 }));
  bigScreen.position.set(290, 2, -9.8);
  g.add(bigScreen);
  const screenFrame = new THREE.Mesh(new THREE.BoxGeometry(6.4, 3.4, 0.1), new THREE.MeshLambertMaterial({ color: 0x111111 }));
  screenFrame.position.set(290, 2, -9.9);
  g.add(screenFrame);
  // Recliner seats (2 rows)
  [-1.5, 0, 1.5].forEach(dx => {
    const seat = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.5, 1), leatherMat);
    seat.position.set(290 + dx, 0.35, -7);
    seat.castShadow = true;
    g.add(seat);
    const sBack = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.8, 0.2), leatherMat);
    sBack.position.set(290 + dx, 0.75, -7.5);
    g.add(sBack);
  });
  const theaterLight = new THREE.PointLight(0x4466aa, 0.3, 10);
  theaterLight.position.set(290, 3, -6.5);
  g.add(theaterLight);

  interactables.push({ mesh: bigScreen, group: g, type: 'homeTheater', label: 'Watch Movie (Theater)', need: 'fun', usePos: new THREE.Vector3(290, 0.15, -6), floor: 0 });

  // === SPA BATHROOM (X=295-305, Z=-10 to -3) ===
  // Marble tub
  const tubOuter = new THREE.Mesh(new THREE.BoxGeometry(3, 0.8, 2), marbleMat);
  tubOuter.position.set(300, 0.5, -7);
  tubOuter.castShadow = true;
  g.add(tubOuter);
  const tubInner = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.6, 1.6), mat.water);
  tubInner.position.set(300, 0.55, -7);
  g.add(tubInner);
  // Gold fixtures
  const fixture = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.15), goldMat);
  fixture.position.set(301.3, 1, -7);
  g.add(fixture);
  // Spa light
  const spaLight = new THREE.PointLight(0xaaddff, 0.3, 8);
  spaLight.position.set(300, 2.5, -7);
  g.add(spaLight);

  interactables.push({ mesh: tubOuter, group: g, type: 'mansionSpa', label: 'Relax in Spa', need: 'hygiene', usePos: new THREE.Vector3(298, 0.15, -7), floor: 0 });

  // === WINE CELLAR (below foyer — X=265-275, Z=-10 to -3) ===
  // Wine cellar stairs down from kitchen corner
  const wineStairFloor = new THREE.Mesh(new THREE.BoxGeometry(2, 0.05, 3), darkWoodMat);
  wineStairFloor.position.set(276, -1.5, -8);
  g.add(wineStairFloor);
  // Wine rack
  const wineRack = new THREE.Mesh(new THREE.BoxGeometry(3, 2, 0.6), darkWoodMat);
  wineRack.position.set(270, 0.3, -9.5);
  wineRack.castShadow = true;
  g.add(wineRack);
  // Wine bottles
  for (let row = 0; row < 3; row++) {
    for (let col = 0; col < 5; col++) {
      const bottle = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 0.4, 6),
        new THREE.MeshLambertMaterial({ color: [0x440022, 0x002244, 0x224400][row] }));
      bottle.rotation.z = Math.PI / 2;
      bottle.position.set(269 + col * 0.6, 0.5 + row * 0.5, -9.3);
      g.add(bottle);
    }
  }

  interactables.push({ mesh: wineRack, group: g, type: 'wineRack', label: 'Taste Wine', need: 'fun', usePos: new THREE.Vector3(270, 0.15, -8), floor: 0 });

  // === GRAND STAIRCASE (X=285-288, Z=3 to 10) ===
  const MSTEPS = 8;
  const mStepW = 3;
  const mStepD = 7 / MSTEPS;
  for (let i = 0; i < MSTEPS; i++) {
    const stepH = ((i + 1) / MSTEPS) * (MANSION_UPPER_Y - GROUND_Y);
    const step = new THREE.Mesh(new THREE.BoxGeometry(mStepW, stepH, mStepD), marbleMat);
    step.position.set(286.5, GROUND_Y + stepH / 2, MANSION_STAIR.zMin + (i + 0.5) * mStepD);
    step.castShadow = true;
    g.add(step);
  }

  // ═══ UPPER FLOOR ═══
  // Upper floor slab (with stairwell hole)
  // Right portion: X=288-305
  const uFloor1 = new THREE.Mesh(new THREE.BoxGeometry(17, 0.15, 20), marbleMat);
  uFloor1.position.set(296.5, MANSION_UPPER_Y - 0.075, 0);
  g.add(uFloor1);
  // Left portion: X=265-285
  const uFloor2 = new THREE.Mesh(new THREE.BoxGeometry(20, 0.15, 20), marbleMat);
  uFloor2.position.set(275, MANSION_UPPER_Y - 0.075, 0);
  g.add(uFloor2);
  // Front portion above stairwell: X=285-288, Z=-10 to 3
  const uFloor3 = new THREE.Mesh(new THREE.BoxGeometry(3, 0.15, 13), marbleMat);
  uFloor3.position.set(286.5, MANSION_UPPER_Y - 0.075, -3.5);
  g.add(uFloor3);

  // Upper walls
  const uwh = 3.5;
  const uwy = MANSION_UPPER_Y + uwh / 2;
  const uWallS = new THREE.Mesh(new THREE.BoxGeometry(41, uwh, 0.3), mansionWallMat);
  uWallS.position.set(285, uwy, -10.15);
  g.add(uWallS);
  const uWallN = new THREE.Mesh(new THREE.BoxGeometry(41, uwh, 0.3), mansionWallMat);
  uWallN.position.set(285, uwy, 10.15);
  g.add(uWallN);
  const uWallW = new THREE.Mesh(new THREE.BoxGeometry(0.3, uwh, 20.3), mansionWallMat);
  uWallW.position.set(265, uwy, 0);
  g.add(uWallW);
  const uWallE = new THREE.Mesh(new THREE.BoxGeometry(0.3, uwh, 20.3), mansionWallMat);
  uWallE.position.set(305, uwy, 0);
  g.add(uWallE);

  // Upper ceiling
  const uCeil = new THREE.Mesh(new THREE.BoxGeometry(41, 0.15, 20.3), mansionWallMat);
  uCeil.position.set(285, MANSION_UPPER_Y + uwh + 0.075, 0);
  g.add(uCeil);

  // Upper floor dividers
  // Master/Library divider (Z=0, X=265-280)
  const uDivML = new THREE.Mesh(new THREE.BoxGeometry(15, uwh, 0.15), mansionWallMat);
  uDivML.position.set(272.5, uwy, 0);
  g.add(uDivML);
  // Art/Game divider (Z=0, X=290-305) — partial, leave gap for balcony access
  const uDivAG = new THREE.Mesh(new THREE.BoxGeometry(15, uwh, 0.15), mansionWallMat);
  uDivAG.position.set(297.5, uwy, 0);
  g.add(uDivAG);
  // Left/Right divider (X=280, full height)
  const uDivLR = new THREE.Mesh(new THREE.BoxGeometry(0.15, uwh, 20), mansionWallMat);
  uDivLR.position.set(280, uwy, 0);
  g.add(uDivLR);
  // Art/Balcony divider (X=290)
  const uDivAB = new THREE.Mesh(new THREE.BoxGeometry(0.15, uwh, 10), mansionWallMat);
  uDivAB.position.set(290, uwy, -5);
  g.add(uDivAB);

  // Upper windows
  [270, 275, 295, 300].forEach(wx => {
    const uWin = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.5, 0.1), mat.window);
    uWin.position.set(wx, MANSION_UPPER_Y + 2, -10.05);
    g.add(uWin);
    const uWin2 = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.5, 0.1), mat.window);
    uWin2.position.set(wx, MANSION_UPPER_Y + 2, 10.05);
    g.add(uWin2);
  });

  // Stairwell railing (upper)
  const uRail = new THREE.Mesh(new THREE.BoxGeometry(3, 0.8, 0.08), goldMat);
  uRail.position.set(286.5, MANSION_UPPER_Y + 0.4, MANSION_STAIR.zMin);
  g.add(uRail);
  const uRailSide = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.8, 7), goldMat);
  uRailSide.position.set(288, MANSION_UPPER_Y + 0.4, 6.5);
  g.add(uRailSide);

  // === MASTER BEDROOM (upper, X=265-280, Z=-10 to 0) ===
  // King bed
  const kingFrame = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.5, 2.5), darkWoodMat);
  kingFrame.position.set(270, MANSION_UPPER_Y + 0.25, -7);
  kingFrame.castShadow = true;
  g.add(kingFrame);
  const kingMattress = new THREE.Mesh(new THREE.BoxGeometry(3.3, 0.25, 2.3),
    new THREE.MeshLambertMaterial({ color: 0xeeeedd }));
  kingMattress.position.set(270, MANSION_UPPER_Y + 0.625, -7);
  g.add(kingMattress);
  const kingSheet = new THREE.Mesh(new THREE.BoxGeometry(3.3, 0.05, 1.5),
    new THREE.MeshLambertMaterial({ color: 0x882244 }));
  kingSheet.position.set(270, MANSION_UPPER_Y + 0.77, -7.3);
  g.add(kingSheet);
  const kingHeadboard = new THREE.Mesh(new THREE.BoxGeometry(3.5, 1.2, 0.2), darkWoodMat);
  kingHeadboard.position.set(270, MANSION_UPPER_Y + 1, -8.35);
  g.add(kingHeadboard);
  // Pillows
  [-0.7, 0.7].forEach(dx => {
    const kPillow = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.2, 0.5), mat.pillow);
    kPillow.position.set(270 + dx, MANSION_UPPER_Y + 0.85, -7.8);
    g.add(kPillow);
  });
  // Vanity
  const vanity = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1, 0.5), darkWoodMat);
  vanity.position.set(278, MANSION_UPPER_Y + 0.5, -9);
  g.add(vanity);
  const vanityMirror = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.2, 0.05), mat.window);
  vanityMirror.position.set(278, MANSION_UPPER_Y + 1.6, -9.8);
  g.add(vanityMirror);
  // Rug
  const bedroomRug = new THREE.Mesh(new THREE.BoxGeometry(4, 0.02, 3), redCarpetMat);
  bedroomRug.position.set(270, MANSION_UPPER_Y + 0.01, -4);
  g.add(bedroomRug);

  interactables.push({ mesh: kingFrame, group: g, type: 'kingBed', label: 'Sleep (King Bed)', need: 'energy', usePos: new THREE.Vector3(272, MANSION_UPPER_Y, -6), floor: 1 });

  // === LIBRARY (upper, X=265-280, Z=0 to 10) ===
  // Bookshelves along walls
  [-1, 3, 7].forEach(dz => {
    const shelf = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2.8, 2.5), darkWoodMat);
    shelf.position.set(265.5, MANSION_UPPER_Y + 1.4, dz + 3);
    shelf.castShadow = true;
    g.add(shelf);
    // Books on shelves
    for (let row = 0; row < 4; row++) {
      for (let b = 0; b < 4; b++) {
        const book = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.35, 0.25),
          new THREE.MeshLambertMaterial({ color: [0xaa3333, 0x3333aa, 0x33aa33, 0xaa8833, 0x8833aa, 0x33aaaa][Math.floor(Math.random() * 6)] }));
        book.position.set(265.35, MANSION_UPPER_Y + 0.5 + row * 0.7, dz + 2.2 + b * 0.55);
        g.add(book);
      }
    }
  });
  // Reading chair
  const readChair = new THREE.Mesh(new THREE.BoxGeometry(1, 0.5, 1), leatherMat);
  readChair.position.set(273, MANSION_UPPER_Y + 0.25, 5);
  readChair.castShadow = true;
  g.add(readChair);
  const readChairBack = new THREE.Mesh(new THREE.BoxGeometry(1, 0.8, 0.2), leatherMat);
  readChairBack.position.set(273, MANSION_UPPER_Y + 0.65, 5.5);
  g.add(readChairBack);
  // Globe
  const globeStand = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.08, 0.8, 6), goldMat);
  globeStand.position.set(276, MANSION_UPPER_Y + 0.4, 8.5);
  g.add(globeStand);
  const globe = new THREE.Mesh(new THREE.SphereGeometry(0.35, 12, 8),
    new THREE.MeshLambertMaterial({ color: 0x3366aa }));
  globe.position.set(276, MANSION_UPPER_Y + 1.0, 8.5);
  g.add(globe);

  interactables.push({ mesh: readChair, group: g, type: 'mansionLibrary', label: 'Study (Library)', need: 'fun', usePos: new THREE.Vector3(272, MANSION_UPPER_Y, 5), floor: 1 });

  // === ART STUDIO (upper, X=280-290, Z=-10 to 0) ===
  // Easel
  const easelLeg1 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 2, 0.08), darkWoodMat);
  easelLeg1.position.set(284, MANSION_UPPER_Y + 1, -5);
  g.add(easelLeg1);
  const easelLeg2 = new THREE.Mesh(new THREE.BoxGeometry(0.08, 2, 0.08), darkWoodMat);
  easelLeg2.position.set(284.6, MANSION_UPPER_Y + 1, -5);
  g.add(easelLeg2);
  const canvas = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.2, 0.05), canvasMat);
  canvas.position.set(284.3, MANSION_UPPER_Y + 1.5, -5);
  canvas.castShadow = true;
  g.add(canvas);
  // Paint palette
  const palette = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.05, 8), darkWoodMat);
  palette.position.set(283, MANSION_UPPER_Y + 0.9, -4);
  g.add(palette);
  // Paint blobs
  [0xff3333, 0x3333ff, 0xffff33, 0x33ff33, 0xff33ff].forEach((col, i) => {
    const blob = new THREE.Mesh(new THREE.SphereGeometry(0.06, 6, 4),
      new THREE.MeshLambertMaterial({ color: col }));
    blob.position.set(283 + Math.cos(i * 1.2) * 0.15, MANSION_UPPER_Y + 0.95, -4 + Math.sin(i * 1.2) * 0.15);
    g.add(blob);
  });
  // Skylight (window in ceiling above art studio)
  const skylight = new THREE.Mesh(new THREE.BoxGeometry(4, 0.1, 4), mat.window);
  skylight.position.set(285, MANSION_UPPER_Y + uwh + 0.1, -5);
  g.add(skylight);

  interactables.push({ mesh: canvas, group: g, type: 'artEasel', label: 'Paint (Easel) +$15', need: 'fun', usePos: new THREE.Vector3(283, MANSION_UPPER_Y, -4), floor: 1 });

  // === GAME ROOM (upper, X=290-305, Z=-10 to 0) ===
  // Arcade cabinet
  const arcadeBody = new THREE.Mesh(new THREE.BoxGeometry(1, 2.2, 0.8), arcadeMat);
  arcadeBody.position.set(295, MANSION_UPPER_Y + 1.1, -8);
  arcadeBody.castShadow = true;
  g.add(arcadeBody);
  const arcadeScreen = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.6, 0.05),
    new THREE.MeshLambertMaterial({ color: 0x113322, emissive: 0x00ff44, emissiveIntensity: 0.4 }));
  arcadeScreen.position.set(295, MANSION_UPPER_Y + 1.7, -7.55);
  g.add(arcadeScreen);
  const arcadeMarquee = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.3, 0.05),
    new THREE.MeshLambertMaterial({ color: 0xff4444, emissive: 0xff2222, emissiveIntensity: 0.3 }));
  arcadeMarquee.position.set(295, MANSION_UPPER_Y + 2.15, -7.55);
  g.add(arcadeMarquee);
  // Pool table (decorative)
  const poolTable = new THREE.Mesh(new THREE.BoxGeometry(3, 0.9, 1.5),
    new THREE.MeshLambertMaterial({ color: 0x006633 }));
  poolTable.position.set(300, MANSION_UPPER_Y + 0.45, -5);
  poolTable.castShadow = true;
  g.add(poolTable);
  const poolRim = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.15, 1.7), darkWoodMat);
  poolRim.position.set(300, MANSION_UPPER_Y + 0.95, -5);
  g.add(poolRim);

  interactables.push({ mesh: arcadeBody, group: g, type: 'mansionArcade', label: 'Play Arcade', need: 'fun', usePos: new THREE.Vector3(295, MANSION_UPPER_Y, -7), floor: 1 });

  // === BALCONY + HOT TUB (upper, X=290-305, Z=0 to 10) ===
  // Balcony railing (open-air feel)
  const balRailN = new THREE.Mesh(new THREE.BoxGeometry(15, 1, 0.1), goldMat);
  balRailN.position.set(297.5, MANSION_UPPER_Y + 0.5, 9.9);
  g.add(balRailN);
  const balRailE = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1, 10), goldMat);
  balRailE.position.set(304.9, MANSION_UPPER_Y + 0.5, 5);
  g.add(balRailE);
  // Remove wall segments for balcony (the walls were already placed, but the railing gives the open-air feel)
  // Hot tub
  const htOuter = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 0.8, 10), darkWoodMat);
  htOuter.position.set(298, MANSION_UPPER_Y + 0.4, 6);
  htOuter.castShadow = true;
  g.add(htOuter);
  const htWater = new THREE.Mesh(new THREE.CylinderGeometry(1.3, 1.3, 0.6, 10), hotTubWaterMat);
  htWater.position.set(298, MANSION_UPPER_Y + 0.45, 6);
  g.add(htWater);
  // Lounge chairs
  [302, 303.5].forEach(cx => {
    const lounger = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.3, 2), new THREE.MeshLambertMaterial({ color: 0xeeeeee }));
    lounger.position.set(cx, MANSION_UPPER_Y + 0.15, 6);
    g.add(lounger);
  });

  interactables.push({ mesh: htOuter, group: g, type: 'hotTub', label: 'Soak in Hot Tub', need: 'hygiene', usePos: new THREE.Vector3(296, MANSION_UPPER_Y, 6), floor: 1 });

  // === OUTDOOR: TENNIS COURT (X=255-265, Z=5 to 15) ===
  const court = new THREE.Mesh(new THREE.BoxGeometry(10, 0.05, 10), tennisMat);
  court.position.set(260, 0.03, 10);
  court.receiveShadow = true;
  g.add(court);
  // Court lines
  const lineMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
  // Outline
  const lineN = new THREE.Mesh(new THREE.BoxGeometry(10, 0.01, 0.1), lineMat);
  lineN.position.set(260, 0.06, 15);
  g.add(lineN);
  const lineS2 = new THREE.Mesh(new THREE.BoxGeometry(10, 0.01, 0.1), lineMat);
  lineS2.position.set(260, 0.06, 5);
  g.add(lineS2);
  const lineW2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.01, 10), lineMat);
  lineW2.position.set(255, 0.06, 10);
  g.add(lineW2);
  const lineE2 = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.01, 10), lineMat);
  lineE2.position.set(265, 0.06, 10);
  g.add(lineE2);
  // Center line
  const centerLine = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.01, 10), lineMat);
  centerLine.position.set(260, 0.06, 10);
  g.add(centerLine);
  // Net
  const netPost1 = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.2, 6), steelMat);
  netPost1.position.set(255.2, 0.6, 10);
  g.add(netPost1);
  const netPost2 = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.2, 6), steelMat);
  netPost2.position.set(264.8, 0.6, 10);
  g.add(netPost2);
  const net = new THREE.Mesh(new THREE.BoxGeometry(9.4, 0.8, 0.05),
    new THREE.MeshLambertMaterial({ color: 0xeeeeee, transparent: true, opacity: 0.5 }));
  net.position.set(260, 0.7, 10);
  g.add(net);

  interactables.push({ mesh: court, group: g, type: 'tennisCourt', label: 'Play Tennis', need: 'fun', usePos: new THREE.Vector3(258, 0.15, 8), floor: 0 });

  // === OUTDOOR: ZEN GARDEN (X=265-275, Z=12 to 20) ===
  const zenBase = new THREE.Mesh(new THREE.BoxGeometry(10, 0.05, 8), sandMat);
  zenBase.position.set(270, 0.03, 16);
  zenBase.receiveShadow = true;
  g.add(zenBase);
  // Raked lines
  for (let z = 13; z <= 19; z += 1) {
    const rake = new THREE.Mesh(new THREE.BoxGeometry(8, 0.01, 0.08),
      new THREE.MeshLambertMaterial({ color: 0xccbb77 }));
    rake.position.set(270, 0.06, z);
    g.add(rake);
  }
  // Zen rocks
  [{ x: 268, z: 14.5, s: 0.5 }, { x: 272, z: 16, s: 0.7 }, { x: 269, z: 18, s: 0.4 }].forEach(r => {
    const rock = new THREE.Mesh(new THREE.SphereGeometry(r.s, 6, 5), stoneMat);
    rock.position.set(r.x, r.s * 0.5, r.z);
    rock.castShadow = true;
    g.add(rock);
  });
  // Bamboo
  [266.5, 267.5, 273.5].forEach(bx => {
    const stalk = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.1, 3, 6),
      new THREE.MeshLambertMaterial({ color: 0x558833 }));
    stalk.position.set(bx, 1.5, 19);
    g.add(stalk);
    const leaves = new THREE.Mesh(new THREE.SphereGeometry(0.4, 6, 4),
      new THREE.MeshLambertMaterial({ color: 0x44aa33 }));
    leaves.position.set(bx, 3, 19);
    g.add(leaves);
  });

  interactables.push({ mesh: zenBase, group: g, type: 'zenGarden', label: 'Meditate (Garden)', need: 'fun', usePos: new THREE.Vector3(270, 0.15, 14), floor: 0 });

  // === MANSION LIGHTING ===
  const mansionLight = new THREE.PointLight(0xffeedd, 0.5, 80);
  mansionLight.position.set(MANSION_ORIGIN.x, 12, MANSION_ORIGIN.z);
  g.add(mansionLight);
  // Upper floor light
  const upperLight = new THREE.PointLight(0xffeedd, 0.4, 40);
  upperLight.position.set(285, MANSION_UPPER_Y + 3, 0);
  g.add(upperLight);

  // === ACTION CONFIGS ===
  actionConfig.mansionKitchen = { label: 'Cooking gourmet meal...', duration: 4, restore: 70, cost: 0 };
  actionConfig.homeTheater = { label: 'Watching movie...', duration: 5, restore: 60, cost: 0 };
  actionConfig.mansionSpa = { label: 'Relaxing in spa...', duration: 6, restore: 80, cost: 0, funBonus: 20 };
  actionConfig.kingBed = { label: 'Sleeping like royalty...', duration: 7, restore: 85, cost: 0 };
  actionConfig.mansionLibrary = { label: 'Studying...', duration: 4, restore: 55, cost: 0 };
  actionConfig.artEasel = { label: 'Painting...', duration: 6, restore: 40, cost: 0, earn: 15 };
  actionConfig.mansionArcade = { label: 'Playing arcade...', duration: 5, restore: 50, cost: 0 };
  actionConfig.hotTub = { label: 'Soaking in hot tub...', duration: 5, restore: 70, cost: 0, funBonus: 25 };
  actionConfig.wineRack = { label: 'Tasting wine...', duration: 3, restore: 35, cost: 0 };
  actionConfig.tennisCourt = { label: 'Playing tennis...', duration: 5, restore: 45, cost: 0, hungerDrain: 15, energyBonus: 20 };
  actionConfig.zenGarden = { label: 'Meditating...', duration: 4, restore: 30, cost: 0, hygieneBonus: 10 };

  rebuildInteractMeshes();
  scene.add(g);
  g.visible = false;
  return g;
}

function openNPCDialogue(npcId) {
  if (npcDialogueOpen || currentAction || jobMiniGameRunning) return;
  npcDialogueOpen = true;
  currentNPCId = npcId;
  if (document.pointerLockElement) document.exitPointerLock();

  const def = TOWN_NPC_DEFS.find(d => d.id === npcId);
  const overlay = document.getElementById('npc-dialogue-overlay');
  const nameEl = document.getElementById('npc-dialogue-name');
  const textEl = document.getElementById('npc-dialogue-text');
  const btnsEl = document.getElementById('npc-dialogue-btns');

  nameEl.textContent = def.name;
  btnsEl.innerHTML = '';

  // Find quest for this NPC
  const questEntry = Object.entries(QUESTS).find(([, q]) => q.npc === npcId);
  if (!questEntry) {
    textEl.textContent = "Hello there!";
    addDialogueBtn(btnsEl, 'Close', 'npc-btn-close', closeNPCDialogue);
    overlay.classList.add('visible');
    return;
  }

  const [questId, quest] = questEntry;
  const state = questLog[questId];

  if (!state) {
    // Offer quest
    textEl.textContent = quest.offer;
    addDialogueBtn(btnsEl, 'Accept', 'npc-btn-accept', () => acceptQuest(questId));
    addDialogueBtn(btnsEl, 'Not now', 'npc-btn-close', closeNPCDialogue);
  } else if (state.status === 'active') {
    if (quest.condition()) {
      // Complete quest
      textEl.textContent = quest.complete;
      addDialogueBtn(btnsEl, 'Collect Reward', 'npc-btn-accept', () => completeQuest(questId));
    } else {
      // Still in progress
      textEl.textContent = quest.active;
      addDialogueBtn(btnsEl, 'OK', 'npc-btn-close', closeNPCDialogue);
    }
  } else {
    // Already completed
    textEl.textContent = "Thanks again for your help!";
    addDialogueBtn(btnsEl, 'Close', 'npc-btn-close', closeNPCDialogue);
  }

  // Add "Work a shift" button if this NPC has a job
  const job = TOWN_JOBS[npcId];
  if (job) {
    if (jobLastDay[npcId] === day) {
      const disBtn = document.createElement('button');
      disBtn.textContent = 'Already worked today';
      disBtn.className = 'npc-btn-close';
      disBtn.disabled = true;
      disBtn.style.opacity = '0.5';
      btnsEl.appendChild(disBtn);
    } else {
      addDialogueBtn(btnsEl, 'Work: ' + job.name + ' ($' + job.basePay + '+)', 'npc-btn-accept', () => startTownJob(npcId));
    }
  }

  overlay.classList.add('visible');
}

function addDialogueBtn(container, text, cls, onclick) {
  const btn = document.createElement('button');
  btn.textContent = text;
  btn.className = cls;
  btn.onclick = onclick;
  container.appendChild(btn);
}

function acceptQuest(questId) {
  questLog[questId] = { status: 'active' };
  showTip('Quest accepted: ' + QUESTS[questId].name);
  closeNPCDialogue();
}

function completeQuest(questId) {
  const quest = QUESTS[questId];
  questLog[questId].status = 'completed';
  questsCompleted++;
  if (quest.reward.money) { money += quest.reward.money; SFX.kaChing(); }
  if (quest.reward.fun) needs.fun = Math.min(100, needs.fun + quest.reward.fun);
  showTip('Quest complete! +$' + (quest.reward.money || 0));
  mlTry('ml_helpful_neighbor');
  if (questsCompleted >= 4) mlTry('ml_town_hero');
  if (Math.floor(money) >= 500) mlTry('ml_high_roller');
  closeNPCDialogue();
}

function closeNPCDialogue() {
  npcDialogueOpen = false;
  currentNPCId = null;
  document.getElementById('npc-dialogue-overlay').classList.remove('visible');
}

// ═══ TOWN JOBS ═══
function startTownJob(npcId) {
  closeNPCDialogue();
  jobMiniGameRunning = true;
  const overlay = document.getElementById('job-overlay');
  const job = TOWN_JOBS[npcId];
  overlay.innerHTML = '<div class="job-screen-box"><canvas id="job-canvas" width="640" height="360"></canvas></div>' +
    '<div class="job-hint" id="job-hint"></div>';
  overlay.classList.add('visible');
  const canvas = document.getElementById('job-canvas');
  const ctx = canvas.getContext('2d');
  const hintEl = document.getElementById('job-hint');
  if (npcId === 'barista') {
    hintEl.innerHTML = '<kbd>W</kbd> Water  <kbd>M</kbd> Milk  <kbd>C</kbd> Coffee  <kbd>S</kbd> Sugar';
    runCafeJob(canvas, ctx, (score) => finishTownJob(npcId, score));
  } else if (npcId === 'merchant') {
    hintEl.innerHTML = '<kbd>A</kbd> / <kbd>D</kbd> Move cart';
    runShopJob(canvas, ctx, (score) => finishTownJob(npcId, score));
  } else if (npcId === 'mayor') {
    hintEl.innerHTML = '<kbd>A</kbd> Approve  <kbd>D</kbd> Deny';
    runTownHallJob(canvas, ctx, (score) => finishTownJob(npcId, score));
  }
}

function finishTownJob(npcId, score) {
  jobMiniGameRunning = false;
  const job = TOWN_JOBS[npcId];
  const finalScore = Math.max(0, score);
  const pay = job.basePay + Math.floor(finalScore * 0.5);
  money += pay;
  needs.energy = Math.max(0, needs.energy - 15);
  needs.hunger = Math.max(0, needs.hunger - 10);
  jobLastDay[npcId] = day;
  totalShiftsWorked++;
  SFX.jobComplete();
  SFX.kaChing();
  mlTry('ml_first_shift');
  if (totalShiftsWorked >= 10) mlTry('ml_hard_worker');
  if (totalShiftsWorked >= 25) mlTry('ml_employee_month');
  if (Math.floor(money) >= 500) mlTry('ml_high_roller');
  showTip('Shift done! Earned $' + pay);
  const overlay = document.getElementById('job-overlay');
  overlay.classList.remove('visible');
  setTimeout(() => { overlay.innerHTML = ''; }, 500);
}

// --- Cafe: Order Rush ---
function runCafeJob(canvas, ctx, onFinish) {
  const W = canvas.width, H = canvas.height;
  const DRINKS = [
    { name: 'Espresso',   recipe: ['C','W'] },
    { name: 'Latte',      recipe: ['C','M','W'] },
    { name: 'Mocha',      recipe: ['C','M','S'] },
    { name: 'Tea',        recipe: ['W','W','S'] },
    { name: 'Cappuccino', recipe: ['C','M','M'] },
    { name: 'Americano',  recipe: ['C','W','W'] },
    { name: 'Sweet Milk', recipe: ['M','S'] },
    { name: 'Hot Cocoa',  recipe: ['M','S','W'] },
  ];
  const KEY_COLORS = { W: '#4488cc', M: '#eeeedd', C: '#6b3a1f', S: '#ffcc44' };
  const KEY_NAMES = { W: 'Water', M: 'Milk', C: 'Coffee', S: 'Sugar' };
  let orders = [];
  let score = 0;
  let timeLeft = 30;
  let lastTime = performance.now();
  let spawnTimer = 0;
  let spawnInterval = 4.5;
  let flash = null;
  let running = true;

  function spawnOrder() {
    const drink = DRINKS[Math.floor(Math.random() * DRINKS.length)];
    orders.push({ name: drink.name, recipe: [...drink.recipe], progress: 0, timer: 10, x: 0 });
  }
  spawnOrder();

  function onKey(e) {
    if (!running) return;
    const k = e.key.toUpperCase();
    if (!['W','M','C','S'].includes(k)) return;
    e.preventDefault();
    flash = { key: k, t: 0.3 };
    if (orders.length === 0) return;
    const order = orders[0];
    if (order.recipe[order.progress] === k) {
      order.progress++;
      SFX.jobCorrect();
      if (order.progress >= order.recipe.length) {
        score += 10;
        orders.shift();
      }
    } else {
      score = Math.max(0, score - 1);
      order.progress = 0;
      SFX.jobWrong();
    }
  }
  document.addEventListener('keydown', onKey);

  function draw() {
    const now = performance.now();
    const dt = Math.min((now - lastTime) / 1000, 0.05);
    lastTime = now;
    timeLeft -= dt;
    spawnTimer += dt;
    if (spawnTimer >= spawnInterval) {
      spawnTimer = 0;
      spawnInterval = Math.max(2.5, spawnInterval - 0.1);
      if (orders.length < 5) spawnOrder();
    }
    // Update orders
    for (let i = orders.length - 1; i >= 0; i--) {
      orders[i].timer -= dt;
      if (orders[i].timer <= 0) {
        score = Math.max(0, score - 1);
        orders.splice(i, 1);
      }
    }
    if (flash) { flash.t -= dt; if (flash.t <= 0) flash = null; }

    // Draw
    ctx.fillStyle = '#3a2218';
    ctx.fillRect(0, 0, W, H);
    // Counter
    ctx.fillStyle = '#5a3a28';
    ctx.fillRect(0, H - 80, W, 80);
    ctx.fillStyle = '#7a5a48';
    ctx.fillRect(0, H - 82, W, 4);

    // Orders as tickets
    const ticketW = 110, ticketH = 130, gap = 12;
    const startX = (W - Math.min(orders.length, 5) * (ticketW + gap)) / 2;
    orders.forEach((order, i) => {
      if (i >= 5) return;
      const tx = startX + i * (ticketW + gap);
      const ty = 30;
      // Ticket bg
      ctx.fillStyle = i === 0 ? '#fff8e0' : '#e8e0d0';
      ctx.fillRect(tx, ty, ticketW, ticketH);
      ctx.strokeStyle = i === 0 ? '#c9a84c' : '#999';
      ctx.lineWidth = i === 0 ? 2 : 1;
      ctx.strokeRect(tx, ty, ticketW, ticketH);
      // Drink name
      ctx.fillStyle = '#333';
      ctx.font = 'bold 13px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(order.name, tx + ticketW / 2, ty + 20);
      // Recipe keys
      order.recipe.forEach((k, ki) => {
        const kx = tx + 15 + ki * 32;
        const ky = ty + 40;
        ctx.fillStyle = ki < order.progress ? '#44aa44' : (ki === order.progress && i === 0 ? '#ffcc44' : '#888');
        ctx.beginPath();
        ctx.arc(kx + 12, ky + 12, 12, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 14px monospace';
        ctx.fillText(k, kx + 12, ky + 17);
      });
      // Timer bar
      const barY = ty + ticketH - 16;
      const pct = Math.max(0, order.timer / 10);
      ctx.fillStyle = '#ddd';
      ctx.fillRect(tx + 5, barY, ticketW - 10, 8);
      ctx.fillStyle = pct > 0.3 ? '#44aa44' : '#cc4444';
      ctx.fillRect(tx + 5, barY, (ticketW - 10) * pct, 8);
    });

    // Key flash
    if (flash) {
      ctx.fillStyle = KEY_COLORS[flash.key] || '#fff';
      ctx.globalAlpha = flash.t / 0.3;
      ctx.font = 'bold 48px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(flash.key, W / 2, H - 30);
      ctx.globalAlpha = 1;
    }

    // HUD
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 16px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('Score: ' + score, 10, 22);
    ctx.textAlign = 'right';
    ctx.fillText('$' + (15 + Math.floor(Math.max(0, score) * 0.5)), W - 10, 22);
    ctx.textAlign = 'center';
    ctx.fillText(Math.ceil(Math.max(0, timeLeft)) + 's', W / 2, H - 50);

    if (timeLeft <= 0) {
      running = false;
      document.removeEventListener('keydown', onKey);
      onFinish(score);
      return;
    }
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
}

// --- Shop: Shelf Stocker ---
function runShopJob(canvas, ctx, onFinish) {
  const W = canvas.width, H = canvas.height;
  const ITEM_TYPES = [
    { name: 'Box', color: '#cc8844', w: 24, h: 24 },
    { name: 'Can', color: '#44aa66', w: 18, h: 26 },
    { name: 'Jar', color: '#aa66cc', w: 20, h: 24 },
    { name: 'Bag', color: '#cc6644', w: 26, h: 20 },
    { name: 'Bottle', color: '#4488cc', w: 16, h: 28 },
  ];
  const BOMB = { name: 'Bomb', color: '#cc2222', w: 22, h: 22, isBomb: true };
  let cart = { x: W / 2, w: 110 };
  let items = [];
  let particles = [];
  let score = 0;
  let timeLeft = 30;
  let lastTime = performance.now();
  let spawnTimer = 0;
  let spawnInterval = 1.2;
  let keys = {};
  let screenFlash = 0;
  let running = true;

  function spawnItem() {
    const isBomb = Math.random() < 0.1;
    const type = isBomb ? BOMB : ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)];
    items.push({ x: 30 + Math.random() * (W - 60), y: -20, speed: 60 + Math.random() * 40 + (30 - timeLeft) * 2, type });
  }

  function onKey(e) {
    if (!running) return;
    const k = e.key.toLowerCase();
    if (k === 'a' || k === 'arrowleft') { keys.left = e.type === 'keydown'; e.preventDefault(); }
    if (k === 'd' || k === 'arrowright') { keys.right = e.type === 'keydown'; e.preventDefault(); }
  }
  document.addEventListener('keydown', onKey);
  document.addEventListener('keyup', onKey);

  function draw() {
    const now = performance.now();
    const dt = Math.min((now - lastTime) / 1000, 0.05);
    lastTime = now;
    timeLeft -= dt;
    spawnTimer += dt;
    if (spawnTimer >= spawnInterval) {
      spawnTimer = 0;
      spawnInterval = Math.max(0.6, spawnInterval - 0.015);
      spawnItem();
    }

    // Move cart
    const speed = 350;
    if (keys.left) cart.x -= speed * dt;
    if (keys.right) cart.x += speed * dt;
    cart.x = Math.max(cart.w / 2, Math.min(W - cart.w / 2, cart.x));

    // Update items
    for (let i = items.length - 1; i >= 0; i--) {
      const item = items[i];
      item.y += item.speed * dt;
      // Check catch
      if (item.y + item.type.h / 2 >= H - 50 && item.y - item.type.h / 2 <= H - 20) {
        if (Math.abs(item.x - cart.x) < (cart.w / 2 + item.type.w / 2)) {
          if (item.type.isBomb) {
            score = Math.max(0, score - 3);
            screenFlash = 0.3;
            SFX.jobWrong();
          } else {
            score += 5;
            SFX.jobCorrect();
            for (let p = 0; p < 5; p++) {
              particles.push({ x: item.x, y: H - 40, vx: (Math.random() - 0.5) * 100, vy: -Math.random() * 80, t: 0.5, color: item.type.color });
            }
          }
          items.splice(i, 1);
          continue;
        }
      }
      // Miss — fell off screen
      if (item.y > H + 20) {
        if (!item.type.isBomb) {
          score = Math.max(0, score - 1);
        }
        items.splice(i, 1);
      }
    }
    // Update particles
    for (let i = particles.length - 1; i >= 0; i--) {
      const p = particles[i];
      p.x += p.vx * dt; p.y += p.vy * dt; p.vy += 200 * dt; p.t -= dt;
      if (p.t <= 0) particles.splice(i, 1);
    }
    if (screenFlash > 0) screenFlash -= dt;

    // Draw
    ctx.fillStyle = '#d4e8f0';
    ctx.fillRect(0, 0, W, H);
    // Shelves decoration
    ctx.fillStyle = '#8b6e4e';
    for (let sy = 60; sy < H - 80; sy += 80) {
      ctx.fillRect(10, sy, 40, 6);
      ctx.fillRect(W - 50, sy, 40, 6);
    }
    // Floor
    ctx.fillStyle = '#bba882';
    ctx.fillRect(0, H - 15, W, 15);

    // Items
    items.forEach(item => {
      ctx.fillStyle = item.type.color;
      ctx.fillRect(item.x - item.type.w / 2, item.y - item.type.h / 2, item.type.w, item.type.h);
      if (item.type.isBomb) {
        ctx.fillStyle = '#ff4444';
        ctx.font = 'bold 14px monospace';
        ctx.textAlign = 'center';
        ctx.fillText('!', item.x, item.y + 5);
      }
    });

    // Cart
    ctx.fillStyle = '#555';
    ctx.fillRect(cart.x - cart.w / 2, H - 50, cart.w, 30);
    ctx.fillStyle = '#888';
    ctx.fillRect(cart.x - cart.w / 2 + 4, H - 48, cart.w - 8, 4);
    // Wheels
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.arc(cart.x - cart.w / 3, H - 18, 6, 0, Math.PI * 2); ctx.fill();
    ctx.beginPath(); ctx.arc(cart.x + cart.w / 3, H - 18, 6, 0, Math.PI * 2); ctx.fill();

    // Particles
    particles.forEach(p => {
      ctx.fillStyle = p.color;
      ctx.globalAlpha = p.t / 0.5;
      ctx.fillRect(p.x - 3, p.y - 3, 6, 6);
      ctx.globalAlpha = 1;
    });

    // Screen flash (bomb)
    if (screenFlash > 0) {
      ctx.fillStyle = 'rgba(255,50,50,' + (screenFlash / 0.3 * 0.3) + ')';
      ctx.fillRect(0, 0, W, H);
    }

    // HUD
    ctx.fillStyle = '#333';
    ctx.font = 'bold 16px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('Score: ' + score, 10, 22);
    ctx.textAlign = 'right';
    ctx.fillText('$' + (15 + Math.floor(Math.max(0, score) * 0.5)), W - 10, 22);
    ctx.textAlign = 'center';
    ctx.fillText(Math.ceil(Math.max(0, timeLeft)) + 's', W / 2, 22);

    if (timeLeft <= 0) {
      running = false;
      document.removeEventListener('keydown', onKey);
      document.removeEventListener('keyup', onKey);
      onFinish(score);
      return;
    }
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
}

// --- Town Hall: Stamp Sorter ---
function runTownHallJob(canvas, ctx, onFinish) {
  const W = canvas.width, H = canvas.height;
  const RULES = [
    { text: 'APPROVE blue, DENY red',     approve: '#4488cc', deny: '#cc4444', aName: 'blue', dName: 'red' },
    { text: 'APPROVE green, DENY yellow',  approve: '#44aa66', deny: '#ccaa44', aName: 'green', dName: 'yellow' },
    { text: 'APPROVE red, DENY blue',      approve: '#cc4444', deny: '#4488cc', aName: 'red', dName: 'blue' },
    { text: 'APPROVE yellow, DENY green',  approve: '#ccaa44', deny: '#44aa66', aName: 'yellow', dName: 'green' },
    { text: 'DENY blue, APPROVE red',      approve: '#cc4444', deny: '#4488cc', aName: 'red', dName: 'blue' },
    { text: 'APPROVE green, DENY red',     approve: '#44aa66', deny: '#cc4444', aName: 'green', dName: 'red' },
  ];
  let currentRule = RULES[0];
  let doc = null;
  let score = 0;
  let timeLeft = 30;
  let lastTime = performance.now();
  let docTimer = 0;
  let docsThisRule = 0;
  let ruleChangeAt = 8 + Math.floor(Math.random() * 4);
  let stamp = null;
  let newRuleFlash = 0;
  let running = true;
  let docCount = 0;

  function pickRule() {
    let next;
    do { next = RULES[Math.floor(Math.random() * RULES.length)]; } while (next === currentRule);
    currentRule = next;
    docsThisRule = 0;
    ruleChangeAt = 8 + Math.floor(Math.random() * 4);
    newRuleFlash = 1.0;
  }

  function spawnDoc() {
    const isApprove = Math.random() < 0.5;
    doc = { color: isApprove ? currentRule.approve : currentRule.deny, shouldApprove: isApprove, timer: 5 };
    docTimer = 0;
    docCount++;
  }
  spawnDoc();

  function onKey(e) {
    if (!running || !doc) return;
    const k = e.key.toLowerCase();
    if (k !== 'a' && k !== 'd') return;
    e.preventDefault();
    const approved = (k === 'a');
    const correct = (approved === doc.shouldApprove);
    if (correct) {
      score += 10;
      stamp = { text: approved ? 'APPROVED' : 'DENIED', color: approved ? '#44aa44' : '#cc4444', t: 0.6 };
      SFX.jobCorrect();
    } else {
      score = Math.max(0, score - 2);
      stamp = { text: 'WRONG!', color: '#ff4444', t: 0.6 };
      SFX.jobWrong();
    }
    docsThisRule++;
    if (docsThisRule >= ruleChangeAt) pickRule();
    doc = null;
    setTimeout(() => { if (running) spawnDoc(); }, 500);
  }
  document.addEventListener('keydown', onKey);

  function draw() {
    const now = performance.now();
    const dt = Math.min((now - lastTime) / 1000, 0.05);
    lastTime = now;
    timeLeft -= dt;
    if (newRuleFlash > 0) newRuleFlash -= dt;

    // Doc timeout
    if (doc) {
      doc.timer -= dt;
      if (doc.timer <= 0) {
        score = Math.max(0, score - 1);
        stamp = { text: 'TOO SLOW', color: '#ff8844', t: 0.6 };
        docsThisRule++;
        if (docsThisRule >= ruleChangeAt) pickRule();
        doc = null;
        setTimeout(() => { if (running) spawnDoc(); }, 500);
      }
    }
    if (stamp) { stamp.t -= dt; if (stamp.t <= 0) stamp = null; }

    // Draw
    ctx.fillStyle = '#e8dcc8';
    ctx.fillRect(0, 0, W, H);
    // Desk
    ctx.fillStyle = '#8b6e4e';
    ctx.fillRect(0, H - 60, W, 60);
    ctx.fillStyle = '#a08060';
    ctx.fillRect(0, H - 62, W, 4);

    // Rule display
    ctx.fillStyle = newRuleFlash > 0.5 ? '#cc4444' : '#333';
    ctx.font = 'bold 18px monospace';
    ctx.textAlign = 'center';
    ctx.fillText(newRuleFlash > 0.5 ? 'NEW RULE!' : currentRule.text, W / 2, 30);

    // Document
    if (doc) {
      const dx = W / 2 - 80, dy = 60, dw = 160, dh = 200;
      // Paper
      ctx.fillStyle = '#fffff0';
      ctx.fillRect(dx, dy, dw, dh);
      ctx.strokeStyle = '#999';
      ctx.lineWidth = 1;
      ctx.strokeRect(dx, dy, dw, dh);
      // Color header
      ctx.fillStyle = doc.color;
      ctx.fillRect(dx, dy, dw, 40);
      // Lines
      ctx.fillStyle = '#ccc';
      for (let ly = dy + 60; ly < dy + dh - 20; ly += 18) {
        ctx.fillRect(dx + 15, ly, dw - 30, 2);
      }
      // Timer bar
      const pct = Math.max(0, doc.timer / 5);
      ctx.fillStyle = '#ddd';
      ctx.fillRect(dx, dy + dh + 8, dw, 8);
      ctx.fillStyle = pct > 0.3 ? '#44aa44' : '#cc4444';
      ctx.fillRect(dx, dy + dh + 8, dw * pct, 8);
    }

    // Stamp overlay
    if (stamp) {
      ctx.save();
      ctx.translate(W / 2, 170);
      ctx.rotate(-0.2);
      ctx.globalAlpha = Math.min(1, stamp.t / 0.3);
      ctx.font = 'bold 36px monospace';
      ctx.fillStyle = stamp.color;
      ctx.textAlign = 'center';
      ctx.fillText(stamp.text, 0, 0);
      ctx.restore();
      ctx.globalAlpha = 1;
    }

    // HUD
    ctx.fillStyle = '#333';
    ctx.font = 'bold 16px monospace';
    ctx.textAlign = 'left';
    ctx.fillText('Score: ' + score, 10, 22);
    ctx.textAlign = 'right';
    ctx.fillText('$' + (15 + Math.floor(Math.max(0, score) * 0.5)), W - 10, 22);
    ctx.textAlign = 'center';
    ctx.fillText(Math.ceil(Math.max(0, timeLeft)) + 's', W / 2, H - 30);

    if (timeLeft <= 0) {
      running = false;
      document.removeEventListener('keydown', onKey);
      onFinish(score);
      return;
    }
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
}

function purchaseFurniture(id) {
  const item = SHOP_FURNITURE.find(f => f.id === id);
  if (!item || ownedFurniture.has(id) || money < item.cost) return;
  money -= item.cost;
  ownedFurniture.add(id);
  SFX.kaChing();
  const builders = { lavaLamp: buildLavaLamp, fishTank: buildFishTank, treadmill: buildTreadmill, jukebox: buildJukebox };
  builders[id]();
  rebuildInteractMeshes();
  showTip(item.name + ' placed!');
  mlTry('ml_shopaholic');
  if (ownedFurniture.size >= 4) mlTry('ml_interior_designer');
  mlCheckLivingLarge();
}

// ═══ CHARACTER BUILDER ═══
const SKIN_TONES = [
  { name: 'Light',       hex: 0xfce4c7 },
  { name: 'Fair',        hex: 0xf4c794 },
  { name: 'Medium',      hex: 0xd4a06a },
  { name: 'Olive',       hex: 0xb07840 },
  { name: 'Brown',       hex: 0x8b5e3c },
  { name: 'Dark',        hex: 0x5a3825 },
];
const HAIR_COLORS = [
  { name: 'Black',   hex: 0x1a1a1a },
  { name: 'Brown',   hex: 0x4a3222 },
  { name: 'Blonde',  hex: 0xd4a843 },
  { name: 'Red',     hex: 0x8b2a1a },
  { name: 'White',   hex: 0xdddddd },
  { name: 'Blue',    hex: 0x3366cc },
];

const OUTFITS = [
  { name: 'Casual Blue',    shirt: 0x4488cc, pants: 0x334466, cost: 0 },
  { name: 'Sporty Red',     shirt: 0xcc3333, pants: 0x222222, cost: 20 },
  { name: 'Forest Green',   shirt: 0x338844, pants: 0x3a3a2a, cost: 25 },
  { name: 'Purple Royale',  shirt: 0x7744aa, pants: 0x2a2244, cost: 30 },
  { name: 'Sunset Orange',  shirt: 0xdd7722, pants: 0x443322, cost: 30 },
  { name: 'All Black',      shirt: 0x222222, pants: 0x1a1a1a, cost: 35 },
  { name: 'Pink Pop',       shirt: 0xdd55aa, pants: 0xeeeedd, cost: 35 },
  { name: 'Golden Drip',    shirt: 0xccaa33, pants: 0x1a1a1a, cost: 50 },
];
let ownedOutfits = new Set([0]); // index 0 (Casual Blue) is free

let charOpts = { skinTone: 1, gender: 'male', hairStyle: 'short', hairColor: 1, outfit: 0 };

function buildCharacter(opts) {
  const group = new THREE.Group();
  const skinMat = new THREE.MeshLambertMaterial({ color: SKIN_TONES[opts.skinTone].hex });
  const hairMat = new THREE.MeshLambertMaterial({ color: HAIR_COLORS[opts.hairColor].hex });
  const fit = OUTFITS[opts.outfit] || OUTFITS[0];
  const shirtMat = new THREE.MeshLambertMaterial({ color: fit.shirt });
  const pantsMat = new THREE.MeshLambertMaterial({ color: fit.pants });
  const eyeMat = new THREE.MeshBasicMaterial({ color: 0x222222 });

  const isFemale = opts.gender === 'female';
  const bodyW = isFemale ? 0.45 : 0.5;
  const hipW = isFemale ? 0.28 : 0.25;
  const armX = isFemale ? 0.32 : 0.35;

  // Legs
  const legL = new THREE.Mesh(new THREE.BoxGeometry(hipW, 0.5, 0.25), pantsMat);
  legL.position.set(-0.15, 0.25, 0);
  legL.castShadow = true;
  group.add(legL);
  const legR = new THREE.Mesh(new THREE.BoxGeometry(hipW, 0.5, 0.25), pantsMat);
  legR.position.set(0.15, 0.25, 0);
  legR.castShadow = true;
  group.add(legR);

  // Body
  const torso = new THREE.Mesh(new THREE.BoxGeometry(bodyW, 0.6, 0.3), shirtMat);
  torso.position.set(0, 0.8, 0);
  torso.castShadow = true;
  group.add(torso);

  // Arms
  const armL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.15), shirtMat);
  armL.position.set(-armX, 0.75, 0);
  armL.castShadow = true;
  group.add(armL);
  const armR = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.5, 0.15), shirtMat);
  armR.position.set(armX, 0.75, 0);
  armR.castShadow = true;
  group.add(armR);

  // Head
  const headMesh = new THREE.Mesh(new THREE.SphereGeometry(0.22, 12, 10), skinMat);
  headMesh.position.set(0, 1.32, 0);
  headMesh.castShadow = true;
  group.add(headMesh);

  // Hair
  if (opts.hairStyle === 'short') {
    const h = new THREE.Mesh(new THREE.SphereGeometry(0.24, 12, 10, 0, Math.PI * 2, 0, Math.PI / 2), hairMat);
    h.position.set(0, 1.35, 0);
    group.add(h);
  } else if (opts.hairStyle === 'long') {
    const top = new THREE.Mesh(new THREE.SphereGeometry(0.24, 12, 10, 0, Math.PI * 2, 0, Math.PI / 2), hairMat);
    top.position.set(0, 1.35, 0);
    group.add(top);
    const back = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.55, 0.2), hairMat);
    back.position.set(0, 1.1, -0.15);
    group.add(back);
  } else if (opts.hairStyle === 'curly') {
    const positions = [
      [0, 1.55, 0], [-0.12, 1.52, 0.05], [0.12, 1.52, 0.05],
      [-0.08, 1.52, -0.1], [0.08, 1.52, -0.1], [0, 1.52, 0.12],
      [-0.15, 1.45, 0], [0.15, 1.45, 0], [0, 1.45, -0.15],
    ];
    positions.forEach(p => {
      const curl = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 6), hairMat);
      curl.position.set(p[0], p[1], p[2]);
      group.add(curl);
    });
  } else if (opts.hairStyle === 'buzz') {
    const h = new THREE.Mesh(new THREE.SphereGeometry(0.23, 12, 10, 0, Math.PI * 2, 0, Math.PI / 2.5), hairMat);
    h.position.set(0, 1.35, 0);
    group.add(h);
  }

  // Eyes
  const eyeL = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), eyeMat);
  eyeL.position.set(-0.08, 1.35, 0.2);
  group.add(eyeL);
  const eyeR = new THREE.Mesh(new THREE.SphereGeometry(0.04, 8, 8), eyeMat);
  eyeR.position.set(0.08, 1.35, 0.2);
  group.add(eyeR);

  return group;
}

// Game character (placed in main scene)
let character = buildCharacter(charOpts);
character.position.set(0, 0.15, 0);
character.visible = false;
scene.add(character);

// ═══ CHARACTER CREATOR ═══
// Preview scene
const prevScene = new THREE.Scene();
prevScene.background = new THREE.Color(0x222233);
const prevCamera = new THREE.PerspectiveCamera(40, 200 / 300, 0.1, 20);
prevCamera.position.set(0, 1.1, 3);
prevCamera.lookAt(0, 0.8, 0);
const prevRenderer = new THREE.WebGLRenderer({ canvas: document.getElementById('preview-canvas'), antialias: true });
prevRenderer.setSize(200, 300);

const prevAmb = new THREE.AmbientLight(0x888899, 0.6);
prevScene.add(prevAmb);
const prevDir = new THREE.DirectionalLight(0xffeedd, 0.9);
prevDir.position.set(3, 5, 4);
prevScene.add(prevDir);

let previewChar = buildCharacter(charOpts);
prevScene.add(previewChar);
let previewAngle = 0;

function updatePreview() {
  prevScene.remove(previewChar);
  previewChar = buildCharacter(charOpts);
  prevScene.add(previewChar);
}

// Populate skin tone swatches
const skinContainer = document.getElementById('skin-options');
SKIN_TONES.forEach((tone, i) => {
  const s = document.createElement('div');
  s.className = 'swatch' + (i === charOpts.skinTone ? ' selected' : '');
  s.style.background = '#' + tone.hex.toString(16).padStart(6, '0');
  s.title = tone.name;
  s.onclick = () => {
    charOpts.skinTone = i;
    skinContainer.querySelectorAll('.swatch').forEach(el => el.classList.remove('selected'));
    s.classList.add('selected');
    updatePreview();
  };
  skinContainer.appendChild(s);
});

// Populate hair color swatches
const hairColorContainer = document.getElementById('hair-color-options');
HAIR_COLORS.forEach((col, i) => {
  const s = document.createElement('div');
  s.className = 'swatch' + (i === charOpts.hairColor ? ' selected' : '');
  s.style.background = '#' + col.hex.toString(16).padStart(6, '0');
  s.title = col.name;
  s.onclick = () => {
    charOpts.hairColor = i;
    hairColorContainer.querySelectorAll('.swatch').forEach(el => el.classList.remove('selected'));
    s.classList.add('selected');
    updatePreview();
  };
  hairColorContainer.appendChild(s);
});

function setGender(val, btn) {
  charOpts.gender = val;
  document.querySelectorAll('#gender-options .toggle-btn').forEach(b => b.classList.remove('selected'));
  btn.classList.add('selected');
  updatePreview();
}

function setHairStyle(val, btn) {
  charOpts.hairStyle = val;
  document.querySelectorAll('#hair-style-options .toggle-btn').forEach(b => b.classList.remove('selected'));
  btn.classList.add('selected');
  updatePreview();
}

let gameStarted = false;

function startGame() {
  SFX.init();
  SFX.startMusic();
  // Rebuild the game character with chosen options
  scene.remove(character);
  character = buildCharacter(charOpts);
  character.position.set(0, 0.15, 0);
  character.visible = false;
  scene.add(character);

  document.getElementById('creator-screen').classList.add('hidden');
  gameStarted = true;
  lastTime = performance.now();
  mlTry('ml_new_home');
  mlLoadGBuxContent();
}

// ═══ GAME STATE ═══
const needs = { hunger: 100, energy: 100, fun: 100, hygiene: 100 };
const decayRates = { hunger: 1.8, energy: 1.2, fun: 2.0, hygiene: 1.5 }; // per game-minute
let money = 50;
let gameTime = 360; // minutes from midnight (6 AM)
let day = 1;
let booksRead = 0;
let treadmillUses = 0;
let gameOver = false;
let moveTarget = null;
let currentAction = null;
let actionProgress = 0;
let actionDuration = 0;
let hoveredObj = null;
let shopOpen = false;

// Expansion state
let hasSecondFloor = false;
let currentFloor = 0;
let secondFloorGroup = null;
const GROUND_Y = 0.15;
const UPPER_Y = 3.65;
const STAIR = { xMin: -5, xMax: -3.5, zMin: -4.5, zMax: -0.5 };

const GAME_SPEED = 0.2; // game-minutes per real second

// ═══ FIRST-PERSON CONTROLS ═══
let yaw = Math.PI;    // looking along -Z initially
let pitch = 0;
let pointerLocked = false;
const keys = {};
const MOVE_SPEED = 3.5;
const MOUSE_SENS = 0.002;
const EYE_HEIGHT = 1.5;

// Pointer lock
renderer.domElement.addEventListener('click', (e) => {
  SFX.init();
  if (!pointerLocked && !gameOver && gameStarted && !npcDialogueOpen && !shopOpen && !petMenuOpen && !jobMiniGameRunning) {
    renderer.domElement.requestPointerLock();
  }
});

document.addEventListener('pointerlockchange', () => {
  pointerLocked = document.pointerLockElement === renderer.domElement;
});

document.addEventListener('mousemove', (e) => {
  if (!pointerLocked) return;
  yaw -= e.movementX * MOUSE_SENS;
  pitch -= e.movementY * MOUSE_SENS;
  pitch = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, pitch));
});

document.addEventListener('keydown', (e) => {
  keys[e.code] = true;
  if (e.code === 'KeyP' && gameStarted && !gameOver && !currentAction) toggleShop();
  if (e.code === 'KeyT' && gameStarted && !gameOver && !currentAction) togglePetMenu();
  if (mirrorOpen) { closeMirror(); return; }
});
document.addEventListener('keyup', (e) => { keys[e.code] = false; });

// ═══ RAYCASTING ═══
const raycaster = new THREE.Raycaster();
let interactMeshes = interactables.map(i => i.mesh);
function rebuildInteractMeshes() { interactMeshes = interactables.map(i => i.mesh); }

// Raycast from center of screen (crosshair) each frame
function updateCrosshairRaycast() {
  if (gameOver) return;
  // Cast from camera center
  raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);

  const allTargets = interactMeshes.concat(petBodyMeshes).concat(inTown ? npcBodyMeshes : []);
  const hits = raycaster.intersectObjects(allTargets, true);
  const tip = document.getElementById('action-tip');
  const crosshair = document.getElementById('crosshair');

  if (hits.length > 0 && hits[0].distance < 4) {
    // Check if it's a pet
    if (petBodyMeshes.includes(hits[0].object)) {
      hoveredObj = { type: 'petMenu' };
      tip.textContent = 'Click: Pet Menu';
      tip.classList.add('visible');
      crosshair.classList.add('active');
      return;
    }
    // Check if it's an NPC
    const hitObj = hits[0].object;
    if (hitObj.userData && hitObj.userData.type === 'npc') {
      const npcDef = TOWN_NPC_DEFS.find(d => d.id === hitObj.userData.npcId);
      hoveredObj = { type: 'npc', npcId: hitObj.userData.npcId };
      tip.textContent = 'Click: Talk to ' + (npcDef ? npcDef.name : 'NPC');
      tip.classList.add('visible');
      crosshair.classList.add('active');
      return;
    }
    const obj = interactables.find(i => i.mesh === hits[0].object);
    if (obj) {
      hoveredObj = obj;
      tip.textContent = 'Click: ' + obj.label;
      tip.classList.add('visible');
      crosshair.classList.add('active');
      return;
    }
  }
  hoveredObj = null;
  tip.classList.remove('visible');
  crosshair.classList.remove('active');
}

// Click to interact with looked-at object
renderer.domElement.addEventListener('mousedown', (e) => {
  if (!pointerLocked || gameOver || currentAction) return;
  if (e.button === 0 && hoveredObj) {
    if (hoveredObj.type === 'petMenu') {
      togglePetMenu();
    } else if (hoveredObj.type === 'npc') {
      openNPCDialogue(hoveredObj.npcId);
    } else {
      startAction(hoveredObj);
    }
  }
});

// ═══ ACTIONS ═══
const actionConfig = {
  fridge:   { label: 'Eating...', duration: 3, restore: 40, cost: 5 },
  bed:      { label: 'Sleeping...', duration: 6, restore: 60, cost: 0 },
  tv:       { label: 'Watching TV...', duration: 4, restore: 45, cost: 0 },
  shower:   { label: 'Showering...', duration: 3.5, restore: 50, cost: 2 },
  computer: { label: 'Gaming...', duration: 10, restore: 0, cost: 0, earn: 10, funDrain: 10 },
};

let miniGameScore = 0;
let miniGameRunning = false;
let miniGameKeys = {};

function openDriveDestMenu() {
  if (npcDialogueOpen || currentAction || driveDestOpen || jobMiniGameRunning) return;
  driveDestOpen = true;
  if (document.pointerLockElement) document.exitPointerLock();
  document.getElementById('drive-dest-overlay').classList.add('visible');
  document.getElementById('drive-mansion-btn').style.display = hasMansion ? '' : 'none';
}
function chooseDriveDest(dest) {
  closeDriveDestMenu();
  startDrivingTransition(dest);
}
function closeDriveDestMenu() {
  driveDestOpen = false;
  document.getElementById('drive-dest-overlay').classList.remove('visible');
}

function startAction(obj) {
  // Car — destination chooser or direct drive
  if (obj.type === 'car') {
    if (hasMansion) { openDriveDestMenu(); } else { startDrivingTransition('town'); }
    return;
  }
  if (obj.type === 'townCar') {
    startDrivingTransition('home');
    return;
  }
  if (obj.type === 'mansionCar') {
    startDrivingTransition('home');
    return;
  }

  const config = actionConfig[obj.type];
  if (obj.floor !== undefined && obj.floor !== currentFloor) {
    if (obj.floor > currentFloor) showTip("Go upstairs first!");
    else showTip("Go downstairs first!");
    return;
  }
  if (obj.type === 'fridge' && money < config.cost) {
    showTip("Not enough money!");
    return;
  }

  // Mirror is instant — no walk, no progress bar
  if (obj.type === 'mirror') {
    openMirror();
    return;
  }

  // Jukebox is instant — cycles tracks
  if (obj.type === 'jukebox') {
    const trackName = SFX.switchTrack();
    needs.fun = Math.min(100, needs.fun + 15);
    showTip('Now playing: ' + trackName);
    updateJukeboxLabel();
    return;
  }

  // Grand Piano is instant — fun boost
  if (obj.type === 'grandPiano') {
    needs.fun = Math.min(100, needs.fun + 50);
    SFX.actionComplete();
    showTip('Beautiful melody!');
    return;
  }

  // Door is instant toggle — open/close
  if (obj.type === 'door') {
    if (doorAnimating) return;
    doorOpen = !doorOpen;
    doorAnimating = true;
    const doorInteract = interactables.find(i => i.type === 'door');
    if (doorInteract) doorInteract.label = doorOpen ? 'Close Door' : 'Open Door';
    SFX.doorCreak();
    return;
  }

  // Walk to use position first, then do action
  moveTarget = obj.usePos.clone();
  currentAction = { obj, config, phase: 'walking' };
}

function beginAction(action) {
  const { config } = action;
  if (action.obj.type === 'fridge') money -= config.cost;
  action.phase = 'doing';
  actionProgress = 0;
  actionDuration = config.duration;

  const barWrap = document.getElementById('action-bar-wrap');
  const barLabel = document.getElementById('action-bar-label');
  barLabel.textContent = config.label;
  barWrap.classList.add('visible');

  // Start animation overlay
  startActionAnim(action.obj.type, config.duration);

  // Start looping sounds
  if (action.obj.type === 'shower' || action.obj.type === 'mansionSpa' || action.obj.type === 'hotTub') SFX.startShower();
  else if (action.obj.type === 'bed' || action.obj.type === 'bed2' || action.obj.type === 'kingBed') SFX.startSleep();
}

function finishAction(action) {
  const { obj, config } = action;
  if (obj.type === 'computer') {
    const bonus = miniGameScore || 0;
    money += config.earn + bonus;
    needs.fun = Math.max(0, needs.fun - config.funDrain);
    if (miniGameScore >= 25) mlTry('ml_arcade_pro');
    miniGameScore = 0;
    SFX.kaChing();
    if (Math.floor(money) >= 500) mlTry('ml_high_roller');
  } else if (obj.type === 'workbench') {
    money += config.earn;
    SFX.kaChing();
    if (Math.floor(money) >= 500) mlTry('ml_high_roller');
    // Quest hook: supply run
    if (questLog.supply_run && questLog.supply_run.status === 'active') questLog.supply_run.workbenchUsed = true;
  } else if (obj.type === 'artEasel') {
    needs.fun = Math.min(100, needs.fun + config.restore);
    money += config.earn;
    SFX.kaChing();
    if (Math.floor(money) >= 500) mlTry('ml_high_roller');
  } else {
    needs[obj.need] = Math.min(100, needs[obj.need] + config.restore);
    if (config.hungerDrain) needs.hunger = Math.max(0, needs.hunger - config.hungerDrain);
    if (config.hygieneBonus) needs.hygiene = Math.min(100, needs.hygiene + config.hygieneBonus);
    if (config.funBonus) needs.fun = Math.min(100, needs.fun + config.funBonus);
    if (config.energyBonus) needs.energy = Math.min(100, needs.energy + config.energyBonus);
    if (obj.type === 'bookshelf' || obj.type === 'mansionLibrary') { booksRead++; if (booksRead >= 3) mlTry('ml_bookworm'); }
    if (obj.type === 'treadmill') { treadmillUses++; if (treadmillUses >= 3) mlTry('ml_gym_rat'); }
    // Quest hook: coffee run (fridge)
    if (obj.type === 'fridge' && questLog.coffee_run && questLog.coffee_run.status === 'active') questLog.coffee_run.fridgeUsed = true;
  }
  SFX.stopLoops();
  SFX.actionComplete();
  currentAction = null;
  actionProgress = 0;
  document.getElementById('action-bar-wrap').classList.remove('visible');
  document.getElementById('action-bar-fill').style.width = '0%';

  // Stop animation overlay
  stopActionAnim(obj.type);
}

function showTip(text) {
  const tip = document.getElementById('action-tip');
  tip.textContent = text;
  tip.classList.add('visible');
  setTimeout(() => tip.classList.remove('visible'), 1500);
}

// ═══ ACTION ANIMATIONS ═══
let animIntervals = [];

function startActionAnim(type, duration) {
  clearAnimIntervals();

  if (type === 'bed') {
    const overlay = document.getElementById('sleep-overlay');
    overlay.classList.add('visible');
    // Spawn floating Zzz repeatedly
    function spawnZzz() {
      const z = document.createElement('div');
      z.className = 'zzz';
      z.textContent = 'Z';
      z.style.left = (35 + Math.random() * 30) + '%';
      z.style.top = (40 + Math.random() * 20) + '%';
      z.style.fontSize = (1.5 + Math.random() * 2) + 'rem';
      z.style.animationDelay = '0s';
      z.style.animationDuration = (2 + Math.random()) + 's';
      overlay.appendChild(z);
      setTimeout(() => z.remove(), 3500);
    }
    spawnZzz();
    animIntervals.push(setInterval(spawnZzz, 700));

  } else if (type === 'shower') {
    const overlay = document.getElementById('shower-overlay');
    overlay.classList.add('visible');
    // Spawn water droplets
    function spawnDroplets() {
      for (let i = 0; i < 8; i++) {
        const d = document.createElement('div');
        d.className = 'droplet';
        d.style.left = (10 + Math.random() * 80) + '%';
        d.style.top = '-10px';
        d.style.height = (15 + Math.random() * 25) + 'px';
        d.style.animationDuration = (0.5 + Math.random() * 0.6) + 's';
        d.style.animationDelay = (Math.random() * 0.3) + 's';
        overlay.appendChild(d);
        setTimeout(() => d.remove(), 1500);
      }
    }
    // Spawn steam puffs
    function spawnSteam() {
      const s = document.createElement('div');
      s.className = 'steam-puff';
      s.style.left = (20 + Math.random() * 60) + '%';
      s.style.bottom = (5 + Math.random() * 15) + '%';
      s.style.animationDuration = (2 + Math.random() * 2) + 's';
      overlay.appendChild(s);
      setTimeout(() => s.remove(), 4500);
    }
    spawnDroplets();
    spawnSteam();
    animIntervals.push(setInterval(spawnDroplets, 400));
    animIntervals.push(setInterval(spawnSteam, 1200));

  } else if (type === 'fridge') {
    const overlay = document.getElementById('eat-overlay');
    overlay.classList.add('visible');
    // Hand rises up with food
    const hand = document.createElement('div');
    hand.className = 'eat-hand';
    hand.id = 'eat-hand-el';
    hand.textContent = '\u{1F354}'; // burger emoji
    overlay.appendChild(hand);
    setTimeout(() => hand.classList.add('up'), 50);
    // Spawn crumbs while eating
    function spawnCrumbs() {
      SFX.eat();
      const colors = ['#c8a060', '#e8c878', '#a07840', '#ddb870'];
      for (let i = 0; i < 3; i++) {
        const c = document.createElement('div');
        c.className = 'eat-crumb';
        c.style.left = (55 + Math.random() * 25) + '%';
        c.style.top = (30 + Math.random() * 20) + '%';
        c.style.background = colors[Math.floor(Math.random() * colors.length)];
        c.style.setProperty('--cx', (Math.random() * 60 - 30) + 'px');
        c.style.width = (4 + Math.random() * 5) + 'px';
        c.style.height = c.style.width;
        overlay.appendChild(c);
        setTimeout(() => c.remove(), 900);
      }
    }
    animIntervals.push(setInterval(spawnCrumbs, 500));
    setTimeout(spawnCrumbs, 600);

    // Hand bobs up/down for eating motion
    let eatBob = true;
    animIntervals.push(setInterval(() => {
      eatBob = !eatBob;
      hand.style.bottom = eatBob ? '13%' : '10%';
    }, 400));

  } else if (type === 'tv') {
    const overlay = document.getElementById('tv-overlay');
    overlay.classList.add('visible');

    // Build TV screen
    const box = document.createElement('div');
    box.className = 'tv-screen-box';
    box.id = 'tv-screen-box';
    overlay.appendChild(box);

    // Scanline
    const scan = document.createElement('div');
    scan.className = 'tv-scanline';
    box.appendChild(scan);

    // Static flash element
    const staticEl = document.createElement('div');
    staticEl.className = 'tv-static';
    staticEl.id = 'tv-static';
    box.appendChild(staticEl);

    // Channel label
    const chLabel = document.createElement('div');
    chLabel.className = 'tv-channel-label';
    chLabel.id = 'tv-ch-label';
    chLabel.textContent = 'CH 1';
    box.appendChild(chLabel);

    // Channel content
    const chContent = document.createElement('div');
    chContent.className = 'tv-channel';
    chContent.id = 'tv-ch-content';
    box.appendChild(chContent);

    const channels = [
      { emoji: '\u{1F3C8}', bg: '#1a4d1a', text: 'SPORTS' },
      { emoji: '\u{1F47B}', bg: '#1a1a33', text: 'HORROR' },
      { emoji: '\u{1F373}', bg: '#332211', text: 'COOKING' },
      { emoji: '\u{1F680}', bg: '#0a0a2a', text: 'SCI-FI' },
      { emoji: '\u{1F3B5}', bg: '#2a0a2a', text: 'MUSIC' },
      { emoji: '\u{1F431}', bg: '#2a2210', text: 'CUTE ANIMALS' },
      { emoji: '\u{1F4F0}', bg: '#1a1a1a', text: 'NEWS' },
      { emoji: '\u{1F92A}', bg: '#2a1a00', text: 'COMEDY' },
    ];
    let chIdx = Math.floor(Math.random() * channels.length);

    function showChannel() {
      const ch = channels[chIdx];
      chContent.innerHTML = '<div style="font-size:4rem;margin-bottom:8px;">' + ch.emoji + '</div>'
        + '<div style="font-size:1rem;color:#ffffffcc;font-family:monospace;letter-spacing:0.1em;">' + ch.text + '</div>';
      box.style.background = ch.bg;
      chLabel.textContent = 'CH ' + (chIdx + 1);
    }
    showChannel();

    // Channel flip with static flash
    function flipChannel() {
      SFX.tvStatic();
      staticEl.classList.add('flash');
      setTimeout(() => {
        chIdx = (chIdx + 1 + Math.floor(Math.random() * (channels.length - 1))) % channels.length;
        showChannel();
        setTimeout(() => staticEl.classList.remove('flash'), 150);
      }, 150);
    }
    animIntervals.push(setInterval(flipChannel, 1800));

  } else if (type === 'computer') {
    const overlay = document.getElementById('computer-overlay');
    overlay.classList.add('visible');

    const box = document.createElement('div');
    box.className = 'pc-screen-box';
    overlay.appendChild(box);

    const hint = document.createElement('div');
    hint.className = 'pc-hint';
    hint.innerHTML = '<kbd>SPACE</kbd> or <kbd>W</kbd> to jump';
    overlay.appendChild(hint);

    // Canvas game
    const W = 640, H = 360;
    const cvs = document.createElement('canvas');
    cvs.width = W; cvs.height = H;
    box.appendChild(cvs);
    const ctx = cvs.getContext('2d');

    // Game state
    const GROUND_Y = H * 0.72;
    const GRAVITY = 2800;
    const JUMP_VEL = -750;
    const BASE_SPEED = 280;
    let speed = BASE_SPEED;
    let py = GROUND_Y, pvy = 0, onGround = true;
    let obstacles = [], coins = [], particles = [];
    let score = 0, combo = 0, hitFlash = 0;
    let groundOffset = 0;
    let stars = [];
    miniGameScore = 0;
    miniGameRunning = true;
    SFX.mgStart();

    // Generate stars
    for (let i = 0; i < 40; i++) {
      stars.push({ x: Math.random() * W, y: Math.random() * GROUND_Y * 0.9, s: 1 + Math.random() * 2, b: Math.random() });
    }

    // Input
    function mgKeyDown(e) {
      if (!miniGameRunning) return;
      if (e.code === 'Space' || e.code === 'KeyW') {
        e.preventDefault();
        if (onGround) { pvy = JUMP_VEL; onGround = false; SFX.mgJump(); }
      }
    }
    function mgKeyUp(e) {
      if (e.code === 'Space' || e.code === 'KeyW') e.preventDefault();
    }
    document.addEventListener('keydown', mgKeyDown);
    document.addEventListener('keyup', mgKeyUp);
    // Store refs for cleanup
    overlay._mgKeyDown = mgKeyDown;
    overlay._mgKeyUp = mgKeyUp;

    // Spawn timers
    let obstacleTimer = 0, coinTimer = 0, speedTimer = 0;
    const PW = 28, PH = 38; // player size

    function mgUpdate(dt) {
      if (!miniGameRunning) return;
      speed = BASE_SPEED + score * 0.8; // speeds up as score grows
      groundOffset = (groundOffset + speed * dt) % 40;
      speedTimer += dt;

      // Player physics
      if (!onGround) {
        pvy += GRAVITY * dt;
        py += pvy * dt;
        if (py >= GROUND_Y) { py = GROUND_Y; pvy = 0; onGround = true; }
      }

      // Spawn obstacles
      obstacleTimer += dt;
      const obstacleInterval = Math.max(0.8, 1.8 - score * 0.008);
      if (obstacleTimer > obstacleInterval) {
        obstacleTimer = 0;
        const oh = 24 + Math.random() * 28;
        obstacles.push({ x: W + 20, w: 18 + Math.random() * 10, h: oh });
      }

      // Spawn coins
      coinTimer += dt;
      if (coinTimer > 0.9) {
        coinTimer = 0;
        const cy = GROUND_Y - 50 - Math.random() * 100;
        coins.push({ x: W + 10, y: cy, r: 8, alive: true, bob: Math.random() * Math.PI * 2 });
      }

      // Move obstacles
      for (let i = obstacles.length - 1; i >= 0; i--) {
        obstacles[i].x -= speed * dt;
        if (obstacles[i].x < -40) { obstacles.splice(i, 1); score++; combo++; miniGameScore = score; }
      }

      // Move coins
      for (let i = coins.length - 1; i >= 0; i--) {
        const c = coins[i];
        c.x -= speed * dt;
        c.bob += dt * 4;
        if (c.x < -20) { coins.splice(i, 1); continue; }
        // Collect check
        if (c.alive) {
          const px = 60, playerTop = py - PH;
          if (c.x > px - 10 && c.x < px + PW + 10 && c.y > playerTop - 10 && c.y < py + 10) {
            c.alive = false;
            score += 3;
            combo += 3;
            miniGameScore = score;
            SFX.mgCoin();
            for (let p = 0; p < 6; p++) {
              particles.push({ x: c.x, y: c.y, vx: (Math.random() - 0.5) * 200, vy: (Math.random() - 0.5) * 200, life: 0.6, color: '#ffdd44' });
            }
          }
        }
      }

      // Collision with obstacles
      const px = 60, playerTop = py - PH;
      for (let obs of obstacles) {
        const obsTop = GROUND_Y - obs.h;
        if (px + PW > obs.x + 4 && px < obs.x + obs.w - 4 && py > obsTop + 4 && playerTop < GROUND_Y) {
          // Hit!
          if (hitFlash <= 0) {
            hitFlash = 0.5;
            SFX.mgHit();
            score = Math.max(0, score - 5);
            combo = 0;
            miniGameScore = score;
            for (let p = 0; p < 8; p++) {
              particles.push({ x: px + PW / 2, y: py - PH / 2, vx: (Math.random() - 0.5) * 300, vy: (Math.random() - 0.5) * 300, life: 0.5, color: '#ff4444' });
            }
          }
        }
      }
      if (hitFlash > 0) hitFlash -= dt;

      // Particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= dt;
        if (p.life <= 0) particles.splice(i, 1);
      }
    }

    function mgDraw() {
      // Sky gradient
      const skyGrad = ctx.createLinearGradient(0, 0, 0, GROUND_Y);
      skyGrad.addColorStop(0, '#060618');
      skyGrad.addColorStop(1, '#141430');
      ctx.fillStyle = skyGrad;
      ctx.fillRect(0, 0, W, GROUND_Y);

      // Stars
      for (const s of stars) {
        const a = 0.3 + 0.7 * (0.5 + 0.5 * Math.sin(performance.now() * 0.001 + s.b * 10));
        ctx.globalAlpha = a;
        ctx.fillStyle = '#fff';
        ctx.fillRect(Math.floor(s.x), Math.floor(s.y), Math.ceil(s.s), Math.ceil(s.s));
      }
      ctx.globalAlpha = 1;

      // Ground
      ctx.fillStyle = '#1a3a1a';
      ctx.fillRect(0, GROUND_Y, W, H - GROUND_Y);
      // Ground detail lines
      ctx.fillStyle = '#2a5a2a';
      for (let gx = -groundOffset; gx < W; gx += 40) {
        ctx.fillRect(gx, GROUND_Y, 20, 2);
        ctx.fillRect(gx + 10, GROUND_Y + 8, 15, 2);
      }

      // Obstacles
      for (const obs of obstacles) {
        // Shadow
        ctx.fillStyle = '#00000044';
        ctx.fillRect(obs.x + 2, GROUND_Y - 2, obs.w, 4);
        // Body
        ctx.fillStyle = hitFlash > 0 ? '#ff6666' : '#cc2222';
        ctx.fillRect(obs.x, GROUND_Y - obs.h, obs.w, obs.h);
        // Highlight
        ctx.fillStyle = '#ff444488';
        ctx.fillRect(obs.x + 2, GROUND_Y - obs.h + 2, obs.w - 4, 4);
        // Spikes on top
        ctx.fillStyle = '#ee3333';
        for (let sx = obs.x + 2; sx < obs.x + obs.w - 4; sx += 6) {
          ctx.beginPath();
          ctx.moveTo(sx, GROUND_Y - obs.h);
          ctx.lineTo(sx + 3, GROUND_Y - obs.h - 6);
          ctx.lineTo(sx + 6, GROUND_Y - obs.h);
          ctx.fill();
        }
      }

      // Coins
      for (const c of coins) {
        if (!c.alive) continue;
        const cy = c.y + Math.sin(c.bob) * 5;
        ctx.fillStyle = '#ffdd44';
        ctx.beginPath();
        ctx.arc(c.x, cy, c.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ccaa22';
        ctx.beginPath();
        ctx.arc(c.x, cy, c.r - 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#ffee88';
        ctx.fillRect(c.x - 2, cy - 3, 4, 4);
      }

      // Player
      const px = 60, playerTop = py - PH;
      if (hitFlash > 0 && Math.floor(hitFlash * 20) % 2) {
        ctx.globalAlpha = 0.4;
      }
      // Body
      ctx.fillStyle = '#3388dd';
      ctx.fillRect(px, playerTop, PW, PH);
      // Head
      ctx.fillStyle = '#44aaff';
      ctx.fillRect(px + 2, playerTop, PW - 4, 14);
      // Eyes
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(px + 6, playerTop + 4, 6, 5);
      ctx.fillRect(px + 16, playerTop + 4, 6, 5);
      ctx.fillStyle = '#222';
      ctx.fillRect(px + 9, playerTop + 5, 3, 3);
      ctx.fillRect(px + 19, playerTop + 5, 3, 3);
      // Legs (animate when on ground)
      const legOff = onGround ? Math.floor(performance.now() / 100) % 2 * 4 : 0;
      ctx.fillStyle = '#2266aa';
      ctx.fillRect(px + 4, py - 2, 8, 4 + legOff);
      ctx.fillRect(px + 16, py - 2, 8, 4 + (legOff ? 0 : 4));
      ctx.globalAlpha = 1;

      // Particles
      for (const p of particles) {
        ctx.globalAlpha = p.life * 2;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x - 3, p.y - 3, 6, 6);
      }
      ctx.globalAlpha = 1;

      // HUD
      ctx.fillStyle = '#00000088';
      ctx.fillRect(0, 0, W, 32);
      ctx.font = 'bold 16px monospace';
      ctx.fillStyle = '#44ff44';
      ctx.textAlign = 'left';
      ctx.fillText('SCORE: ' + score, 12, 22);
      ctx.fillStyle = '#ffdd44';
      ctx.textAlign = 'right';
      ctx.fillText('$' + (10 + score), W - 12, 22);
      // Combo
      if (combo >= 5) {
        ctx.fillStyle = '#ff88ff';
        ctx.textAlign = 'center';
        ctx.fillText('COMBO x' + combo + '!', W / 2, 22);
      }
    }

    let mgLastTime = performance.now();
    function mgLoop() {
      if (!miniGameRunning) return;
      const now = performance.now();
      const dt = Math.min((now - mgLastTime) / 1000, 0.05);
      mgLastTime = now;
      mgUpdate(dt);
      mgDraw();
      requestAnimationFrame(mgLoop);
    }
    mgLoop();

  } else if (type === 'bookshelf') {
    const overlay = document.getElementById('sleep-overlay');
    overlay.classList.add('visible');
    overlay.style.background = '#1a1a2eee';
    function spawnBook() {
      const emojis = ['\u{1F4D6}', '\u{1F4DA}', '\u{1F4D5}', '\u{1F4D8}'];
      const b = document.createElement('div');
      b.className = 'zzz';
      b.textContent = emojis[Math.floor(Math.random() * emojis.length)];
      b.style.left = (30 + Math.random() * 40) + '%';
      b.style.top = (35 + Math.random() * 25) + '%';
      b.style.fontSize = (1.5 + Math.random() * 1.5) + 'rem';
      overlay.appendChild(b);
      setTimeout(() => b.remove(), 3500);
    }
    spawnBook();
    animIntervals.push(setInterval(spawnBook, 800));

  } else if (type === 'bed2') {
    // Reuse sleep animation
    const overlay = document.getElementById('sleep-overlay');
    overlay.classList.add('visible');
    function spawnZzz2() {
      const z = document.createElement('div');
      z.className = 'zzz';
      z.textContent = 'Z';
      z.style.left = (35 + Math.random() * 30) + '%';
      z.style.top = (40 + Math.random() * 20) + '%';
      z.style.fontSize = (1.5 + Math.random() * 2) + 'rem';
      overlay.appendChild(z);
      setTimeout(() => z.remove(), 3500);
    }
    spawnZzz2();
    animIntervals.push(setInterval(spawnZzz2, 700));

  } else if (type === 'lavaLamp') {
    const overlay = document.getElementById('sleep-overlay');
    overlay.classList.add('visible');
    overlay.style.background = 'linear-gradient(180deg, #1a0a20ee, #330a1aee)';
    function spawnBlob() {
      const blob = document.createElement('div');
      blob.className = 'zzz';
      blob.textContent = '\u{1F7E3}';
      blob.style.left = (35 + Math.random() * 30) + '%';
      blob.style.top = (50 + Math.random() * 30) + '%';
      blob.style.fontSize = (1 + Math.random() * 1.5) + 'rem';
      overlay.appendChild(blob);
      setTimeout(() => blob.remove(), 3500);
    }
    spawnBlob();
    animIntervals.push(setInterval(spawnBlob, 600));

  } else if (type === 'fishTank') {
    const overlay = document.getElementById('sleep-overlay');
    overlay.classList.add('visible');
    overlay.style.background = 'linear-gradient(180deg, #0a2a3aee, #0a1a2aee)';
    function spawnFish() {
      const fishEmoji = ['\u{1F41F}', '\u{1F420}', '\u{1F421}', '\u{1F99E}'];
      const f = document.createElement('div');
      f.className = 'zzz';
      f.textContent = fishEmoji[Math.floor(Math.random() * fishEmoji.length)];
      f.style.left = (20 + Math.random() * 60) + '%';
      f.style.top = (30 + Math.random() * 40) + '%';
      f.style.fontSize = (1.5 + Math.random() * 1.5) + 'rem';
      overlay.appendChild(f);
      setTimeout(() => f.remove(), 3500);
    }
    function spawnBubble() {
      const b = document.createElement('div');
      b.className = 'zzz';
      b.textContent = '\u{1FAE7}';
      b.style.left = (25 + Math.random() * 50) + '%';
      b.style.top = (60 + Math.random() * 20) + '%';
      b.style.fontSize = '0.8rem';
      b.style.opacity = '0.5';
      overlay.appendChild(b);
      setTimeout(() => b.remove(), 2500);
    }
    spawnFish();
    animIntervals.push(setInterval(spawnFish, 900));
    animIntervals.push(setInterval(spawnBubble, 500));

  } else if (type === 'treadmill') {
    const overlay = document.getElementById('sleep-overlay');
    overlay.classList.add('visible');
    overlay.style.background = '#1a1a2eee';
    function spawnSweat() {
      const s = document.createElement('div');
      s.className = 'zzz';
      s.textContent = '\u{1F4A6}';
      s.style.left = (40 + Math.random() * 20) + '%';
      s.style.top = (30 + Math.random() * 20) + '%';
      s.style.fontSize = (1 + Math.random() * 1) + 'rem';
      overlay.appendChild(s);
      setTimeout(() => s.remove(), 2500);
    }
    const runner = document.createElement('div');
    runner.style.cssText = 'position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:4rem;';
    runner.textContent = '\u{1F3C3}';
    overlay.appendChild(runner);
    spawnSweat();
    animIntervals.push(setInterval(spawnSweat, 500));

  } else if (type === 'pool') {
    const overlay = document.getElementById('sleep-overlay');
    overlay.classList.add('visible');
    overlay.style.background = 'linear-gradient(180deg, #1a4466ee, #0a2244ee)';
    function spawnSplash() {
      const s = document.createElement('div');
      s.className = 'zzz';
      s.textContent = '\u{1F4A6}';
      s.style.left = (20 + Math.random() * 60) + '%';
      s.style.top = (30 + Math.random() * 30) + '%';
      s.style.fontSize = (1 + Math.random() * 1.5) + 'rem';
      overlay.appendChild(s);
      setTimeout(() => s.remove(), 2500);
    }
    const swimmer = document.createElement('div');
    swimmer.style.cssText = 'position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:4rem;';
    swimmer.textContent = '\u{1F3CA}';
    overlay.appendChild(swimmer);
    spawnSplash();
    animIntervals.push(setInterval(spawnSplash, 400));

  } else if (type === 'workbench') {
    const overlay = document.getElementById('sleep-overlay');
    overlay.classList.add('visible');
    overlay.style.background = '#2a2010ee';
    const tools = document.createElement('div');
    tools.style.cssText = 'position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:3.5rem;';
    tools.textContent = '\u{1F528}';
    overlay.appendChild(tools);
    function spawnSpark() {
      const s = document.createElement('div');
      s.className = 'zzz';
      s.textContent = '\u{2728}';
      s.style.left = (30 + Math.random() * 40) + '%';
      s.style.top = (35 + Math.random() * 25) + '%';
      s.style.fontSize = (0.8 + Math.random() * 1) + 'rem';
      overlay.appendChild(s);
      setTimeout(() => s.remove(), 2000);
    }
    spawnSpark();
    animIntervals.push(setInterval(spawnSpark, 600));

  } else if (type === 'punchingBag') {
    const overlay = document.getElementById('sleep-overlay');
    overlay.classList.add('visible');
    overlay.style.background = '#2a0a0aee';
    const fist = document.createElement('div');
    fist.style.cssText = 'position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); font-size:4rem;';
    fist.textContent = '\u{1F44A}';
    overlay.appendChild(fist);
    function spawnPow() {
      const s = document.createElement('div');
      s.className = 'zzz';
      s.textContent = '\u{1F4A5}';
      s.style.left = (30 + Math.random() * 40) + '%';
      s.style.top = (30 + Math.random() * 30) + '%';
      s.style.fontSize = (1.5 + Math.random() * 1.5) + 'rem';
      overlay.appendChild(s);
      setTimeout(() => s.remove(), 2000);
    }
    spawnPow();
    animIntervals.push(setInterval(spawnPow, 500));
  }
}

function stopActionAnim(type) {
  clearAnimIntervals();

  if (type === 'bed') {
    const overlay = document.getElementById('sleep-overlay');
    overlay.classList.remove('visible');
    setTimeout(() => { overlay.innerHTML = ''; }, 500);
  } else if (type === 'shower') {
    const overlay = document.getElementById('shower-overlay');
    overlay.classList.remove('visible');
    setTimeout(() => { overlay.innerHTML = ''; }, 500);
  } else if (type === 'fridge') {
    const overlay = document.getElementById('eat-overlay');
    const hand = document.getElementById('eat-hand-el');
    if (hand) hand.classList.remove('up');
    overlay.classList.remove('visible');
    setTimeout(() => { overlay.innerHTML = ''; }, 500);
  } else if (type === 'tv') {
    const overlay = document.getElementById('tv-overlay');
    overlay.classList.remove('visible');
    setTimeout(() => { overlay.innerHTML = ''; }, 500);
  } else if (type === 'computer') {
    miniGameRunning = false;
    const overlay = document.getElementById('computer-overlay');
    if (overlay._mgKeyDown) document.removeEventListener('keydown', overlay._mgKeyDown);
    if (overlay._mgKeyUp) document.removeEventListener('keyup', overlay._mgKeyUp);
    overlay.classList.remove('visible');
    setTimeout(() => { overlay.innerHTML = ''; }, 500);
  } else if (type === 'bookshelf' || type === 'bed2' || type === 'lavaLamp' || type === 'fishTank' || type === 'treadmill' || type === 'pool' || type === 'workbench' || type === 'punchingBag') {
    const overlay = document.getElementById('sleep-overlay');
    overlay.style.background = '';
    overlay.classList.remove('visible');
    setTimeout(() => { overlay.innerHTML = ''; }, 500);
  }
}

function clearAnimIntervals() {
  animIntervals.forEach(id => clearInterval(id));
  animIntervals = [];
}

// ═══ SHOP ═══
function toggleShop() {
  if (gameOver || !gameStarted || currentAction) return;
  shopOpen = !shopOpen;
  petMenuOpen = false;
  document.getElementById('pet-menu-overlay').classList.remove('visible');
  const overlay = document.getElementById('shop-overlay');
  if (shopOpen) {
    if (document.pointerLockElement) document.exitPointerLock();
    renderShopItems();
    overlay.classList.add('visible');
  } else {
    overlay.classList.remove('visible');
  }
}

// ═══ PET MENU ═══
let petMenuOpen = false;

function togglePetMenu() {
  if (gameOver || !gameStarted || currentAction) return;
  if (!petDogLoaded) return;
  petMenuOpen = !petMenuOpen;
  shopOpen = false;
  document.getElementById('shop-overlay').classList.remove('visible');
  const overlay = document.getElementById('pet-menu-overlay');
  if (petMenuOpen) {
    if (document.pointerLockElement) document.exitPointerLock();
    renderPetOptions();
    overlay.classList.add('visible');
  } else {
    overlay.classList.remove('visible');
  }
}

function renderPetOptions() {
  const container = document.getElementById('pet-options');
  container.innerHTML = '';
  const pets = [
    { id: 'dog', name: 'Dog', icon: '\u{1F415}', desc: 'Loyal golden retriever. Follows close behind you.' },
    { id: 'cat', name: 'Cat', icon: '\u{1F408}', desc: 'Independent grey cat. Wanders at your side.' },
    { id: 'none', name: 'No Pet', icon: '\u{1F6AB}', desc: 'Dismiss your pet for now.' },
  ];
  pets.forEach(pet => {
    const div = document.createElement('div');
    div.className = 'pet-option' + (activePet === pet.id ? ' active' : '');
    div.innerHTML =
      '<div class="pet-option-icon">' + pet.icon + '</div>' +
      '<div class="pet-option-info"><div class="pet-option-name">' + pet.name + '</div>' +
      '<div class="pet-option-desc">' + pet.desc + '</div></div>' +
      (activePet === pet.id ? '<div class="pet-option-badge">Active</div>' : '');
    div.onclick = () => {
      selectPet(pet.id);
      renderPetOptions();
    };
    container.appendChild(div);
  });
}

function selectPet(petId) {
  activePet = petId;
  petBonusTimer = 0;
  if (petDog) petDog.visible = petId === 'dog';
  if (petCat) petCat.visible = petId === 'cat';
  const names = { dog: 'Dog', cat: 'Cat', none: 'No Pet' };
  showTip(petId === 'none' ? 'Pet dismissed!' : 'Equipped: ' + names[petId] + '!');
}

function renderShopItems() {
  const container = document.getElementById('shop-items');
  container.innerHTML = '';

  // --- Expansions ---
  const expansions = [
    { name: 'Double Decker House', desc: 'Second floor with stairs, bookshelf, cozy bed, and plant!', cost: 200, purchased: hasSecondFloor, onBuy: purchaseSecondFloor },
    { name: 'Car', desc: 'Red car for the yard. Drive to town to meet people and do quests!', cost: 200, purchased: hasCar, onBuy: purchaseCar },
    { name: 'Mansion', desc: 'Luxury estate! Theater, spa, hot tub, library, tennis court, and more!', cost: 1000, purchased: hasMansion, onBuy: purchaseMansion },
  ];
  expansions.forEach(item => {
    const div = document.createElement('div');
    div.className = 'shop-item';
    const info = document.createElement('div');
    info.className = 'shop-item-info';
    info.innerHTML = '<div class="shop-item-name">' + item.name + '</div><div class="shop-item-desc">' + item.desc + '</div>';
    div.appendChild(info);
    const btn = document.createElement('button');
    if (item.purchased) {
      btn.className = 'shop-item-btn bought'; btn.textContent = 'OWNED';
    } else if (money < item.cost) {
      btn.className = 'shop-item-btn bought'; btn.textContent = '$' + item.cost;
    } else {
      btn.className = 'shop-item-btn buy'; btn.textContent = '$' + item.cost;
      btn.onclick = () => { item.onBuy(); renderShopItems(); };
    }
    div.appendChild(btn);
    container.appendChild(div);
  });

  // --- Furniture ---
  const furnitureLabel = document.createElement('div');
  furnitureLabel.style.cssText = 'color:#aaa; font-size:0.75rem; margin:14px 0 6px; text-transform:uppercase; letter-spacing:0.08em;';
  furnitureLabel.textContent = 'Furniture';
  container.appendChild(furnitureLabel);

  SHOP_FURNITURE.forEach(item => {
    const owned = ownedFurniture.has(item.id);
    const div = document.createElement('div');
    div.className = 'shop-item';
    const info = document.createElement('div');
    info.className = 'shop-item-info';
    info.innerHTML = '<div class="shop-item-name">' + item.name + '</div><div class="shop-item-desc">' + item.desc + '</div>';
    div.appendChild(info);
    const btn = document.createElement('button');
    if (owned) {
      btn.className = 'shop-item-btn bought'; btn.textContent = 'PLACED';
    } else if (money < item.cost) {
      btn.className = 'shop-item-btn bought'; btn.textContent = '$' + item.cost;
    } else {
      btn.className = 'shop-item-btn buy'; btn.textContent = '$' + item.cost;
      btn.onclick = () => { purchaseFurniture(item.id); renderShopItems(); };
    }
    div.appendChild(btn);
    container.appendChild(div);
  });

  // --- Outfits ---
  const outfitLabel = document.createElement('div');
  outfitLabel.style.cssText = 'color:#aaa; font-size:0.75rem; margin:14px 0 6px; text-transform:uppercase; letter-spacing:0.08em;';
  outfitLabel.textContent = 'Outfits';
  container.appendChild(outfitLabel);

  OUTFITS.forEach((fit, i) => {
    if (i === 0) return; // skip default free outfit
    const owned = ownedOutfits.has(i);
    const equipped = charOpts.outfit === i;
    const div = document.createElement('div');
    div.className = 'shop-item';
    // Color swatches
    const swatches = document.createElement('div');
    swatches.style.cssText = 'display:flex; gap:4px; margin-right:10px;';
    const s1 = document.createElement('div');
    s1.style.cssText = 'width:18px; height:24px; border-radius:3px 3px 0 0; border:1px solid #555; background:#' + fit.shirt.toString(16).padStart(6, '0');
    const s2 = document.createElement('div');
    s2.style.cssText = 'width:18px; height:16px; border-radius:0 0 3px 3px; border:1px solid #555; border-top:none; background:#' + fit.pants.toString(16).padStart(6, '0');
    const swatchCol = document.createElement('div');
    swatchCol.appendChild(s1); swatchCol.appendChild(s2);
    swatches.appendChild(swatchCol);
    div.appendChild(swatches);
    // Info
    const info = document.createElement('div');
    info.className = 'shop-item-info';
    info.innerHTML = '<div class="shop-item-name">' + fit.name + '</div>';
    div.appendChild(info);
    // Button
    const btn = document.createElement('button');
    if (equipped) {
      btn.className = 'shop-item-btn bought'; btn.textContent = 'WEARING';
    } else if (owned) {
      btn.className = 'shop-item-btn buy'; btn.textContent = 'EQUIP';
      btn.onclick = () => { equipOutfit(i); renderShopItems(); };
    } else if (money < fit.cost) {
      btn.className = 'shop-item-btn bought'; btn.textContent = '$' + fit.cost;
    } else {
      btn.className = 'shop-item-btn buy'; btn.textContent = '$' + fit.cost;
      btn.onclick = () => { buyOutfit(i); renderShopItems(); };
    }
    div.appendChild(btn);
    container.appendChild(div);
  });
}

function buyOutfit(idx) {
  const fit = OUTFITS[idx];
  if (!fit || money < fit.cost || ownedOutfits.has(idx)) return;
  money -= fit.cost;
  ownedOutfits.add(idx);
  SFX.kaChing();
  equipOutfit(idx);
  mlTry('ml_fashion_icon');
  mlCheckLivingLarge();
}

function equipOutfit(idx) {
  charOpts.outfit = idx;
  // Rebuild the in-game character with new outfit
  const pos = character.position.clone();
  const vis = character.visible;
  scene.remove(character);
  character = buildCharacter(charOpts);
  character.position.copy(pos);
  character.visible = vis;
  scene.add(character);
  showTip('Wearing: ' + OUTFITS[idx].name);
}

// ═══ MIRROR ═══
let mirrorOpen = false;
let mirrorRenderer = null;
let mirrorChar = null;
let mirrorAngle = 0;
const mirrorScene = new THREE.Scene();
mirrorScene.background = new THREE.Color(0x1a1a28);
const mirrorCam = new THREE.PerspectiveCamera(35, 280 / 400, 0.1, 20);
mirrorCam.position.set(0, 1.0, 3.2);
mirrorCam.lookAt(0, 0.75, 0);
const mirAmb = new THREE.AmbientLight(0x8888aa, 0.6);
mirrorScene.add(mirAmb);
const mirDir = new THREE.DirectionalLight(0xffeedd, 1.0);
mirDir.position.set(3, 5, 4);
mirrorScene.add(mirDir);

function openMirror() {
  mirrorOpen = true;
  if (document.pointerLockElement) document.exitPointerLock();
  const overlay = document.getElementById('mirror-overlay');
  overlay.innerHTML = '';
  overlay.classList.add('visible');

  const frame = document.createElement('div');
  frame.className = 'mirror-frame';
  overlay.appendChild(frame);

  const cvs = document.createElement('canvas');
  cvs.width = 280; cvs.height = 400;
  frame.appendChild(cvs);

  mirrorRenderer = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
  mirrorRenderer.setSize(280, 400);

  // Build a fresh character for the mirror
  if (mirrorChar) mirrorScene.remove(mirrorChar);
  mirrorChar = buildCharacter(charOpts);
  mirrorScene.add(mirrorChar);
  mirrorAngle = Math.PI; // face toward camera

  const label = document.createElement('div');
  label.className = 'mirror-label';
  label.textContent = OUTFITS[charOpts.outfit].name;
  overlay.appendChild(label);

  const hint = document.createElement('div');
  hint.className = 'mirror-hint';
  hint.textContent = 'Click or press any key to close';
  overlay.appendChild(hint);
}

function closeMirror() {
  if (!mirrorOpen) return;
  mirrorOpen = false;
  const overlay = document.getElementById('mirror-overlay');
  overlay.classList.remove('visible');
  setTimeout(() => {
    overlay.innerHTML = '';
    if (mirrorChar) { mirrorScene.remove(mirrorChar); mirrorChar = null; }
    if (mirrorRenderer) { mirrorRenderer.dispose(); mirrorRenderer = null; }
  }, 300);
}
document.getElementById('mirror-overlay').addEventListener('click', closeMirror);

function purchaseSecondFloor() {
  if (hasSecondFloor || money < 200) return;
  money -= 200;
  hasSecondFloor = true;
  SFX.kaChing();

  // Move fridge out of stairwell zone
  const fridgeObj = interactables.find(i => i.type === 'fridge');
  if (fridgeObj) {
    fridgeObj.group.position.set(-2, 0.15, -4);
    fridgeObj.usePos.set(-1.5, 0.15, -3.5);
  }

  secondFloorGroup = buildSecondFloor();
  scene.add(secondFloorGroup);
  rebuildInteractMeshes();
  showTip("Second floor built! Find the stairs on the left.");
  mlTry('ml_moving_up');
  mlCheckLivingLarge();
}

// ═══ BUILD SECOND FLOOR ═══
function buildSecondFloor() {
  const group = new THREE.Group();
  const woodMat = mat.table;
  const wallMat = mat.wall;

  // --- Stairs (7 steps along left wall, Z: -4.5 to -0.5) ---
  const STEPS = 7;
  const stepW = 1.4, stepD = (4.0) / STEPS; // Z span = 4.0
  for (let i = 0; i < STEPS; i++) {
    const stepH = ((i + 1) / STEPS) * (UPPER_Y - GROUND_Y);
    const step = new THREE.Mesh(new THREE.BoxGeometry(stepW, stepH, stepD), woodMat);
    step.position.set(-4.3, GROUND_Y + stepH / 2, STAIR.zMin + (i + 0.5) * stepD);
    step.castShadow = true;
    step.receiveShadow = true;
    group.add(step);
  }
  // Stair railing (open side)
  const railing = new THREE.Mesh(new THREE.BoxGeometry(0.06, 1.2, 4.0), woodMat);
  railing.position.set(STAIR.xMax, 2.5, (STAIR.zMin + STAIR.zMax) / 2);
  group.add(railing);
  // Railing posts
  for (let z = STAIR.zMin; z <= STAIR.zMax; z += 1.0) {
    const post = new THREE.Mesh(new THREE.BoxGeometry(0.06, 1.2, 0.06), woodMat);
    post.position.set(STAIR.xMax, 2.5, z);
    group.add(post);
  }

  // --- Second floor slab (with stairwell hole) ---
  // Right portion: X -3.5 to 5 (width 8.5)
  const floor1 = new THREE.Mesh(new THREE.BoxGeometry(8.5, 0.15, 10), mat.floor);
  floor1.position.set(0.75, UPPER_Y - 0.075, 0);
  floor1.receiveShadow = true;
  group.add(floor1);
  // Left-front portion: X -5 to -3.5, Z -0.5 to 5 (width 1.5, depth 5.5)
  const floor2 = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.15, 5.5), mat.floor);
  floor2.position.set(-4.25, UPPER_Y - 0.075, 2.25);
  floor2.receiveShadow = true;
  group.add(floor2);

  // Rug upstairs
  const rug2 = new THREE.Mesh(new THREE.BoxGeometry(3, 0.02, 2), mat.rug);
  rug2.position.set(1, UPPER_Y + 0.01, 0);
  group.add(rug2);

  // Upper floor stairwell railing
  const upperRail = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.8, 0.08), woodMat);
  upperRail.position.set(-4.25, UPPER_Y + 0.4, STAIR.zMax);
  group.add(upperRail);
  // Side railing along the stairwell opening
  const sideRail = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.8, Math.abs(STAIR.zMax - STAIR.zMin)), woodMat);
  sideRail.position.set(STAIR.xMax, UPPER_Y + 0.4, (STAIR.zMin + STAIR.zMax) / 2);
  group.add(sideRail);

  // --- Walls (second floor) ---
  const wh = 3.5, wy = UPPER_Y + wh / 2;
  // Back
  const w1 = new THREE.Mesh(new THREE.BoxGeometry(10.3, wh, 0.15), wallMat);
  w1.position.set(0, wy, -5); w1.castShadow = true; group.add(w1);
  // Left
  const w2 = new THREE.Mesh(new THREE.BoxGeometry(0.15, wh, 10), wallMat);
  w2.position.set(-5, wy, 0); w2.castShadow = true; group.add(w2);
  // Right
  const w3 = new THREE.Mesh(new THREE.BoxGeometry(0.15, wh, 10), wallMat);
  w3.position.set(5, wy, 0); w3.castShadow = true; group.add(w3);
  // Front
  const w4 = new THREE.Mesh(new THREE.BoxGeometry(10.3, wh, 0.15), wallMat);
  w4.position.set(0, wy, 5); w4.castShadow = true; group.add(w4);

  // Ceiling
  const ceil = new THREE.Mesh(new THREE.BoxGeometry(10.3, 0.15, 10.3), wallMat);
  ceil.position.set(0, UPPER_Y + wh + 0.075, 0);
  group.add(ceil);

  // Window (back wall upstairs)
  const win2 = new THREE.Mesh(new THREE.BoxGeometry(2, 1.5, 0.1), mat.window);
  win2.position.set(1.5, UPPER_Y + 2.0, -4.9);
  group.add(win2);

  // --- Bookshelf ---
  const bsGroup = new THREE.Group();
  const bsFrame = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.2, 0.4), woodMat);
  bsFrame.position.set(0, 1.1, 0);
  bsFrame.castShadow = true;
  bsGroup.add(bsFrame);
  for (let i = 0; i < 4; i++) {
    const shelf = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.04, 0.35), woodMat);
    shelf.position.set(0, 0.3 + i * 0.55, 0.03);
    bsGroup.add(shelf);
  }
  const bookColors = [0xcc3333, 0x3366cc, 0x33aa55, 0xccaa33, 0x8833aa, 0xcc6633];
  for (let s = 0; s < 3; s++) {
    for (let b = 0; b < 4; b++) {
      const bm = new THREE.MeshLambertMaterial({ color: bookColors[(s * 4 + b) % bookColors.length] });
      const book = new THREE.Mesh(new THREE.BoxGeometry(0.08 + Math.random() * 0.04, 0.25 + Math.random() * 0.1, 0.22), bm);
      book.position.set(-0.45 + b * 0.28, 0.48 + s * 0.55, 0.03);
      bsGroup.add(book);
    }
  }
  bsGroup.position.set(4, UPPER_Y, -4);
  group.add(bsGroup);
  interactables.push({ mesh: bsFrame, group: bsGroup, type: 'bookshelf', label: 'Read a Book', need: 'fun', usePos: new THREE.Vector3(3, UPPER_Y, -3.5), floor: 1 });

  // --- Upstairs bed ---
  const bedGroup = new THREE.Group();
  const bed2Sheet = new THREE.MeshLambertMaterial({ color: 0x8844aa });
  const frame2 = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.5, 3.2), mat.bed);
  frame2.position.set(0, 0.25, 0); frame2.castShadow = true; bedGroup.add(frame2);
  const matt2 = new THREE.Mesh(new THREE.BoxGeometry(2, 0.2, 3), bed2Sheet);
  matt2.position.set(0, 0.55, 0); bedGroup.add(matt2);
  const pill2 = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.15, 0.5), mat.pillow);
  pill2.position.set(0, 0.7, -1.1); bedGroup.add(pill2);
  const hb2 = new THREE.Mesh(new THREE.BoxGeometry(2.2, 1, 0.15), mat.bed);
  hb2.position.set(0, 0.8, -1.55); hb2.castShadow = true; bedGroup.add(hb2);
  bedGroup.position.set(-3, UPPER_Y, 3);
  group.add(bedGroup);
  interactables.push({ mesh: frame2, group: bedGroup, type: 'bed2', label: 'Nap (Cozy Bed)', need: 'energy', usePos: new THREE.Vector3(-2, UPPER_Y, 2), floor: 1 });

  // --- Plant ---
  const plantGroup = new THREE.Group();
  const potMat = new THREE.MeshLambertMaterial({ color: 0xaa5533 });
  const leafMat = new THREE.MeshLambertMaterial({ color: 0x33aa44 });
  const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.15, 0.4, 8), potMat);
  pot.position.set(0, 0.2, 0); plantGroup.add(pot);
  const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.4, 6), leafMat);
  stem.position.set(0, 0.55, 0); plantGroup.add(stem);
  [[0, 0.8, 0], [-0.15, 0.7, 0.1], [0.15, 0.7, -0.1], [0.1, 0.65, 0.15]].forEach(p => {
    const leaf = new THREE.Mesh(new THREE.SphereGeometry(0.15, 8, 6), leafMat);
    leaf.position.set(p[0], p[1], p[2]);
    plantGroup.add(leaf);
  });
  plantGroup.position.set(3.5, UPPER_Y, 4);
  group.add(plantGroup);

  // Action configs for new furniture
  actionConfig.bookshelf = { label: 'Reading...', duration: 4, restore: 40, cost: 0 };
  actionConfig.bed2 = { label: 'Napping...', duration: 5, restore: 55, cost: 0 };

  return group;
}

// ═══ FLOOR SYSTEM ═══
const BASEMENT_Y = -3.35;
const BSTAIR = { xMin: 5.3, xMax: 8, zMin: -4.5, zMax: -2.5 };

function updatePlayerY() {
  const x = character.position.x, z = character.position.z;

  // In town — always ground level
  if (inTown) { character.position.y = GROUND_Y; return; }

  // In mansion — handle mansion stairs
  if (inMansion) {
    const onMStairs = x >= MANSION_STAIR.xMin && x <= MANSION_STAIR.xMax && z >= MANSION_STAIR.zMin && z <= MANSION_STAIR.zMax;
    if (onMStairs) {
      const t = (z - MANSION_STAIR.zMin) / (MANSION_STAIR.zMax - MANSION_STAIR.zMin);
      character.position.y = GROUND_Y + t * (MANSION_UPPER_Y - GROUND_Y);
      if (t < 0.15) currentFloor = 0;
      else if (t > 0.85) currentFloor = 1;
    } else {
      if (currentFloor === 1 && x >= MANSION_STAIR.xMin && x <= MANSION_STAIR.xMax && z > MANSION_STAIR.zMin && z < MANSION_STAIR.zMax) {
        character.position.x = MANSION_STAIR.xMax;
      }
      character.position.y = currentFloor === 1 ? MANSION_UPPER_Y : GROUND_Y;
    }
    return;
  }

  // Basement stairs check (in yard — must come before yard ground check)
  if (basementLoaded) {
    const onBStairs = x >= BSTAIR.xMin && x <= BSTAIR.xMax && z >= BSTAIR.zMin && z <= BSTAIR.zMax;
    if (onBStairs && (currentFloor === 0 || currentFloor === -1)) {
      const t = (BSTAIR.xMax - x) / (BSTAIR.xMax - BSTAIR.xMin);
      character.position.y = GROUND_Y - t * (GROUND_Y - (BASEMENT_Y + 0.15));
      if (t < 0.15) currentFloor = 0;
      else if (t > 0.85) currentFloor = -1;
      return;
    }
    if (currentFloor === -1) {
      // Allow passage through stair opening in right wall (z=-4.5 to z=-2.5)
      const inStairGap = z >= BSTAIR.zMin && z <= BSTAIR.zMax;
      character.position.x = Math.max(-4.5, Math.min(inStairGap ? BSTAIR.xMax : 4.5, x));
      character.position.z = Math.max(-4.5, Math.min(4.5, z));
      character.position.y = BASEMENT_Y + 0.15;
      return;
    }
  }

  // Outside the house — always ground level
  if (x > 5.0) { character.position.y = GROUND_Y; return; }

  if (!hasSecondFloor) { character.position.y = GROUND_Y; return; }

  const onStairs = x >= STAIR.xMin && x <= STAIR.xMax && z >= STAIR.zMin && z <= STAIR.zMax;

  if (onStairs) {
    const t = (z - STAIR.zMin) / (STAIR.zMax - STAIR.zMin);
    character.position.y = GROUND_Y + t * (UPPER_Y - GROUND_Y);
    if (t < 0.15) currentFloor = 0;
    else if (t > 0.85) currentFloor = 1;
  } else {
    // Prevent falling into stairwell hole from upper floor
    if (currentFloor === 1 && x < STAIR.xMax && z < STAIR.zMax && z > STAIR.zMin) {
      character.position.x = STAIR.xMax;
    }
    character.position.y = currentFloor === 0 ? GROUND_Y : UPPER_Y;
  }
}

// ═══ UPDATE LOOP ═══
let lastTime = performance.now();
let walkAnim = 0;

function update() {
  if (!gameStarted || gameOver) return;
  const now = performance.now();
  const dt = (now - lastTime) / 1000;
  lastTime = now;

  // Game time
  gameTime += GAME_SPEED * dt * 60;
  if (gameTime >= 1440) {
    gameTime -= 1440; day++; money += 20; SFX.dayChime();
    if (day >= 3) mlTry('ml_survivor');
    if (day >= 7) mlTry('ml_week_warrior');
    if (Math.floor(money) >= 500) mlTry('ml_high_roller');
  }

  // Decay needs
  for (const key in needs) {
    needs[key] -= decayRates[key] * GAME_SPEED * dt;
    if (needs[key] <= 0) {
      needs[key] = 0;
      triggerGameOver(key);
      return;
    }
  }

  // Pet happiness bonus (+10 fun every 30 real seconds with a pet)
  if (activePet !== 'none' && petDogLoaded) {
    petBonusTimer += dt;
    if (petBonusTimer >= 30) {
      petBonusTimer -= 30;
      needs.fun = Math.min(100, needs.fun + 10);
      showTip(activePet === 'dog' ? 'Your dog makes you happy!' : 'Your cat purrs contentedly!');
    }
  }

  // Money trickle
  money += 0.02 * dt;

  // First-person WASD movement
  if (moveTarget) {
    // Auto-walk to action target
    const dir = new THREE.Vector3().subVectors(moveTarget, character.position);
    dir.y = 0;
    const dist = dir.length();
    if (dist < 0.5) {
      character.position.x = moveTarget.x;
      character.position.z = moveTarget.z;
      updatePlayerY();
      moveTarget = null;
      if (currentAction && currentAction.phase === 'walking') {
        beginAction(currentAction);
      }
    } else {
      dir.normalize();
      character.position.add(dir.multiplyScalar(MOVE_SPEED * dt));
      updatePlayerY();
    }
  } else if (!currentAction || currentAction.phase !== 'doing') {
    // WASD movement
    const forward = new THREE.Vector3(-Math.sin(yaw), 0, -Math.cos(yaw));
    const right = new THREE.Vector3(Math.cos(yaw), 0, -Math.sin(yaw));
    const move = new THREE.Vector3();
    if (keys['KeyW'] || keys['ArrowUp']) move.add(forward);
    if (keys['KeyS'] || keys['ArrowDown']) move.sub(forward);
    if (keys['KeyA'] || keys['ArrowLeft']) move.sub(right);
    if (keys['KeyD'] || keys['ArrowRight']) move.add(right);
    if (move.lengthSq() > 0) {
      move.normalize().multiplyScalar(MOVE_SPEED * dt);
      character.position.add(move);
      // Head bob + footsteps
      const prevWalk = walkAnim;
      walkAnim += dt * 10;
      if (Math.floor(prevWalk / Math.PI) !== Math.floor(walkAnim / Math.PI)) SFX.footstep();
    }
    // Clamp to room / yard / town boundaries
    let px = character.position.x;
    let pz = character.position.z;
    if (inTown) {
      // Town bounds
      px = Math.max(TOWN_BOUNDS.xMin, Math.min(TOWN_BOUNDS.xMax, px));
      pz = Math.max(TOWN_BOUNDS.zMin, Math.min(TOWN_BOUNDS.zMax, pz));
      // Building collision — push out of AABBs
      for (const b of TOWN_BUILDINGS) {
        if (px > b.xMin && px < b.xMax && pz > b.zMin && pz < b.zMax) {
          const dL = px - b.xMin, dR = b.xMax - px, dB = pz - b.zMin, dT = b.zMax - pz;
          const minD = Math.min(dL, dR, dB, dT);
          if (minD === dL) px = b.xMin;
          else if (minD === dR) px = b.xMax;
          else if (minD === dB) pz = b.zMin;
          else pz = b.zMax;
        }
      }
      character.position.x = px;
      character.position.z = pz;
    } else if (inMansion) {
      // Mansion bounds
      px = Math.max(MANSION_BOUNDS.xMin, Math.min(MANSION_BOUNDS.xMax, px));
      pz = Math.max(MANSION_BOUNDS.zMin, Math.min(MANSION_BOUNDS.zMax, pz));
      // Mansion collision — push out of AABBs
      if (currentFloor === 0) {
        for (const b of MANSION_COLLISIONS) {
          if (px > b.xMin && px < b.xMax && pz > b.zMin && pz < b.zMax) {
            const dL = px - b.xMin, dR = b.xMax - px, dB = pz - b.zMin, dT = b.zMax - pz;
            const minD = Math.min(dL, dR, dB, dT);
            if (minD === dL) px = b.xMin;
            else if (minD === dR) px = b.xMax;
            else if (minD === dB) pz = b.zMin;
            else pz = b.zMax;
          }
        }
      } else if (currentFloor === 1) {
        // Upper floor bounds — inside the mansion building
        px = Math.max(265.5, Math.min(304.5, px));
        pz = Math.max(-9.5, Math.min(9.5, pz));
      }
      character.position.x = px;
      character.position.z = pz;
    } else if (basementLoaded && currentFloor === -1) {
      // Basement level — allow passage through stair opening
      const inGap = pz >= BSTAIR.zMin && pz <= BSTAIR.zMax;
      character.position.x = Math.max(-4.5, Math.min(inGap ? BSTAIR.xMax : 4.5, px));
      character.position.z = Math.max(-4.5, Math.min(4.5, pz));
    } else if (doorOpen && px > 4.3) {
      // Near or past right wall — check door gap
      if (pz >= -0.5 && pz <= 2.0) {
        // In the door gap — allow passage to yard
        character.position.x = Math.max(-4.5, Math.min(18, px));
        character.position.z = px > 5.0
          ? Math.max(-8, Math.min(8, pz))     // yard bounds
          : Math.max(-4.5, Math.min(4.5, pz)); // room bounds
      } else if (px > 5.0) {
        // Outside but drifted past gap edges — yard bounds
        character.position.x = Math.max(5.1, Math.min(18, px));
        character.position.z = Math.max(-8, Math.min(8, pz));
      } else {
        // Inside room, near right wall but outside gap — block
        character.position.x = Math.max(-4.5, Math.min(4.3, px));
        character.position.z = Math.max(-4.5, Math.min(4.5, pz));
      }
    } else {
      // Door closed or away from right wall — normal room clamp
      character.position.x = Math.max(-4.5, Math.min(4.5, px));
      character.position.z = Math.max(-4.5, Math.min(4.5, pz));
    }
    updatePlayerY();
  }

  // Action progress
  if (currentAction && currentAction.phase === 'doing') {
    actionProgress += dt;
    const pct = Math.min(actionProgress / actionDuration, 1);
    document.getElementById('action-bar-fill').style.width = (pct * 100) + '%';
    if (pct >= 1) {
      finishAction(currentAction);
    }
  }

  // Day/night cycle
  updateDayNight();

  // Door swing animation
  if (doorAnimating) {
    const target = doorOpen ? DOOR_OPEN_ANGLE : 0;
    const diff = target - doorAngle;
    if (Math.abs(diff) < 0.02) {
      doorAngle = target;
      doorAnimating = false;
    } else {
      doorAngle += Math.sign(diff) * DOOR_ANIM_SPEED * dt;
      if ((diff > 0 && doorAngle > target) || (diff < 0 && doorAngle < target)) {
        doorAngle = target;
        doorAnimating = false;
      }
    }
    doorPivot.rotation.y = doorAngle;
  }

  // Active pet follow (only at home)
  if (!inTown && !inMansion) {
    if (petDog && activePet === 'dog') {
      const target = character.position.clone();
      target.x += Math.sin(yaw + 2) * 1.5;
      target.z += Math.cos(yaw + 2) * 1.5;
      target.y = character.position.y;
      petDog.position.lerp(target, 0.03);
      petDog.lookAt(character.position.x, petDog.position.y, character.position.z);
      const tail = petDog.getObjectByName('dogTail');
      if (tail) tail.rotation.y = Math.sin(performance.now() * 0.008) * 0.5;
    }
    if (petCat && activePet === 'cat') {
      const catTarget = character.position.clone();
      catTarget.x += Math.sin(yaw - 2) * 1.8;
      catTarget.z += Math.cos(yaw - 2) * 1.8;
      catTarget.y = character.position.y;
      petCat.position.lerp(catTarget, 0.02);
      petCat.lookAt(character.position.x, petCat.position.y, character.position.z);
      const catTail = petCat.getObjectByName('catTail');
      if (catTail) catTail.rotation.y = Math.sin(performance.now() * 0.006) * 0.7;
    }
  }

  // First-person camera
  const bobY = (keys['KeyW'] || keys['KeyS'] || keys['KeyA'] || keys['KeyD']) ? Math.sin(walkAnim) * 0.04 : 0;
  camera.position.set(
    character.position.x,
    character.position.y + EYE_HEIGHT + bobY,
    character.position.z
  );
  // Look direction from yaw/pitch
  const lookDir = new THREE.Vector3(
    -Math.sin(yaw) * Math.cos(pitch),
    Math.sin(pitch),
    -Math.cos(yaw) * Math.cos(pitch)
  );
  camera.lookAt(camera.position.clone().add(lookDir));

  // Crosshair raycast
  updateCrosshairRaycast();

  updateHUD();
}

function updateDayNight() {
  const hour = gameTime / 60;
  let sunIntensity, ambIntensity, skyR, skyG, skyB;

  if (hour >= 6 && hour < 8) {
    // Sunrise
    const t = (hour - 6) / 2;
    sunIntensity = 0.3 + t * 0.7;
    ambIntensity = 0.3 + t * 0.2;
    skyR = 0.3 + t * 0.23; skyG = 0.4 + t * 0.41; skyB = 0.5 + t * 0.42;
  } else if (hour >= 8 && hour < 18) {
    // Day
    sunIntensity = 1.0; ambIntensity = 0.5;
    skyR = 0.53; skyG = 0.81; skyB = 0.92;
  } else if (hour >= 18 && hour < 20) {
    // Sunset
    const t = (hour - 18) / 2;
    sunIntensity = 1.0 - t * 0.7;
    ambIntensity = 0.5 - t * 0.3;
    skyR = 0.53 + t * 0.27; skyG = 0.81 - t * 0.51; skyB = 0.92 - t * 0.72;
  } else {
    // Night
    sunIntensity = 0.15; ambIntensity = 0.15;
    skyR = 0.05; skyG = 0.05; skyB = 0.15;
  }

  sunLight.intensity = sunIntensity;
  ambientLight.intensity = ambIntensity;
  scene.background.setRGB(skyR, skyG, skyB);
  scene.fog.color.setRGB(skyR, skyG, skyB);
}

function updateHUD() {
  for (const key of ['hunger', 'energy', 'fun', 'hygiene']) {
    const v = Math.round(needs[key]);
    document.getElementById('bar-' + key).style.width = v + '%';
    document.getElementById('val-' + key).textContent = v;
    // Color based on value
    const bar = document.getElementById('bar-' + key);
    if (v > 60) bar.style.background = { hunger: '#4caf50', energy: '#2196f3', fun: '#ff9800', hygiene: '#00bcd4' }[key];
    else if (v > 30) bar.style.background = '#f5a623';
    else bar.style.background = '#f44336';
  }

  document.getElementById('money-val').textContent = Math.floor(money);

  const hour = Math.floor(gameTime / 60) % 24;
  const min = Math.floor(gameTime % 60);
  const ampm = hour >= 12 ? 'PM' : 'AM';
  const h12 = hour === 0 ? 12 : hour > 12 ? hour - 12 : hour;
  document.getElementById('time-val').textContent = h12 + ':' + String(min).padStart(2, '0') + ' ' + ampm;
  document.getElementById('time-icon').textContent = (hour >= 6 && hour < 20) ? '\u2600\uFE0F' : '\u{1F319}';
  document.getElementById('day-val').textContent = day;
}

function triggerGameOver(need) {
  gameOver = true;
  shopOpen = false;
  petMenuOpen = false;
  closeMirror();
  closeNPCDialogue();
  document.getElementById('shop-overlay').classList.remove('visible');
  document.getElementById('pet-menu-overlay').classList.remove('visible');
  document.getElementById('drive-overlay').classList.remove('visible');
  SFX.stopLoops();
  SFX.stopMusic();
  SFX.gameOver();
  const reasons = {
    hunger: 'You starved!',
    energy: 'You collapsed from exhaustion!',
    fun: 'You died of boredom!',
    hygiene: 'You... well, let\'s not talk about it.',
  };
  document.getElementById('game-over-reason').textContent = reasons[need];
  document.getElementById('game-over').classList.add('visible');
}

function restartGame() {
  gameOver = false;
  gameStarted = false;
  needs.hunger = 100; needs.energy = 100; needs.fun = 100; needs.hygiene = 100;
  money = 50;
  gameTime = 360;
  day = 1;
  moveTarget = null;
  currentAction = null;
  actionProgress = 0;
  character.position.set(0, 0.15, 0);
  yaw = Math.PI;
  pitch = 0;
  document.getElementById('game-over').classList.remove('visible');
  document.getElementById('action-bar-wrap').classList.remove('visible');
  // Clean up any running sounds and animations
  SFX.stopLoops();
  SFX.stopMusic();
  miniGameRunning = false;
  miniGameScore = 0;
  clearAnimIntervals();
  closeMirror();
  ['sleep-overlay', 'shower-overlay', 'eat-overlay', 'tv-overlay', 'computer-overlay', 'job-overlay', 'name-prompt-overlay'].forEach(id => {
    const el = document.getElementById(id);
    el.style.background = '';
    el.classList.remove('visible');
    el.innerHTML = '';
  });
  // Reset door
  doorOpen = false;
  doorAnimating = false;
  doorAngle = 0;
  doorPivot.rotation.y = 0;
  const doorInteract = interactables.find(i => i.type === 'door');
  if (doorInteract) doorInteract.label = 'Open Door';
  // Tear down second floor
  if (secondFloorGroup) {
    scene.remove(secondFloorGroup);
    secondFloorGroup = null;
  }
  hasSecondFloor = false;
  currentFloor = 0;
  shopOpen = false;
  petMenuOpen = false;
  document.getElementById('shop-overlay').classList.remove('visible');
  document.getElementById('pet-menu-overlay').classList.remove('visible');
  // Remove second-floor interactables
  for (let i = interactables.length - 1; i >= 0; i--) {
    if (interactables[i].floor === 1) interactables.splice(i, 1);
  }
  delete actionConfig.bookshelf;
  delete actionConfig.bed2;
  // Reset furniture
  for (const id of ownedFurniture) {
    if (furnitureGroups[id]) {
      scene.remove(furnitureGroups[id]);
      delete furnitureGroups[id];
    }
    for (let i = interactables.length - 1; i >= 0; i--) {
      if (interactables[i].type === id) interactables.splice(i, 1);
    }
    delete actionConfig[id];
  }
  ownedFurniture = new Set();
  rebuildInteractMeshes();
  // Reset outfits
  ownedOutfits = new Set([0]);
  charOpts.outfit = 0;
  booksRead = 0;
  treadmillUses = 0;
  activePet = 'dog';
  petBonusTimer = 0;
  // Reset town/car state
  if (carGroup) { scene.remove(carGroup); carGroup = null; }
  if (townGroup) { scene.remove(townGroup); townGroup = null; }
  townCarGroup = null;
  hasCar = false;
  inTown = false;
  questLog = {};
  questsCompleted = 0;
  jobLastDay = {};
  totalShiftsWorked = 0;
  jobMiniGameRunning = false;
  currentSlot = -1;
  currentSlotName = '';
  npcDialogueOpen = false;
  currentNPCId = null;
  // Reset mansion state
  if (mansionGroup) { scene.remove(mansionGroup); mansionGroup = null; }
  mansionCarGroup = null;
  hasMansion = false;
  inMansion = false;
  driveDestOpen = false;
  // Remove car/townCar/mansion/npc interactables
  const mansionTypes = ['mansionCar', 'mansionKitchen', 'grandPiano', 'homeTheater', 'mansionSpa',
    'kingBed', 'mansionLibrary', 'artEasel', 'mansionArcade', 'hotTub', 'wineRack', 'tennisCourt', 'zenGarden'];
  for (let i = interactables.length - 1; i >= 0; i--) {
    if (['car', 'townCar'].includes(interactables[i].type) || mansionTypes.includes(interactables[i].type)) interactables.splice(i, 1);
  }
  mansionTypes.forEach(k => delete actionConfig[k]);
  npcBodyMeshes = [];
  townNPCs = [];
  scene.fog.far = HOME_FOG_FAR;
  sunLight.shadow.camera.left = -15;
  sunLight.shadow.camera.right = 15;
  sunLight.shadow.camera.top = 20;
  sunLight.shadow.camera.bottom = -15;
  sunLight.shadow.camera.updateProjectionMatrix();
  document.getElementById('drive-overlay').classList.remove('visible');
  document.getElementById('npc-dialogue-overlay').classList.remove('visible');
  document.getElementById('drive-dest-overlay').classList.remove('visible');
  document.getElementById('drive-mansion-btn').style.display = 'none';
  // Reset fridge position
  const fridgeObj = interactables.find(i => i.type === 'fridge');
  if (fridgeObj) {
    fridgeObj.group.position.set(-4, 0.15, -4);
    fridgeObj.usePos.set(-3, 0.15, -3.5);
  }
  // Show creator again
  document.getElementById('creator-screen').classList.remove('hidden');
  renderSlotList();
  // Release pointer lock
  if (document.pointerLockElement) document.exitPointerLock();
  lastTime = performance.now();
}

// ═══ SAVE / LOAD ═══
function getSlotsMetadata() {
  try { return JSON.parse(localStorage.getItem('minilife-slots')) || [null, null, null]; }
  catch(e) { return [null, null, null]; }
}
function setSlotsMetadata(slots) { localStorage.setItem('minilife-slots', JSON.stringify(slots)); }

function renderSlotList() {
  const container = document.getElementById('save-slot-list');
  if (!container) return;
  container.innerHTML = '';
  const slots = getSlotsMetadata();
  slots.forEach((slot, i) => {
    const row = document.createElement('div');
    row.className = 'save-slot-row' + (slot ? ' occupied' : '');
    if (slot) {
      row.innerHTML = '<div class="save-slot-info"><div class="save-slot-name">' + slot.name + '</div>' +
        '<div class="save-slot-detail">Day ' + (slot.day || 1) + ' | $' + Math.floor(slot.money || 0) + '</div></div>' +
        '<div class="save-slot-btns"><button class="slot-load-btn" onclick="loadSlot(' + i + ')">LOAD</button>' +
        '<button class="slot-delete-btn" onclick="deleteSlot(' + i + ')">DEL</button></div>';
    } else {
      row.innerHTML = '<div class="save-slot-empty">Empty</div>';
    }
    container.appendChild(row);
  });
}

function promptSaveName(callback) {
  const overlay = document.getElementById('name-prompt-overlay');
  const input = document.getElementById('name-prompt-input');
  const btn = document.getElementById('name-prompt-ok');
  input.value = '';
  overlay.classList.add('visible');
  setTimeout(() => input.focus(), 100);
  function finish() {
    const name = input.value.trim() || ('Save ' + (currentSlot + 1));
    overlay.classList.remove('visible');
    btn.removeEventListener('click', finish);
    input.removeEventListener('keydown', onKey);
    callback(name);
  }
  function onKey(e) { if (e.key === 'Enter') finish(); }
  btn.addEventListener('click', finish);
  input.addEventListener('keydown', onKey);
}

function buildSaveData() {
  return {
    needs: { ...needs },
    money,
    gameTime,
    day,
    charOpts: { ...charOpts },
    ownedOutfits: [...ownedOutfits],
    ownedFurniture: [...ownedFurniture],
    currentTrackId: SFX.currentTrackId,
    doorOpen,
    hasSecondFloor,
    booksRead,
    treadmillUses,
    activePet,
    currentFloor,
    playerPos: { x: character.position.x, y: character.position.y, z: character.position.z },
    yaw,
    pitch,
    hasCar,
    inTown,
    hasMansion,
    inMansion,
    questLog: JSON.parse(JSON.stringify(questLog)),
    questsCompleted,
    jobLastDay: { ...jobLastDay },
    totalShiftsWorked,
  };
}

function writeSaveToSlot(slotIndex, name) {
  const save = buildSaveData();
  localStorage.setItem('minilife-slot-' + slotIndex, JSON.stringify(save));
  const slots = getSlotsMetadata();
  slots[slotIndex] = { name, day: save.day, money: save.money };
  setSlotsMetadata(slots);
  currentSlot = slotIndex;
  currentSlotName = name;
  SFX.kaChing();
  const toast = document.getElementById('save-toast');
  toast.classList.add('visible');
  setTimeout(() => toast.classList.remove('visible'), 1500);
}

function saveGame() {
  if (!gameStarted || gameOver) return;
  if (currentSlot >= 0 && currentSlotName) {
    // Already have a slot — just save
    writeSaveToSlot(currentSlot, currentSlotName);
    return;
  }
  // Need to pick a slot and name
  const slots = getSlotsMetadata();
  const emptyIdx = slots.findIndex(s => s === null);
  if (emptyIdx >= 0) {
    currentSlot = emptyIdx;
    promptSaveName(name => writeSaveToSlot(emptyIdx, name));
  } else {
    // All full — overwrite slot 2 (last)
    currentSlot = 2;
    promptSaveName(name => writeSaveToSlot(2, name));
  }
}

function loadSlot(index) {
  const raw = localStorage.getItem('minilife-slot-' + index);
  if (!raw) return;
  const save = JSON.parse(raw);
  const slots = getSlotsMetadata();
  currentSlot = index;
  currentSlotName = slots[index] ? slots[index].name : ('Save ' + (index + 1));

  // Restore character options and rebuild preview to match
  charOpts.skinTone = save.charOpts.skinTone;
  charOpts.gender = save.charOpts.gender;
  charOpts.hairStyle = save.charOpts.hairStyle;
  charOpts.hairColor = save.charOpts.hairColor;
  charOpts.outfit = save.charOpts.outfit;
  ownedOutfits = new Set(save.ownedOutfits);

  // Start the game first (hides creator, builds character)
  startGame();

  // Now restore state
  needs.hunger = save.needs.hunger;
  needs.energy = save.needs.energy;
  needs.fun = save.needs.fun;
  needs.hygiene = save.needs.hygiene;
  money = save.money;
  gameTime = save.gameTime;
  day = save.day;
  booksRead = save.booksRead || 0;
  treadmillUses = save.treadmillUses || 0;
  activePet = save.activePet || 'dog';
  yaw = save.yaw;
  pitch = save.pitch;
  character.position.set(save.playerPos.x, save.playerPos.y, save.playerPos.z);

  // Rebuild second floor if owned
  if (save.hasSecondFloor) {
    hasSecondFloor = true;
    // Move fridge out of stairwell zone
    const fridgeObj = interactables.find(i => i.type === 'fridge');
    if (fridgeObj) {
      fridgeObj.group.position.set(-2, 0.15, -4);
      fridgeObj.usePos.set(-1.5, 0.15, -3.5);
    }
    secondFloorGroup = buildSecondFloor();
    scene.add(secondFloorGroup);
    rebuildInteractMeshes();
  }
  currentFloor = save.currentFloor;

  // Restore music track
  if (save.currentTrackId && SFX.TRACK_ORDER.includes(save.currentTrackId)) {
    SFX.currentTrackId = save.currentTrackId;
    SFX.stopMusic();
    setTimeout(() => SFX.startMusic(), 650);
  }

  // Restore door state
  if (save.doorOpen) {
    doorOpen = true;
    doorAngle = DOOR_OPEN_ANGLE;
    doorPivot.rotation.y = DOOR_OPEN_ANGLE;
    const doorInteract = interactables.find(i => i.type === 'door');
    if (doorInteract) doorInteract.label = 'Close Door';
  }

  // Rebuild purchased furniture
  if (save.ownedFurniture) {
    const builders = { lavaLamp: buildLavaLamp, fishTank: buildFishTank, treadmill: buildTreadmill, jukebox: buildJukebox };
    save.ownedFurniture.forEach(id => {
      ownedFurniture.add(id);
      if (builders[id]) builders[id]();
    });
    rebuildInteractMeshes();
  }

  // Restore car and town state
  if (save.hasCar) {
    hasCar = true;
    carGroup = buildCar();
    carGroup.position.set(12, 0.15, -6);
    carGroup.rotation.y = Math.PI / 2;
    scene.add(carGroup);
    const carBody = carGroup.children[0];
    interactables.push({ mesh: carBody, group: carGroup, type: 'car', label: 'Drive to Town', need: null, usePos: new THREE.Vector3(11, 0.15, -5), floor: 0 });
    rebuildInteractMeshes();
  }
  if (save.questLog) questLog = save.questLog;
  if (save.questsCompleted) questsCompleted = save.questsCompleted;
  if (save.jobLastDay) jobLastDay = save.jobLastDay;
  if (save.totalShiftsWorked) totalShiftsWorked = save.totalShiftsWorked;
  if (save.inTown && save.hasCar) {
    if (!townGroup) {
      townGroup = buildTown();
      buildTownNPCs();
    }
    townGroup.visible = true;
    inTown = true;
    scene.fog.far = TOWN_FOG_FAR;
    sunLight.shadow.camera.left = -60;
    sunLight.shadow.camera.right = 60;
    sunLight.shadow.camera.top = 40;
    sunLight.shadow.camera.bottom = -40;
    sunLight.shadow.camera.updateProjectionMatrix();
  }

  // Restore mansion state
  if (save.hasMansion) {
    hasMansion = true;
    document.getElementById('drive-mansion-btn').style.display = '';
  }
  if (save.inMansion && save.hasCar) {
    if (!mansionGroup) { mansionGroup = buildMansion(); }
    mansionGroup.visible = true;
    inMansion = true;
    scene.fog.far = MANSION_FOG_FAR;
    sunLight.shadow.camera.left = -80;
    sunLight.shadow.camera.right = 80;
    sunLight.shadow.camera.top = 50;
    sunLight.shadow.camera.bottom = -50;
    sunLight.shadow.camera.updateProjectionMatrix();
  }

  // Load G Bux content
  mlLoadGBuxContent();

  // Re-check achievements based on restored state
  mlTry('ml_new_home');
  if (day >= 3) mlTry('ml_survivor');
  if (day >= 7) mlTry('ml_week_warrior');
  if (ownedFurniture.size > 0 || hasCar) mlTry('ml_shopaholic');
  if (ownedFurniture.size >= 4) mlTry('ml_interior_designer');
  if (ownedOutfits.size > 1) mlTry('ml_fashion_icon');
  if (hasSecondFloor) mlTry('ml_moving_up');
  if (Math.floor(money) >= 500) mlTry('ml_high_roller');
  if (booksRead >= 3) mlTry('ml_bookworm');
  if (treadmillUses >= 3) mlTry('ml_gym_rat');
  if (questsCompleted >= 1) mlTry('ml_helpful_neighbor');
  if (questsCompleted >= 4) mlTry('ml_town_hero');
  if (hasMansion) mlTry('ml_mansion_mogul');
  if (totalShiftsWorked >= 1) mlTry('ml_first_shift');
  if (totalShiftsWorked >= 10) mlTry('ml_hard_worker');
  if (totalShiftsWorked >= 25) mlTry('ml_employee_month');
  mlCheckLivingLarge();
}

function deleteSlot(index) {
  if (!confirm('Delete this save?')) return;
  localStorage.removeItem('minilife-slot-' + index);
  const slots = getSlotsMetadata();
  slots[index] = null;
  setSlotsMetadata(slots);
  renderSlotList();
}

// Migrate old single-save format
(function migrateSave() {
  const oldSave = localStorage.getItem('minilife-save');
  if (oldSave && !localStorage.getItem('minilife-slots')) {
    localStorage.setItem('minilife-slot-0', oldSave);
    const save = JSON.parse(oldSave);
    setSlotsMetadata([{ name: 'Save 1', day: save.day || 1, money: save.money || 0 }, null, null]);
    localStorage.removeItem('minilife-save');
  }
})();

// Render save slots on page load
renderSlotList();

// ═══ RENDER LOOP ═══
function animate() {
  requestAnimationFrame(animate);
  update();
  renderer.render(scene, camera);

  // Mirror character rotation
  if (mirrorOpen && mirrorRenderer && mirrorChar) {
    mirrorAngle += 0.012;
    mirrorChar.rotation.y = mirrorAngle;
    mirrorRenderer.render(mirrorScene, mirrorCam);
  }

  // Preview character rotation
  if (!gameStarted) {
    previewAngle += 0.01;
    previewChar.rotation.y = previewAngle;
    prevRenderer.render(prevScene, prevCamera);
  }
}
animate();

// Resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
